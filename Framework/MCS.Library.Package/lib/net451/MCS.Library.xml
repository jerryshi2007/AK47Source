<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MCS.Library</name>
    </assembly>
    <members>
        <member name="T:MCS.Library.Accessories.BuilderBase`1">
            <summary>
            基于反射的创建者基类，该基类继承自IBuilder接口。
            </summary>
            <typeparam name="T">实例的类型</typeparam>
            <remarks>基于反射的创建者基类，该基类继承自IBuilder接口。</remarks>
        </member>
        <member name="T:MCS.Library.Accessories.IBuilder`1">
            <summary>
            基于反射的创建者类接口，该接口实现了创建者模式。
            </summary>
            <typeparam name="T">实例的类型</typeparam>
            <remarks>基于反射的创建者类接口，该接口实现了创建者模式。
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.IBuilder`1.BuildUp(`0)">
            <summary>
            创建指定类型的实例。
            </summary>
            <param name="target">需要创建的实例</param>
            <returns>已创建的实例。</returns>
            <remarks>创建指定类型的实例。</remarks>
        </member>
        <member name="M:MCS.Library.Accessories.IBuilder`1.TearDown(`0)">
            <summary>
            拆开指定类型的实例。
            </summary>
            <param name="target">需要拆开的实例</param>
            <returns>已拆开的实例</returns>
            <remarks>拆开指定类型的实例。</remarks>
        </member>
        <member name="M:MCS.Library.Accessories.BuilderBase`1.BuildUp(`0)">
            <summary>
            创建指定类型的实例。
            </summary>
            <param name="target">需要创建的实例</param>
            <returns>指定类型的实例</returns>
            <remarks>
            创建指定类型的实例。
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.BuilderBase`1.TearDown(`0)">
             <summary>
            拆开指定类型的实例。
             </summary>
             <param name="target">需要拆开的实例</param>
             <returns>已拆开的实例</returns>
             <remarks>拆开指定类型的实例。</remarks>
        </member>
        <member name="M:MCS.Library.Accessories.BuilderBase`1.CreateInstance(System.String,System.Object[])">
            <summary>
            根据全类型名称动态的创建指定类型的实例。 
            </summary>
            <param name="typeName">类型名称</param>
            <param name="constructorParams">创建实例的参数</param>
            <returns>指定类型的实例对象</returns>
            <remarks>
            根据全类型名称动态的创建指定类型的实例，该创建实例过程用到了反射机制。
            </remarks>
        </member>
        <member name="T:MCS.Library.Accessories.ChainBase`1">
            <summary>
            职责链模式的基类，实现了IChain(职责链Interface)接口。
            </summary>
            <typeparam name="T">职责链中每一个节点的类型</typeparam>
            <remarks>
            该基类提供对职责链的基本操作实现，对于链对象的插入以及数据获取。
            </remarks>
        </member>
        <member name="T:MCS.Library.Accessories.IChain`1">
            <summary>
            职责链模式接口，该接口实现了职责链模式。
            </summary>
            <typeparam name="T">职责链中每一个节点的类型</typeparam>
            <remarks>
            该接口提供对职责链的基本操作，包括添加一个节点，添加一组节点等等。   
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.IChain`1.Add(`0)">
            <summary>
            向职责链中添加一个节点
            </summary>
            <param name="item">需要向职责链中添加的节点</param>
            <remarks>
            向职责链中添加一个节点
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.IChain`1.AddRange(System.Collections.IEnumerable)">
            <summary>
            向职责链中添加一组节点。
            </summary>
            <param name="items">节点组</param>
            <remarks>
            向职责链中添加一系列节点。
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.IChain`1.GetNext(`0)">
            <summary>
            在职责链中获得当前节点的下一个节点。
            </summary>
            <param name="current">当前的节点</param>
            <returns>获取职责链的指定节点的下一个节点，如果指定的节点为空或当前节点的下一个节点为空，则返回空。</returns>
            <remarks>
            获得职责链中指定节点的下一个节点。
            </remarks>
        </member>
        <member name="P:MCS.Library.Accessories.IChain`1.Head">
            <summary>
            职责链的第一个节点
            </summary>
            <remarks>
            该属性是只读的
            </remarks>
        </member>
        <member name="F:MCS.Library.Accessories.ChainBase`1.chainItems">
            <summary>
            保存责任链中每一项的表。
            </summary>
            <remarks>保存责任链中每一项的表</remarks>
        </member>
        <member name="M:MCS.Library.Accessories.ChainBase`1.#ctor">
            <summary>
            不带参数的构造函数
            </summary>
            <remarks>不带参数的构造函数
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ChainBaseTest.cs" region="Test IChain and ChainBase" lang="cs" title="在DeluxeWorks里如何实现责任链模式" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.ChainBase`1.Add(`0)">
            <summary>
            向职责链中添加一个节点
            </summary>
            <param name="item">需要向职责链中添加的节点</param>
            <remarks>
            向职责链中添加一个节点
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ChainBaseTest.cs" region="Test IChain and ChainBase" lang="cs" title="在DeluxeWorks里如何实现责任链模式"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.ChainBase`1.AddRange(System.Collections.IEnumerable)">
            <summary>
            向职责链中添加一组节点。
            </summary>
            <param name="items">节点组</param>
            <remarks>
            向职责链中添加一组节点。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ChainBaseTest.cs" region="Test IChain and ChainBase" lang="cs" title="在DeluxeWorks里如何实现责任链模式"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.ChainBase`1.GetNext(`0)">
            <summary>
            在职责链中获得当前节点的下一个节点。
            </summary>
            <param name="current">当前的节点</param>
            <returns>获取职责链的当前节点的下一个节点，如果指定的节点为空或当前节点的下一个节点为空，则返回空。
            </returns>
            <remarks>
            获得职责链中指定节点的下一个节点
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ChainBaseTest.cs" region="Test IChain and ChainBase" lang="cs" title="在DeluxeWorks里如何实现责任链模式"/>
            </remarks>
        </member>
        <member name="P:MCS.Library.Accessories.ChainBase`1.Head">
            <summary>
            职责链的第一个节点
            </summary>
            <remarks>
            职责链的第一个节点，该属性是只读的。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ChainBaseTest.cs" region="Test IChain and ChainBase" lang="cs" title="在DeluxeWorks里如何实现责任链模式" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Accessories.FilterPipelineBase`2">
            <summary>
            过滤器基类，该基类实现了IFilter接口。
            </summary>
            <typeparam name="TFilter">过滤器的类型</typeparam>
            <typeparam name="TTarget">需要过滤的实例的类型</typeparam>
            <remarks>例如：在过滤器中存放了很多的限制条件，若实例满足过滤器中的所有限制条件，则该实例需要进行某种处理，否则进行另一种处理。
            </remarks>
        </member>
        <member name="F:MCS.Library.Accessories.FilterPipelineBase`2.pipeline">
            <summary>
            过滤器队列对象
            </summary>
            <remarks>
            过滤器队列对象，用于处理内部过滤器集合
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.FilterPipelineBase`2.Add(`0)">
            <summary>
            向过滤器中添加新的一个过滤项
            </summary>
            <param name="filter">过滤项</param>
            <remarks>
            向过滤器中添加新的一个过滤项。
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.FilterPipelineBase`2.Remove(`0)">
            <summary>
            从过滤器中移除一个过滤项
            </summary>
            <param name="filter">过滤项</param>
            <remarks>从过滤器中移除一个过滤项
            </remarks>
        </member>
        <member name="M:MCS.Library.Accessories.FilterPipelineBase`2.IsMatch(`1)">
            <summary>
            判断实例是否满足过滤器中每一项的限制条件。
            </summary>
            <param name="target">需要进行过滤的实例</param>
            <returns>若实例满足过滤器中每一项的所有限制条件则返回真，否则返回假。</returns>
            <remarks>判断实例是否满足过滤器中每一项的限制条件，若满足则返回真，否则返回假。
            </remarks>
        </member>
        <member name="T:MCS.Library.Accessories.IFilter`1">
            <summary>
            过滤器的接口，该接口实现了过滤器模式。
            </summary>
            <typeparam name="T">过滤器需要过滤的实例类型</typeparam>
            <remarks>例如：在过滤器中存放了很多的限制条件，若实例满足过滤器中的所有限制条件，则该实例需要进行某种处理，否则进行另一种处理。</remarks>
        </member>
        <member name="M:MCS.Library.Accessories.IFilter`1.IsMatch(`0)">
            <summary>
            判断实例是否满足过滤器中的所有限制条件。
            </summary>
            <param name="target">需要过滤的实例</param>
            <returns>布尔类型，若实例满足过滤器中的所有限制条件则返回true，否则返回false。</returns>
            <remarks>判断与给定的实例是否匹配,返回布尔值。
            </remarks>
        </member>
        <member name="P:MCS.Library.Accessories.IFilter`1.Name">
            <summary>
            逻辑名称
            </summary>
            <remarks>在实现时，用户需要得到pipeline的逻辑名称，则可以从这里存取逻辑名称。该属性是可读可写的。</remarks>
        </member>
        <member name="T:MCS.Library.Accessories.IStrategy`2">
            <summary>
            策略模式，实现了IStrategy接口。
            </summary>
            <remarks>
            定义抽象的Stragegy对象计算过程，实际开发中可以根据计算的要求借助 StrategyContextBase 对象来组织相关的计算内容。
            </remarks>
            <typeparam name="TData">计算对象类型</typeparam>
            <typeparam name="TResult">计算结果类型</typeparam>
        </member>
        <member name="M:MCS.Library.Accessories.IStrategy`2.Calculate(`0)">
            <summary>
            根据输入信息计算结果的算法部分
            </summary>
            <param name="data">输入数据</param>
            <returns>算法计算结果</returns>
            <remarks>根据输入信息计算结果的算法部分</remarks>
        </member>
        <member name="T:MCS.Library.Accessories.StrategyContextBase`2">
            <summary>
            策略模式，实现了Strategy Context 。
            </summary>
            <remarks>
            组合 IStragegy 对象计算过程。
            </remarks>
            <typeparam name="TStrategy">计算对象类型</typeparam>
            <typeparam name="TResult">计算结果类型</typeparam>
        </member>
        <member name="F:MCS.Library.Accessories.StrategyContextBase`2.innerStrategy">
            <summary>
            Context 需要操作的算法对象
            </summary>
        </member>
        <member name="M:MCS.Library.Accessories.StrategyContextBase`2.DoAction">
            <summary>
            可以覆盖的抽象 IStragegy 类型各方法计算过程，作为抽象 Context 类型这里仅完成基本的 Calculate 方法调用。
            </summary>
            <returns>内部计算的结果值</returns>
            <remarks>
            可以覆盖的抽象 IStragegy 类型各方法计算过程，作为抽象 Context 类型这里仅完成基本的 Calculate 方法调用。
            </remarks>
        </member>
        <member name="P:MCS.Library.Accessories.StrategyContextBase`2.Strategy">
            <summary>
            定义具体的算法类型
            </summary>
            <remarks>
            定义具体的算法类型
            </remarks>
        </member>
        <member name="T:MCS.Library.Caching.CacheItemBase">
            <summary>
            CacheItem的基类
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheItemBase.#ctor(MCS.Library.Caching.CacheQueueBase)">
            <summary>
            构造方法
            </summary>
            <param name="cacheQueueBase"></param>
        </member>
        <member name="M:MCS.Library.Caching.CacheItemBase.RemoveCacheItem">
            <summary>
            在Cache队列中清除Cache项
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheItemBase.SetChanged">
            <summary>
            将此CacheItem设置为必须更新
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheItemBase.Dispose">
            <summary>
            实现IDisposable接口
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheItemBase.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:MCS.Library.Caching.CacheItemBase.GetKeyValue">
            <summary>
            得到CacheItem对应的Key和Value
            </summary>
            <returns>获得CacheItem的Key和Value，需要派生类重载</returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheItemBase.SetValue(System.Object)">
            <summary>
            设置CacheItem的值
            </summary>
            <param name="value">为CacheItem设置Value</param>
        </member>
        <member name="P:MCS.Library.Caching.CacheItemBase.Queue">
            <summary>
            当前Cache项所属于的CacheQueue。
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheItemBase.Dependency">
            <summary>
            属性，获取或设置与此CacheItem相关联的Dependency
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheManager">
            <summary>
            全局静态类，通过注册方式统一管理应用域内所有CacheQueue
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheManager.GetInstance``1">
            <summary>
            注册函数，应用域中全部类型的CacheQueue对象均通过此
            函数进行注册，如果应用域中已经存在相同类型的CacheQueue对象，则将其引用返回
            以保证系统内每一种类型的CacheQueue对象是唯一的
            </summary>
            <typeparam name="T">泛型类型</typeparam>
            <returns>返回注册CacheQueue对象的引用</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\CacheManagerTest.cs" region="RegisterCacheTest" lang="cs" title="注册自定义的CacheQueue对象" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.CacheManager.GetInstance(System.Type)">
            <summary>
            注册函数，应用域中全部类型的CacheQueue对象均通过此
            函数进行注册，如果应用域中已经存在相同类型的CacheQueue对象，则将其引用返回
            以保证系统内每一种类型的CacheQueue对象是唯一的
            </summary>
            <param name="type">Cache队列的类型</param>
            <returns>返回注册CacheQueue对象的引用</returns>
            <remarks>
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.CacheManager.GetAllCacheInfo">
            <summary>
            获得所有Cache队列的信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheManager.ClearAllCache">
            <summary>
            清空所有的缓存
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheManager.StartScavengeThread">
            <summary>
            启动一个清理线程，完成一次清理工作
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheManager.InitScavengingThread">
            <summary>
            初始化并启动后台清理线程
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheManager.ScavengeCache">
            <summary>
            CacheQueue的清理方法
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheManager.InScavengeThread">
            <summary>
            表示当前是否处于后台清理状态，此属性主要用于在Cache队列内部判断当前是清理线程的工作状态中。
            在CacheQueue或Dependency的内部，可以通过此状态判断调用者是否是清理线程
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheModule">
            <summary>
            用于Web应用清理Cache的HttpModule
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheModule.Dispose">
            <summary>
            释放对象
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheModule.Init(System.Web.HttpApplication)">
            <summary>
            初始化
            </summary>
            <param name="context">HttpApplication对象</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheModule.RenderQueueInfo(System.Web.UI.HtmlTextWriter,MCS.Library.Caching.CacheQueueInfo)">
            <summary>
            渲染一个Cache队列的内容
            </summary>
            <param name="writer"></param>
            <param name="queueInfo"></param>
        </member>
        <member name="M:MCS.Library.Caching.CacheModule.RenderCacheQueueClearButton(System.Web.UI.HtmlTextWriter,System.String)">
            <summary>
            渲染清理Cache的按钮
            </summary>
            <param name="writer"></param>
            <param name="queueTypeName"></param>
        </member>
        <member name="M:MCS.Library.Caching.CacheModule.RenderCacheQueueItemsInfo(System.Web.UI.HtmlTextWriter,MCS.Library.Caching.CacheQueueInfo)">
            <summary>
            渲染每一条Cache项
            </summary>
            <param name="writer"></param>
            <param name="queueInfo"></param>
        </member>
        <member name="T:MCS.Library.Caching.CacheItemInfo">
            <summary>
            Cache项信息
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheItemInfo.Key">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheItemInfo.Value">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheItemInfoCollection">
            <summary>
            Cache项信息的集合
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheItemInfoCollection.Add(MCS.Library.Caching.CacheItemInfo)">
            <summary>
            增加一项
            </summary>
            <param name="info"></param>
        </member>
        <member name="P:MCS.Library.Caching.CacheItemInfoCollection.Item(System.Int32)">
            <summary>
            取得第n项信息
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.CacheQueueInfo">
            <summary>
            Cache队列信息
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueueInfo.QueueTypeName">
            <summary>
            Cache队列的名称
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueueInfo.QueueTypeFullName">
            <summary>
            Cache队列的全名
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueueInfo.Count">
            <summary>
            Cache队列中的项数
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheQueueInfoCollection">
            <summary>
            Cache队列信息的集合
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueueInfoCollection.Add(MCS.Library.Caching.CacheQueueInfo)">
            <summary>
            增加一项
            </summary>
            <param name="info"></param>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueueInfoCollection.Item(System.Int32)">
            <summary>
            取得第n项信息
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifierSettings">
            <summary>
            Cache通知的附加设置
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifierSettings.GetConfig">
            <summary>
            获取cacheNotifierSettings的配置信息
            </summary>
            <returns>UdpCacheNotifierSettings实例</returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifierSettings.OnDeserializeUnrecognizedAttribute(System.String,System.String)">
            <summary>
            返回true。主要是当配置文件改了之后为了保持兼容性
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifierSettings.OnDeserializeUnrecognizedElement(System.String,System.Xml.XmlReader)">
            <summary>
            返回true。主要是当配置文件改了之后为了保持兼容性
            </summary>
            <param name="elementName"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierSettings.ForwardUdpToMmf">
            <summary>
            将接收到的Udp通知转发到内存映射文件的通知项中
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierSettings.EnableMmfNotifier">
            <summary>
            是否启用内存映射文件的通知
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifyType">
            <summary>
            Cache变更通知类型
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyType.Invalid">
            <summary>
            数据已经非法
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyType.Update">
            <summary>
            数据修改，变更通知中，包含已经变更的数据
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyType.Clear">
            <summary>
            清除所有数据
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifyData">
            <summary>
            Cache变更时的数据包
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyData.EmptyData">
            <summary>
            空集合数组
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyData.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyData.#ctor(System.Type,System.Object,MCS.Library.Caching.CacheNotifyType)">
            <summary>
            构造方法
            </summary>
            <param name="queueType">Cache队列的类型</param>
            <param name="key">Cache的key</param>
            <param name="nType">通知的类型</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyData.FromBuffer(System.IO.Stream)">
            <summary>
            从Stream还原CacheNotifyData
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyData.FromBuffer(System.Byte[])">
            <summary>
            从byte[]还原CacheNotifyData
            </summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyData.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyData.ToBytes">
            <summary>
            转换为字节数组
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifyData.NotifyType">
            <summary>
            通知的类型
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifyData.CacheQueueType">
            <summary>
            Cache队列的类型
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifyData.CacheQueueTypeDesp">
            <summary>
            Cache队列的类型描述
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifyData.CacheData">
            <summary>
            Cache项的数据
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifyData.CacheKey">
            <summary>
            Cache项的Key
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifyDataMap">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMap.MappedFileTag">
            <summary>
            映射文件的标识
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMap.MutextTag">
            <summary>
            互斥量的标识
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMap.MutexTimeout">
            <summary>
            互斥量等待的超时时间
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyDataMap.GetTotalMemorySize">
            <summary>
            得到总内存尺寸
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyDataMap.OpenFile(System.IO.FileMode)">
            <summary>
            打开文件
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyDataMap.ResetMap">
            <summary>
            重置所有数据
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyDataMap.GetCacheNotifyDataMapInfo">
            <summary>
            返回Memory Mapped中的Cache通知信息的头信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyDataMap.WriteCacheNotifyData(MCS.Library.Caching.CacheNotifyData[])">
            <summary>
            将一组通知数据写入到内存映射文件中
            </summary>
            <param name="notifyData"></param>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyDataMap.WriteNotExistCacheNotifyData(System.Int64,MCS.Library.Caching.CacheNotifyData[])">
            <summary>
            将一组Key不存在的通知数据写入到内存映射文件中，避免重复写入
            </summary>
            <param name="lastTicks">内存映射文件中在此Ticks之后的通知数据</param>
            <param name="notifyData"></param>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyDataMap.ReadCacheNotifyData(System.Int64@)">
            <summary>
            读取在Memory Mapped中的所有Cache通知信息。并且返回最后的Ticks
            </summary>
            <param name="lastTicks">最后的执行Ticks，这个值也可以返回为最大的Ticks</param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifyDataMapInfo">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMapInfo.CacheDataBlockSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMapInfo.CacheDataItemCount">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMapInfo.TotalMapSize">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMapInfo.Tag">
            <summary>
            内存标记
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMapInfo.Mark">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMapInfo.Pointer">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyDataMapInfo.Clone">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifyDataMapItem">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMapItem.Ticks">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheNotifyDataMapItem.Size">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifyFetcherBase">
            <summary>
            消息通知数据获取器的基类
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyFetcherBase.Init">
            <summary>
            初始化数据
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyFetcherBase.GetInterval">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyFetcherBase.GetData">
            <summary>
            获取数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyFetcherBase.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyFetcherBase.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifyKey">
            <summary>
            Cache通知的Key
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyKey.GetHashCode">
            <summary>
            重载哈希算法
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifyKey.CacheQueueType">
            <summary>
            类型队列的类型
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifyKey.CacheKey">
            <summary>
            Cache通知的Key
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifyKeyToDependencies">
            <summary>
            CacheNotifyKey和依赖项之间的关系
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyKeyToDependencies.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifyKeyToDependencies.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:MCS.Library.Caching.CookieCacheDependency">
            <summary>
            基于Cookie的Cache依赖项
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.DependencyBase">
            <summary>
            所有Dependency的抽象基类，此基类实现了IDisposable接口
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.DependencyBase.SetChanged">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.DependencyBase.CacheItemBinded">
            <summary>
            当Dependency对象绑定到CacheItem时，会调用此方法。此方法被调用时，保证Dependency的CacheItem属性已经有值
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.DependencyBase.Dispose">
            <summary>
            实现IDisposable接口
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.DependencyBase.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:MCS.Library.Caching.DependencyBase.CacheItem">
            <summary>
            Dependency所依赖的CacheItem
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.DependencyBase.UtcLastModified">
            <summary>
            属性,获取或设置Cache项最后修改时间的UTC时间值
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.DependencyBase.UtcLastAccessTime">
            <summary>
            属性,获取或设置Cache项的最后访问时间的UTC时间值
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.DependencyBase.HasChanged">
            <summary>
            属性,获取此Dependency是否过期
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CookieCacheDependency.#ctor(System.Web.HttpCookie)">
            <summary>
            构造方法
            </summary>
            <param name="cookie">cookie</param>
        </member>
        <member name="P:MCS.Library.Caching.CookieCacheDependency.HasChanged">
            <summary>
            是否发生改变
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CookieCacheDependency.UtcLastModified">
            <summary>
            最后修改日期
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.FileCacheDependency">
            <summary>
            文件依赖，客户端代码在初始化此类的对象时，需要提供一个文件名数组，
            当此数组中的任何一个文件发生变化时，认为与此依赖项相关的Cache项过期。
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.FileCacheDependency.syncObject">
            <summary>
            同步对象
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.#ctor(System.String[])">
            <summary>
            构造方法
            </summary>
            <param name="fileNames">Cache项依赖的文件名称</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\FileCacheDependencyTest.cs" region="FileCacheDependencyConstructorTest" lang="cs" title="指定依赖的文件名列表" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.#ctor(System.Boolean,System.String[])">
            <summary>
            构造方法
            </summary>
            <param name="ifne">是否忽略不存在的文件，如置为false，则文件不存在会抛出异常</param>
            <param name="fileNames">Cache项依赖的文件名称</param>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.SetChanged">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.Dispose(System.Boolean)">
            <summary>
            释放资源，包括内部的FileSystemWatcher
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.CacheItemBinded">
            <summary>
            当此Dependency绑定到CacheItem时
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.FileCacheDependency.FileNames">
            <summary>
            文件名集合
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\FileCacheDependencyTest.cs" region="FileCacheDependencyFileNamesTest" lang="cs" title="文件名列表，只读" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Caching.FileCacheDependency.HasChanged">
            <summary>
            是否发生改变
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\FileCacheDependencyTest.cs" region="FileDependencyChangeContentTest" lang="cs" title="获取本Dependency是否过期" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Caching.FileCacheDependency.FileDependencyReadOnlyCollection">
            <summary>
            为了实现大小写问题，
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.FileDependencyReadOnlyCollection.#ctor(System.Collections.Generic.List{System.String})">
            <summary>
            构造函数
            </summary>
            <param name="ls">初始化用的List</param>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.FileDependencyReadOnlyCollection.Contains(System.String)">
            <summary>
            判断集合中是否含有某个字符串，但在判断之前将字符串转化为大写
            </summary>
            <param name="key">需要搜索的字符串</param>
            <returns>是否存在</returns>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.FileDependencyReadOnlyCollection.IndexOf(System.String)">
            <summary>
            返回指定键的索引
            </summary>
            <param name="key">键值</param>
            <returns>键值索引</returns>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.DirToFileSystemWatcherItem.#ctor(System.String,System.IO.FileSystemEventHandler,System.IO.RenamedEventHandler)">
            <summary>
            查看系统文件组
            </summary>
            <param name="directory">目录</param>
            <param name="fse">文件系统事件句柄</param>
            <param name="re">Reamed事件句柄</param>
        </member>
        <member name="T:MCS.Library.Caching.FileCacheDependency.FileNameToFileCacheDependenciesItem">
            <summary>
            文件名称的FileDependency的映射
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.FileCacheDependency.FileNameToFileCacheDependenciesItem.#ctor(System.String)">
            <summary>
            获取文件名称
            </summary>
            <param name="dependenceFileName">缓存依赖文件的名称</param>
        </member>
        <member name="T:MCS.Library.Caching.ICacheNotifier">
            <summary>
            Cache通知发送者的接口
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.ICacheNotifier.SendNotify(MCS.Library.Caching.CacheNotifyData[])">
            <summary>
            同步发送Cache通知
            </summary>
            <param name="notifyDataArray"></param>
        </member>
        <member name="M:MCS.Library.Caching.ICacheNotifier.SendNotifyAsync(MCS.Library.Caching.CacheNotifyData[])">
            <summary>
            异步发送Cache通知
            </summary>
            <param name="notifyDataArray"></param>
        </member>
        <member name="T:MCS.Library.Caching.MemoryMappedFileCacheMonitor">
            <summary>
            内存映射文件的监听器
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.NotifierCacheMonitorBase">
            <summary>
            Cache变化的监听器的积累
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheMonitorBase.EnsureMonitorNotifyThread">
            <summary>
            确保监听线程被创建
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheMonitorBase.DoCacheChanged(MCS.Library.Caching.CacheNotifyData)">
            <summary>
            处理Cache项的改变
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheMonitorBase.CreateLogger">
            <summary>
            创建Logger。如果出现异常则有可能为空
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheMonitorBase.WriteCacheNotifyDataToLog(MCS.Library.Logging.Logger,MCS.Library.Caching.CacheNotifyData)">
            <summary>
            将CacheNotifyData写入日志
            </summary>
            <param name="logger"></param>
            <param name="notifyData"></param>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheMonitorBase.CreateLogEntity(MCS.Library.Caching.CacheNotifyData)">
            <summary>
            创建Log项
            </summary>
            <param name="notifyData"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheMonitorBase.GetDataFetcher">
            <summary>
            获得CacheNotifyData读取器
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheMonitorBase.MonitorThreadMethod">
            <summary>
            监听线程方法
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.NotifierCacheMonitorBase.CacheItems">
            <summary>
            通知的Key的依赖项之间的关系
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.MemoryMappedFileCacheMonitor.Instance">
            <summary>
            监听器的实例
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.MemoryMappedFileCacheMonitor.GetDataFetcher">
            <summary>
            得到数据获取器
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.MemoryMappedFileCacheMonitor.CreateLogEntity(MCS.Library.Caching.CacheNotifyData)">
            <summary>
            创建接收到消息的日志对象
            </summary>
            <param name="notifyData"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.MemoryMappedFileNotifierCacheDependency">
            <summary>
            内存映射文件的Cache依赖项
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.NotifierCacheDependencyBase">
            <summary>
            通知类Cache依赖项的基类
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheDependencyBase.SetChanged">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheDependencyBase.GetNotifyKey">
            <summary>
            根据Cache项得到通知的Key
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheDependencyBase.CacheItemBinded">
            <summary>
            当CacheItem加入到Cache队列中时
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheDependencyBase.Dispose(System.Boolean)">
            <summary>
            释放资源
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:MCS.Library.Caching.NotifierCacheDependencyBase.GetMonitor">
            <summary>
            得到监听器的实例
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.NotifierCacheDependencyBase.HasChanged">
            <summary>
            是否改变
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.MemoryMappedFileNotifierCacheDependency.GetMonitor">
            <summary>
            得到监听器
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.MemoryMappedFileCacheNotifyFetcher">
            <summary>
            内存映射文件的通知获取器
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.MemoryMappedFileCacheNotifyFetcher.lastTicks">
            <summary>
            最后一次Cache项的Ticks
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.MemoryMappedFileCacheNotifyFetcher.GetData">
            <summary>
            获取数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.MemoryMappedFileCacheNotifyFetcher.GetInterval">
            <summary>
            轮询间隔
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.MmfCacheNotifier">
            <summary>
            基于内存映射文件发送Cache通知
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.MmfCacheNotifier.Instance">
            <summary>
            内部构建的实体对象，单件模式的表现方式
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.MmfCacheNotifier.SendNotify(MCS.Library.Caching.CacheNotifyData[])">
            <summary>
            同步发送Cache通知
            </summary>
            <param name="notifyDataArray"></param>
        </member>
        <member name="M:MCS.Library.Caching.MmfCacheNotifier.SendNotifyAsync(MCS.Library.Caching.CacheNotifyData[])">
            <summary>
            异步发送Cache通知
            </summary>
            <param name="notifyDataArray"></param>
        </member>
        <member name="T:MCS.Library.Caching.UdpCacheNotifyFetcher">
            <summary>
            Udp消息通知数据获取器
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifyFetcher.Init">
            <summary>
            初始化
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifyFetcher.GetData">
            <summary>
            获取数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifyFetcher.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:MCS.Library.Caching.UdpNotifierCacheMonitor">
            <summary>
            UdpCache变化的监听器
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.UdpNotifierCacheMonitor.Instance">
            <summary>
            监听器的实例
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpNotifierCacheMonitor.GetDataFetcher">
            <summary>
            获取CacheNotifyData读取器
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.UdpNotifierCacheMonitor.CreateLogEntity(MCS.Library.Caching.CacheNotifyData)">
            <summary>
            创建接收到消息的日志对象
            </summary>
            <param name="notifyData"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.CachePerformanceCounterInstaller">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CachePerformanceCounterInstaller.Instance">
            <summary>
            性能监控指针的安装类实例，用于初始化PerformanceCounters类
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CachePerformanceCounterInstaller.#ctor">
            <summary>
            初始化性能计数器安装
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CachePerformanceCounterInstaller.Dispose(System.Boolean)">
            <summary> 
            清空已经存在安装信息
            </summary>
            <param name="disposing">是否清空</param>
        </member>
        <member name="M:MCS.Library.Caching.CachePerformanceCounterInstaller.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CacheQueue`2">
            <summary>
            一泛型Cache类，内部通过LRU算法实现了一个Cache项的队列，
            当Cache项的数量超过预先设定的Cache容量时，将自动把队列尾部的Cache项清除
            用户在使用此Cache时需要从此类派生
            </summary>
            <typeparam name="TKey">键值类型</typeparam>
            <typeparam name="TValue">值类型</typeparam>
        </member>
        <member name="T:MCS.Library.Caching.CacheQueueBase">
            <summary>
            Cache队列的虚基类
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueueBase.Clear">
            <summary>
            清除Cache队列
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueueBase.SetChanged">
            <summary>
            是否都标记为更新
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueueBase.RemoveItem(MCS.Library.Caching.CacheItemBase)">
            <summary>
            虚方法，删除Cache项
            </summary>
            <param name="cacheItem">被删除的Cache项</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueueBase.GetAllItemsInfo">
            <summary>
            得到所有项的描述信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueueBase.ToString">
            <summary>
            重载ToString。输出内部的项数
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueueBase.#ctor">
            <summary>
            构造方法，初始化性能指针
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueueBase.#ctor(System.String)">
            <summary>
            构造方法，初始化性能指针
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueueBase.InitPerformanceCounters(System.String)">
            <summary>
            初始化性能监视指针
            </summary>
            <param name="instanceName">本地性能监视器的指针</param>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueueBase.Count">
            <summary>
            Cache项的数量
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueueBase.TotalCounters">
            <summary>
            所有Cache的性能指针
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueueBase.Counters">
            <summary>
            性能指针
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.IScavenge">
            <summary>
            接口，各中CacheQueue通过实现此接口完成自身的清理工作
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.IScavenge.DoScavenging">
            <summary>
            Cache对列清理方法
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.CacheQueue`2.innerDictionary">
            <summary>
            采用LRU算法保存Cache项的字典
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.#ctor">
            <summary>
            构造函数，没有设置CacheQueue的容量大小，则使用默认值100
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.#ctor(System.Boolean)">
            <summary>
            构造方法
            </summary>
            <param name="overrideExists">Add Cache项时，是否覆盖已有的数据</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.#ctor(System.Boolean,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="overrideExists"></param>
            <param name="instanceName"></param>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.#ctor(System.Boolean,System.String,System.Int32)">
            <summary>
            构造方法
            </summary>
            <param name="overrideExists"></param>
            <param name="instanceName"></param>
            <param name="maxLength"></param>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.Add(`0,`1)">
            <summary>
            向CacheQueue中增加一Cache项值对，如果相应的key已经存在，则抛出异常
            此种构造方法无相关Dependency，所以此增加Cache项不会过期，只可能当CacheQueue
            的长度超过预先设定时，才可能被清理掉
            </summary>
            <param name="key">键</param>
            <param name="data">值</param>
            <returns>值</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\CacheQueueTest.cs" region="AddRemoveClearTest" lang="cs" title="增加、移除、获取CacheItem项" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.Add(`0,`1,MCS.Library.Caching.DependencyBase)">
            <summary>
            向CacheQueue中增加一个有关联Dependency的Cache项，如果相应的key已经存在，则抛出异常
            </summary>
            <param name="key">键</param>
            <param name="data">值</param>
            <param name="dependency">依赖：相对时间依赖、绝对时间依赖、文件依赖或混合依赖</param>
            <returns>值</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\CacheQueueTest.cs" region="AddRemoveClearTest" lang="cs" title="增加、移除、获取CacheItem项" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.TryGetValue(`0,`1@)">
            <summary>
            通过key，获取Cache项的value，如果相应的cache项存在的话
            则将cache项的value作为输出参数，返回给客户端代码
            </summary>
            <param name="key">cache项的key</param>
            <param name="data">cache项的value</param>
            <returns>如果CacheQueue中包含此Cache项，则返回true，否则返回false</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\CacheQueueTest.cs" region="GetCacheItemTest" lang="cs" title="通过key，获取Cache项的value" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.GetOrAddNewValue(`0,MCS.Library.Caching.CacheQueue{`0,`1}.CacheItemNotExistsAction)">
            <summary>
            在Cache中读取Cache项，如果不存在，则调用action
            </summary>
            <param name="key">键值</param>
            <param name="action">不存在时的回调</param>
            <returns>Cache项的值</returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.Remove(`0)">
            <summary>
            通过key，删除一Cache项
            </summary>
            <param name="key">缓存唯一标识</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\CacheQueueTest.cs" region="AddRemoveClearTest" lang="cs" title="增加、移除、获取CacheItem项" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.RemoveItem(MCS.Library.Caching.CacheItemBase)">
            <summary>
            重载基类方法，删除传入的CacheItem
            </summary>
            <param name="cacheItem">缓存队列对象</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.ContainsKey(`0)">
            <summary>
            判断CacheQueue中是否包含key键的Cache项
            </summary>
            <param name="key">查询的cache项的键值</param>
            <returns>如果包含此键值，返回true，否则返回false</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\CacheQueueTest.cs" region="AddRemoveClearTest" lang="cs" title="增加、移除、获取CacheItem项" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.SetChanged">
            <summary>
            全部更新了
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.Clear">
            <summary>
            清空整个CacheQueue，删除CacheQueue中所有的Cache项
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\CacheQueueTest.cs" region="AddRemoveClearTest" lang="cs" title="增加、移除、获取CacheItem项" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.DoScavenging">
            <summary>
            清理方法，清理本CacheQueue中过期的cache项
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.CheckDependencyChanged(`0,MCS.Library.Caching.CacheItem{`0,`1})">
            <summary>
            判断一Cache项是否过期
            </summary>
            <param name="key">Cache项的键值</param>
            <param name="item">Cache项</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.InnerRemove(`0,MCS.Library.Caching.CacheItem{`0,`1})">
            <summary>
            删除Cache项
            </summary>
            <param name="key">Cache项键值</param>
            <param name="item">Cache项</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheQueue`2.GetAllItemsInfo">
            <summary>
            得到所有项的信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueue`2.MaxLength">
            <summary>
            属性，获取CacheQueue的最大容量
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueue`2.Count">
            <summary>
            属性，获取CacheQueue中的存储的Cache项的数量
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheQueue`2.Item(`0)">
            <summary>
            通过Cache项的key获取Cache项Value的索引器
            </summary>
            <param name="key">cache项key</param>
            <returns>cache项Value</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\CacheQueueTest.cs" region="GetCacheItemTest" lang="cs" title="通过Cache项的key获取Cache项Value" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Caching.CacheQueue`2.CacheItemNotExistsAction">
            <summary>
            Cache项不存在时的委托定义
            </summary>
            <param name="cache">Cache对列</param>
            <param name="key">键值</param>
            <returns>新的Cache项</returns>
        </member>
        <member name="T:MCS.Library.Caching.CacheSettingsSection">
            <summary>
            Cache的配置信息
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.DeluxeConfigurationSection">
            <summary>
            配置节的基类。允许不识别的属性存在
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.DeluxeConfigurationSection.OnDeserializeUnrecognizedAttribute(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheSettingsSection.GetConfig">
            <summary>
            获取Cache的配置信息
            </summary>
            <returns>Cache的配置信息</returns>
        </member>
        <member name="P:MCS.Library.Caching.CacheSettingsSection.DefaultQueueLength">
            <summary>
            缺省的队列长度
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheSettingsSection.EnableCacheInfoPage">
            <summary>
            是否启用网页中显示Cache信息
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheSettingsSection.ScanvageInterval">
            <summary>
            清理间隔
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheSettingsSection.QueueSettings">
            <summary>
            具体每个Cache队列的设置
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.QueueSettingCollection">
            <summary>
            每个Cache队列的设置集合
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.QueueSettingCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            获取配置元素的键值
            </summary>
            <param name="element">配置元素</param>
            <returns>键值</returns>
        </member>
        <member name="M:MCS.Library.Caching.QueueSettingCollection.CreateNewElement">
            <summary>
            创建配置元素
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.QueueSettingCollection.Item(System.Type)">
            <summary>
            获取指定类型的队列设置
            </summary>
            <param name="type">类型</param>
            <returns>队列设置</returns>
        </member>
        <member name="T:MCS.Library.Caching.QueueSetting">
            <summary>
            每个Cache队列的设置
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.QueueSetting.CacheDefaultQueueLength">
            <summary>
            默认Cache队列长度
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.QueueSetting.TypeName">
            <summary>
            对象的类型名称
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.QueueSetting.QueueLength">
            <summary>
            队列的深度
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.CachingPerformanceCounters">
            <summary>
            和Cache有关的性能计数器包装
            </summary>
        </member>
        <member name="T:MCS.Library.Core.PerformanceCountersWrapperBase">
            <summary>
            命中类型的性能监视指针们的基类，常用于Cache的性能监控。
            里面包含了一组指针
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCountersWrapperBase.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCountersWrapperBase.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="instanceName">实例名称</param>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCountersWrapperBase.#ctor(System.Diagnostics.PerformanceCounterInstaller,System.String)">
            <summary>
            构造方法，从Installer类构造
            </summary>
            <param name="installer"></param>
            <param name="instanceName"></param>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCountersWrapperBase.GetInstanceName">
            <summary>
            根据环境信息得到实例的名称
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCountersWrapperBase.GetCounter(System.String)">
            <summary>
            得到计数器
            </summary>
            <param name="counterName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CachingPerformanceCounters.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="instanceName">实例名称</param>
        </member>
        <member name="P:MCS.Library.Caching.CachingPerformanceCounters.EntriesCounter">
            <summary>
            Cache项的计数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CachingPerformanceCounters.HitsCounter">
            <summary>
            命中次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CachingPerformanceCounters.MissesCounter">
            <summary>
            没有命中的次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CachingPerformanceCounters.HitRatioCounter">
            <summary>
            命令率中的命中次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CachingPerformanceCounters.HitRatioBaseCounter">
            <summary>
            命中率中的总访问数
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.ContextCacheQueueBase">
            <summary>
            在调用上下文中缓存的Cache队列的基类，该Cache的生命期，仅仅在当前线程（WinForm）或一次Http（Web）)请求过程中
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.ContextCacheQueueBase`2">
            <summary>
            在调用上下文中缓存的泛型Cache队列的基类，该Cache的生命期，仅仅在当前线程（WinForm）或一次Http（Web）)请求过程中
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.ContextCacheQueueBase`2.Add(`0,`1)">
            <summary>
            在Cach队列中添加一项
            </summary>
            <param name="key">键</param>
            <param name="data">值</param>
            <returns>值</returns>
        </member>
        <member name="M:MCS.Library.Caching.ContextCacheQueueBase`2.TryGetValue(`0,`1@)">
            <summary>
            通过key，获取Cache项的value，如果相应的cache项存在的话
            则将cache项的value作为输出参数，返回给客户端代码 
            </summary>
            <param name="key">键</param>
            <param name="data">值</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.ContextCacheQueueBase`2.GetOrAddNewValue(`0,MCS.Library.Caching.ContextCacheQueueBase{`0,`1}.ContextCacheItemNotExistsAction)">
            <summary>
            在Cache中读取Cache项，如果不存在，则调用action
            </summary>
            <param name="key">键值</param>
            <param name="action">不存在时的回调</param>
            <returns>Cache项的值</returns>
        </member>
        <member name="M:MCS.Library.Caching.ContextCacheQueueBase`2.Remove(`0)">
            <summary>
            按照键值，删除一项Cache项
            </summary>
            <param name="key">键</param>
            <returns>是否成功删除</returns>
        </member>
        <member name="M:MCS.Library.Caching.ContextCacheQueueBase`2.Clear">
            <summary>
            清空所有Cache项
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.ContextCacheQueueBase`2.ContainsKey(`0)">
            <summary>
            是否包含某键值
            </summary>
            <param name="key">键</param>
            <returns>是否包含</returns>
        </member>
        <member name="M:MCS.Library.Caching.ContextCacheQueueBase`2.GetEnumerator">
            <summary>
            枚举Cache的每一项
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.ContextCacheQueueBase`2.Item(`0)">
            <summary>
            按照键值获取或设置Cache的值
            </summary>
            <param name="key">键</param>
            <returns>值</returns>
        </member>
        <member name="P:MCS.Library.Caching.ContextCacheQueueBase`2.Count">
            <summary>
            Cache项的数量
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.ContextCacheQueueBase`2.ContextCacheItemNotExistsAction">
            <summary>
            Cache项不存在时的委托定义
            </summary>
            <param name="cache">Cache对列</param>
            <param name="key">键值</param>
            <returns>新的Cache项</returns>
        </member>
        <member name="T:MCS.Library.Caching.ContextCacheManager">
            <summary>
            在调用上下文中缓存的Cache管理器，该Cache的生命期，仅仅在当前线程（WinForm）或一次Http（Web）)请求过程中
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.ContextCacheManager.GetInstance``1">
            <summary>
            获取Cache队列的实例，如果该队列没有被缓存，可以动态创建一个实例
            </summary>
            <typeparam name="T">Cache队列的类型</typeparam>
            <returns>Cache队列的实例</returns>
        </member>
        <member name="M:MCS.Library.Caching.ContextCacheManager.Current_OperationCompleted(System.Object,System.EventArgs)">
            <summary>
            在WCF操作结束后，清除当前的上下文缓存
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:MCS.Library.Caching.ObjectContextCache">
            <summary>
            存放Key和Value都是object的ContextCache
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.ObjectContextCache.Instance">
            <summary>
            ObjectContextCache的实例，此处必须是属性，动态计算
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.UdpCacheClientSettings">
            <summary>
            与Udp Cache通知机制相关的配置信息
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheClientSettings.GetConfig">
            <summary>
            获取udpCacheNotifierSettings的配置信息
            </summary>
            <returns>UdpCacheNotifierSettings实例</returns>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheClientSettings.GetPorts">
            <summary>
            得到端口号的数组
            </summary>
            <returns>端口号的数组</returns>
        </member>
        <member name="P:MCS.Library.Caching.UdpCacheClientSettings.Address">
            <summary>
            ip地址
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.UdpCacheClientSettings.InnerIPAddress">
            <summary>
            ip地址
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.UdpCacheNotifier">
            <summary>
            通过Udp方式发送消息，该Class使用了单件模式，直接使用UdpCacheNotifier.Instance
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.UdpCacheNotifier.Instance">
            <summary>
            内部构建的实体对象，单件模式的表现方式
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifier.SendNotify(MCS.Library.Caching.CacheNotifyData[])">
            <summary>
            发送Cache通知
            </summary>
            <param name="notifyDataArray">Cache通知数据</param>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifier.SendNotifyAsync(MCS.Library.Caching.CacheNotifyData[])">
            <summary>
            异步发送Cache通知
            </summary>
            <param name="notifyDataArray">Cache通知数据</param>
        </member>
        <member name="T:MCS.Library.Caching.UdpNotifierCacheDependency">
            <summary>
            基于Udp通知的CacheDepenedency
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpNotifierCacheDependency.GetMonitor">
            <summary>
            得到监听器
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.UdpCacheNotifierSettings">
            <summary>
            基于Udp的Cache通知器的配置信息
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifierSettings.GetConfig">
            <summary>
            获取udpCacheNotifierSettings的配置信息
            </summary>
            <returns>UdpCacheNotifierSettings实例</returns>
        </member>
        <member name="P:MCS.Library.Caching.UdpCacheNotifierSettings.PackageSize">
            <summary>
            数据包大小，缺省为1200个字节
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.UdpCacheNotifierSettings.EndPoints">
            <summary>
            发送的端点
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.UdpCacheNotifierTargetCollection">
            <summary>
            UdpCacheNotifierTarget集合
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifierTargetCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            得到元素的Key
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifierTargetCollection.CreateNewElement">
            <summary>
            创建新元素
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.UdpCacheNotifierTarget">
            <summary>
            基于Udp的Cache通知器的发送目标
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifierTarget.GetPorts">
            <summary>
            得到端口号的数组
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.UdpCacheNotifierTarget.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.UdpCacheNotifierTarget.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.UdpCacheNotifierTarget.Address">
            <summary>
            ip地址
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.UdpCacheNotifierTarget.InnerIPAddress">
            <summary>
            ip地址
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UdpSettingsHelper.GetPorts(System.String)">
            <summary>
            将由字符串表示，以“,”的一组端口号转换为由int数组表示。
            </summary>
            <param name="portsDefine">由字符串表示的一组端口号</param>
            <returns>以int数组表示的一组端口号</returns>
        </member>
        <member name="T:MCS.Library.Caching.CacheNotifierPerformanceCounters">
            <summary>
            Udp通知的相关性能指针
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.CacheNotifierPerformanceCounters.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="instanceName">实例名称</param>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.UdpSentItemsCounter">
            <summary>
            Udp通知已经发送到次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.UdpReceivedItemsCounter">
            <summary>
            Udp通知已经接收到的次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.MmfCurrentPointer">
            <summary>
            Mmf的当前指针位置
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.MmfSentItemsCounter">
            <summary>
            MemoryeMappedFile已经发送到次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.MmfReceivedItemsCounter">
            <summary>
            Mmf通知已经接收到的次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.ForwardedUdpToMmfItems">
            <summary>
            从Udp转发到Mmf的Cache通知的个数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.UdpSentCountPerSecond">
            <summary>
            每秒Udp通知的发送次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.UdpReceivedCountPerSecond">
            <summary>
            每秒Udp通知的接收次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.MmfSentCountPerSecond">
            <summary>
            每秒Mmf通知的发送次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.MmfReceivedCountPerSecond">
            <summary>
            每秒Mmf通知的接收次数
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.CacheNotifierPerformanceCounters.ForwardUdpToMmfCountPerSecond">
            <summary>
            每秒从Udp转发到Mmf通知的次数
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.ServiceMethodCache">
            <summary>
            Web服务方法的Cache队列。这里面存放了同一个方法，不同的参数所对应的返回值
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.ServiceMethodCache.#ctor(System.String,System.Int32)">
            <summary>
            构造方法
            </summary>
            <param name="instanceName"></param>
            <param name="maxLength"></param>
        </member>
        <member name="T:MCS.Library.Caching.ServiceMethodCacheManager">
            <summary>
            这个管理类管理了每一个服务方法的缓存队列，它本身受全局的CacheManager管理
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.ServiceMethodCacheManager.Instance">
            <summary>
            Cache的实例
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.StringTableContextCache">
            <summary>
            字符串表的上下文缓存，以字符串为key，字符串为值的队列。仅存放于上下文中
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.StringTableContextCache.Instance">
            <summary>
            StringTableContextCache的实例，此处必须是属性，动态计算
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.SwitchContextCache">
            <summary>
            开关表的上下文缓存，以字符串为key，bool为值的队列。仅存放于上下文中
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.SwitchContextCache.Instance">
            <summary>
            SwitchContextCache的实例，此处必须是属性，动态计算
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.TypeMembersCacheQueue`1">
            <summary>
            为类型的成员提供Cache功能
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.TypePropertiesCacheQueueBase">
            <summary>
            为类型的Properties提供Cache功能的基类
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.TypePropertiesCacheQueueBase.GetProperties(System.Type)">
            <summary>
            得到类型的属性信息。必须重载
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.TypePropertiesCacheQueueBase.GetPropertyInfo(System.Type,System.String)">
            <summary>
            得到类型的属性定义
            </summary>
            <param name="type"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.TypePropertiesCacheQueueBase.GetPropertyDictionary(System.Type)">
            <summary>
            得到属性字典。属性名称为Key
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.TypePropertiesCacheQueueBase.GetPropertyInfoDirectly(System.Type,System.String)">
            <summary>
            得到类型的属性定义
            </summary>
            <param name="type"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.TypePropertiesCacheQueueBase.GetObjectPropertyValue(System.Object,System.String)">
            <summary>
            得到对象的属性值
            </summary>
            <param name="target"></param>
            <param name="propertyName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.TypePropertiesCacheQueueBase.SetObjectPropertyValue(System.Object,System.String,System.Object)">
            <summary>
            设置对象的属性值
            </summary>
            <param name="target"></param>
            <param name="propertyName"></param>
            <param name="value"></param>
        </member>
        <member name="T:MCS.Library.Caching.TypePropertiesWithNonPublicCacheQueue">
            <summary>
            得到类型的实例化的公有或私有的属性
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.TypePropertiesWithNonPublicCacheQueue.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.TypePropertiesWithNonPublicCacheQueue.GetProperties(System.Type)">
            <summary>
            得到类型的基本属性（Instance, Public，NonPublic）
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.TypeFlattenHierarchyPropertiesCacheQueue">
            <summary>
            为类型的实例化，公有的Properties提供Cache功能
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.TypeFlattenHierarchyPropertiesCacheQueue.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.TypeFlattenHierarchyPropertiesCacheQueue.GetProperties(System.Type)">
            <summary>
            得到类型的基本属性（Instance, Public，继承的）
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.TypePropertiesCacheQueue">
            <summary>
            为类型的Properties提供Cache功能
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.TypePropertiesCacheQueue.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.TypePropertiesCacheQueue.GetProperties(System.Type)">
            <summary>
            得到类型的基本属性（Instance, Public，非继承的）
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Caching.UriContextCache">
            <summary>
            Uri对象的上下文缓存
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.UriContextCache.GetUri(System.String)">
            <summary>
            得到字符串所对应的Uri对象。
            </summary>
            <param name="uriString"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.UriContextCache.Instance">
            <summary>
            此处必须是属性，动态计算，不能是ReadOnly变量
            </summary>
        </member>
        <member name="T:MCS.Web.Library.WebXmlDocumentCache">
            <summary>
            Web应用中，Xml文档对象的缓存类
            </summary>
        </member>
        <member name="M:MCS.Web.Library.WebXmlDocumentCache.GetXmlDocument(System.String)">
            <summary>
            从虚目录加载Xml文档，加载过的文档会缓存在Cache中
            </summary>
            <param name="virtualPath"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Web.Library.WebXmlDocumentCache.GetDocument(System.String)">
            <summary>
            得到虚拟目录所对应文件的文本
            </summary>
            <param name="virtualPath"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Web.Library.WebXmlDocumentCacheQueue">
            <summary>
            存储XmlDocument的Cache Queue
            </summary>
        </member>
        <member name="T:MCS.Library.Compression.Crc32">
            <summary>
            CRC32校验算法
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.Crc32.crc">
            <summary>
            The crc data checksum so far.
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.Crc32.Reset">
            <summary>
            重置CRC32校验和
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.Crc32.Update(System.Byte[])">
            <summary>
            用byte数组更新校验和
            </summary>
            <param name="buffer">
            byte数组
            </param>
        </member>
        <member name="M:MCS.Library.Compression.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将byte数组添加到校验和中
            </summary>
            <param name = "buf">需要添加到校验和中的byte数组</param>
            <param name = "off">byte数组添加部分的起始位置索引</param>
            <param name = "len">byte数组添加部分的长度</param>
        </member>
        <member name="P:MCS.Library.Compression.Crc32.Value">
            <summary>
            CRC32校验和
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.Accessories.BestDirectoryMatchStrategy">
            <summary>
            寻找目录层次中最匹配一项的算法
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.Accessories.BestPathMatchStrategyBase">
            <summary>
            路径最贴近匹配算法实现类
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.BestPathMatchStrategyBase.Calculate(System.Collections.Generic.IList{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            IStrategy IList 的抽象实现
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.BestPathMatchStrategyBase.IsDirectory(System.String)">
            <summary>
            判断某个路径是否为目录
            </summary>
            <param name="folderPath">路径</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.BestPathMatchStrategyBase.FileterPath(MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection,System.Boolean)">
            <summary>
            依照路径类型（文件/目录）和格式筛选路径
            </summary>
            <param name="instances">MetaConfigurationSourceInstanceElementCollection</param>
            <param name="isDirectory">是否目录</param>
            <returns>KeyValuePair 中 Value 为 meta.config 文件, key 为application 路径</returns>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.BestPathMatchStrategyBase.FormatPath(System.String)">
            <summary>
            将路径去除空格并转换为小写
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.Accessories.BestPathMatchStrategyBase.Candidates">
            <summary>
            待筛选的文件内容
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.BestDirectoryMatchStrategy.#ctor(MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection)">
            <summary>
            构造函数
            </summary>
            <param name="instances">MetaConfigurationSourceInstanceElementCollection对象（集合）</param>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.BestDirectoryMatchStrategy.Calculate(System.Collections.Generic.IList{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            从路径列表里选择与目标路径最贴近的一项。
            </summary>
            <param name="items">路径列表</param>
            <returns>最贴近项目</returns>
        </member>
        <member name="T:MCS.Library.Configuration.Accessories.PathMatchStrategyContext">
            <summary>
            路径匹配算法计算过程定义 Context
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.PathMatchStrategyContext.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.PathMatchStrategyContext.DoAction">
            <summary>
            根据抽象算法类型组织计算过程
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Configuration.Accessories.BestFileNameMatchStrategy">
            <summary>
            寻找最匹配的文件算法
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.BestFileNameMatchStrategy.#ctor(MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection)">
            <summary>
            构造函数
            </summary>
            <param name="instances">MetaConfigurationSourceInstanceElementCollection对象（集合）</param>
        </member>
        <member name="M:MCS.Library.Configuration.Accessories.BestFileNameMatchStrategy.Calculate(System.Collections.Generic.IList{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            从路径列表里选择与目标路径最贴近的一项。
            </summary>
            <param name="items">路径列表</param>
            <returns>最贴近项目</returns>
        </member>
        <member name="T:MCS.Library.Configuration.AssemblyMappingSettings">
            <summary>
             Assembly名字映射的配置节
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.AssemblyMappingSettings.GetConfig">
            <summary>
            Assembly名字映射的配置信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.AssemblyMappingSettings.Mapping">
            <summary>
            映射
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.AssemblyMappingConfigurationElement">
            <summary>
            Assembly名字映射条目
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.NamedConfigurationElement">
            <summary>
            以名字为键值的配置项
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.NamedConfigurationElement.OnDeserializeUnrecognizedAttribute(System.String,System.String)">
            <summary>
            返回true。主要是当配置文件改了之后为了保持兼容性
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.NamedConfigurationElement.OnDeserializeUnrecognizedElement(System.String,System.Xml.XmlReader)">
            <summary>
            返回true。主要是当配置文件改了之后为了保持兼容性
            </summary>
            <param name="elementName"></param>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.NamedConfigurationElement.Name">
            <summary>
            Uri的逻辑名称
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.NamedConfigurationElement.Description">
            <summary>
            描述
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.AssemblyMappingConfigurationElement.MapTo">
            <summary>
            类型描述信息
            </summary>
            <remarks>一般采用QualifiedName （QuanlifiedTypeName, AssemblyName）方式</remarks>
        </member>
        <member name="T:MCS.Library.Configuration.AssemblyMappingConfigurationElementCollection">
            <summary>
            Assembly名字映射条目集合
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.NamedConfigurationElementCollection`1">
            <summary>
            以名字为键值的配置元素集合
            </summary>
            <typeparam name="T">配置元素类型</typeparam>
        </member>
        <member name="M:MCS.Library.Configuration.NamedConfigurationElementCollection`1.ContainsKey(System.String)">
            <summary>
            是否包含指定的配置元素
            </summary>
            <param name="name">配置元素名称</param>
            <returns>是否包含</returns>
        </member>
        <member name="M:MCS.Library.Configuration.NamedConfigurationElementCollection`1.CheckAndGet(System.String)">
            <summary>
            检查并且获取对应的项，如果不存在，则抛出异常
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.NamedConfigurationElementCollection`1.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            得到元素的Key值
            </summary>
            <param name="element">配置元素</param>
            <returns>配置元素所对应的配置元素</returns>
        </member>
        <member name="M:MCS.Library.Configuration.NamedConfigurationElementCollection`1.CreateNewElement">
            <summary>
            生成新的配置元素实例
            </summary>
            <returns>配置元素实例</returns>
        </member>
        <member name="M:MCS.Library.Configuration.NamedConfigurationElementCollection`1.InnerGet(System.String)">
            <summary>
            通过name在字典内查找数据，如果name不存在，则抛出异常，本方法可重载
            </summary>
            <param name="name">名称</param>
            <returns>配置元素</returns>
        </member>
        <member name="P:MCS.Library.Configuration.NamedConfigurationElementCollection`1.Item(System.Int32)">
            <summary>
            按照序号获取指定的配置元素
            </summary>
            <param name="index">序号</param>
            <returns>配置元素</returns>
        </member>
        <member name="P:MCS.Library.Configuration.NamedConfigurationElementCollection`1.Item(System.String)">
            <summary>
            按照名称获取指定的配置元素
            </summary>
            <param name="name">名称</param>
            <returns>配置元素</returns>
        </member>
        <member name="T:MCS.Library.Configuration.ConfigurationExceptionHelper">
            <summary>
            和Config异常有关的异常辅助方法
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationExceptionHelper.CheckSectionNotNull(System.Configuration.ConfigurationSection,System.String)">
            <summary>
            检查section是否为空，如果为空，会抛出异常
            </summary>
            <param name="section">section对象</param>
            <param name="sectionName">section的名称，会在异常信息中出现</param>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationExceptionHelper.CheckSectionSource(System.Configuration.ConfigurationSection,System.String)">
            <summary>
            检查section的source是否为空，如果为空，会抛出异常。这个检查会先执行CheckSectionNotNull
            </summary>
            <param name="section">section对象</param>
            <param name="sectionName">section的名称，会在异常信息中出现</param>
        </member>
        <member name="T:MCS.Library.Configuration.ConfigurationExtension">
            <summary>
            Configuration有关的扩展方法
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationExtension.GetSectionRelativeFile(System.Configuration.Configuration,System.Configuration.ConfigurationSection)">
            <summary>
            得到Section的相关文件
            </summary>
            <param name="config"></param>
            <param name="section"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationExtension.GetSectionRecursively(System.Configuration.Configuration,System.String)">
            <summary>
            从Configuration中读取某个Section，递归查找组
            </summary>
            <param name="config"></param>
            <param name="sectionName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationExtension.GetSectionFromGroups(System.String,System.Configuration.ConfigurationSectionGroupCollection)">
            <summary>
            从SectionGroup中读取Section。在Section写在Group里时使用
            </summary>
            <param name="sectionName">section name</param>
            <param name="groups">SectionGroup</param>
            <returns>ConfigurationSection</returns>
        </member>
        <member name="T:MCS.Library.Configuration.IdentityConfigSettings">
            <summary>
            登录身份的配置信息
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.IdentityConfigSettings.GetConfig">
            <summary>
            从配置文件中得到服务器配置信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.IdentityConfigSettings.Identities">
            <summary>
            服务器配置信息集合
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.IdentityConfigurationElement">
            <summary>
            定义基本用户信息凭据的配置元素.    
            </summary>     
        </member>
        <member name="M:MCS.Library.Configuration.IdentityConfigurationElement.ToLogOnIdentity">
            <summary>
            转换为LogOnIdentity
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.IdentityConfigurationElement.UserId">
            <summary>
            用户编号
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.IdentityConfigurationElement.Password">
            <summary>
            密码
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.IdentityConfigurationElement.Domain">
            <summary>
            用户所在的域
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.IdentityConfigurationElement.IsIntegrated">
            <summary>
            是否采用集成认证方式
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.IdentityConfigurationElementCollection">
            <summary>
            装载基本用户信息凭据的配置元素集合
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.ServerInfoConfigSettings">
            <summary>
            服务器配置信息
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.ServerInfoConfigSettings.GetConfig">
            <summary>
            从配置文件中得到服务器配置信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.ServerInfoConfigSettings.ServerInfos">
            <summary>
            服务器配置信息集合
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.ServerInfoConfigureElement">
            <summary>
            每一个服务器配置信息的配置项
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.ServerInfoConfigureElement.ToServerInfo">
            <summary>
            转换为ServerInfo对象
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.ServerInfoConfigureElement.ServerName">
            <summary>
            服务器名称
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.ServerInfoConfigureElement.IdentityName">
            <summary>
            登录服务器的Identity配置项的名称
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.ServerInfoConfigureElement.Port">
            <summary>
            使用服务器的端口号
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.ServerInfoConfigureElement.AuthenticateType">
            <summary>
            服务器的认证方式
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.AuthenticateType">
            <summary>
            服务器的认证方式
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.AuthenticateType.Anonymous">
            <summary>
            匿名
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.AuthenticateType.Basic">
            <summary>
            基本认证
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.AuthenticateType.NTLM">
            <summary>
            NTLM认证
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.ServerInfoConfigureElementCollection">
            <summary>
            服务器配置项的集合
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.TenantContextSettings">
            <summary>
            租户上下文配置信息
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.TenantContextSettings.GetConfig">
            <summary>
            从配置信息中获取租户上下文相关的配置信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.TenantContextSettings.Enabled">
            <summary>
            是否启用多租户模式
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.TenantContextSettings.DefaultTenantCode">
            <summary>
            默认的租户代码
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.TimePointSimulationSettings">
            <summary>
            模拟时间点的设置
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.TimePointSimulationSettings.GetConfig">
            <summary>
            得到模拟时间点的设置信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.TimePointSimulationSettings.Enabled">
            <summary>
            是否启用
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.TimePointSimulationSettings.CookieKey">
            <summary>
            如果保存为Cookie，Cookie的Key的名称
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.TimePointSimulationSettings.DefaultSimulatedTime">
            <summary>
            默认的模拟时间
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.TimePointSimulationSettings.Persister">
            <summary>
            持久化器
            </summary>
        </member>
        <member name="T:MCS.Library.Core.ActionContextBase`1">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ActionContextBase`1.DoActions(System.Action)">
            <summary>
            执行<paramref name="action"/>指定的操作。
            </summary>
            <param name="action">操作方法 或 <see langword="null"/>表示无操作。</param>
        </member>
        <member name="M:MCS.Library.Core.ActionContextBase`1.Clear">
            <summary>
            清除上下文
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ActionContextBase`1.Current">
            <summary>
            从ObjectContextCache获取上下文对象
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ActionContextBase`1.Context">
            <summary>
            获取一个保存上下文对象的<see cref="T:Dictionary^2"/>。
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ActionContextBase`1.ExistsInContext">
            <summary>
            是否在上下文中存在
            </summary>
        </member>
        <member name="T:MCS.Library.Core.ActionContextDescriptionAttribute">
            <summary>
            描述ActionContext的Key信息
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ActionContextDescriptionAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ActionContextDescriptionAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="key"></param>
        </member>
        <member name="P:MCS.Library.Core.ActionContextDescriptionAttribute.Key">
            <summary>
            Key值，这个值用于ObjectContextQueue中Key值
            </summary>
        </member>
        <member name="T:MCS.Library.Core.IPersistTimePoint">
            <summary>
            保存TimePoint的接口
            </summary>
        </member>
        <member name="M:MCS.Library.Core.IPersistTimePoint.LoadTimePoint(System.String)">
            <summary>
            加载TimePoint
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.IPersistTimePoint.SaveTimePoint(System.String,System.DateTime)">
            <summary>
            保存TimePoint
            </summary>
            <param name="key"></param>
            <param name="simulatedTime"></param>
        </member>
        <member name="T:MCS.Library.Core.TenantContext">
            <summary>
            租户相关的上下文信息
            </summary>
        </member>
        <member name="M:MCS.Library.Core.TenantContext.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="P:MCS.Library.Core.TenantContext.TenantCode">
            <summary>
            租户上下文
            </summary>
        </member>
        <member name="P:MCS.Library.Core.TenantContext.Enabled">
            <summary>
            是否启用租户上下文
            </summary>
        </member>
        <member name="T:MCS.Library.Core.TenantRelativeObjectAttribute">
            <summary>
            为对象添加此属性时，会在Adapter的基类中添加这个字段的处理
            </summary>
        </member>
        <member name="M:MCS.Library.Core.TenantRelativeObjectAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.TenantRelativeObjectAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="tenantCodeFieldName">租户编码的所对应的数据库字段，默认值是TENANT_CODE</param>
        </member>
        <member name="P:MCS.Library.Core.TenantRelativeObjectAttribute.TenantCodeFieldName">
            <summary>
            租户编码的所对应的数据库字段，默认值是TENANT_CODE
            </summary>
        </member>
        <member name="T:MCS.Library.Core.ArgumentsParser">
            <summary>
            命令行参数的分析器，将命令行参数解析为字符串数组
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ArgumentsParser.Parse(System.String[])">
            <summary>
            分析和格式化命令行参数，返回Key、Value的字典
            </summary>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.CookieHelper">
            <summary>
            Cookie相关的辅助方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.CookieHelper.GetRequestCookieValue``1(System.String,``0)">
            <summary>
            得到Http请求中的Cookie值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.CookieHelper.SetResponseCookieValue``1(System.String,``0)">
            <summary>
            在Response中创建Cookie，并且设置它的值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.EqualityComparerHandler`1">
            <summary>
            比较两个对象是否相等的delegate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.GeneralEqualityComparer`1">
            <summary>
            通用对象比较器，用于集合中的Distinct等操作
            </summary>
            <typeparam name="T">需要比较的数据类型</typeparam>
        </member>
        <member name="M:MCS.Library.Core.GeneralEqualityComparer`1.#ctor(MCS.Library.Core.EqualityComparerHandler{`0})">
            <summary>
            构造方法。
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:MCS.Library.Core.GeneralEqualityComparer`1.Equals(`0,`0)">
            <summary>
            判断x，y是否相等
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.GeneralEqualityComparer`1.GetHashCode(`0)">
            <summary>
            得到对象的Hashcode
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.IProcessProgressResponser">
            <summary>
            如何将处理过程输出的接口
            </summary>
        </member>
        <member name="M:MCS.Library.Core.IProcessProgressResponser.Register(MCS.Library.Core.ProcessProgress)">
            <summary>
            注册Responser，这里可以初始化一些参数，如Output和Error
            </summary>
            <param name="progress"></param>
        </member>
        <member name="M:MCS.Library.Core.IProcessProgressResponser.Response(MCS.Library.Core.ProcessProgress)">
            <summary>
            输出Progress信息
            </summary>
            <param name="progress"></param>
        </member>
        <member name="T:MCS.Library.Core.ISimpleXmlDeserializer">
            <summary>
            简单XML反序列化器
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ISimpleXmlDeserializer.FromXElement(System.Xml.Linq.XElement,System.String)">
            <summary>
            从一个XElement元素序列化对象
            </summary>
            <param name="element"></param>
            <param name="refNodeName">可参照的节点名称，如果此参数不为空，则从此名称的子节点序列化对象</param>
        </member>
        <member name="T:MCS.Library.Core.ISimpleXmlSerializer">
            <summary>
            简单XML序列化器
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ISimpleXmlSerializer.ToXElement(System.Xml.Linq.XElement,System.String)">
            <summary>
            将对象序列化到一个XElement元素上
            </summary>
            <param name="element"></param>
            <param name="refNodeName">可参照的节点名称，如果此参数不为空，则增加此名称的子节点</param>
        </member>
        <member name="T:MCS.Library.Core.MethodExtensions">
            <summary>
            MethodBase相关的扩展方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.MethodExtensions.GetMatchedMethodInfoByParameterNames(System.Collections.Generic.IEnumerable{System.Reflection.MethodBase},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            找到参数名称最匹配的方法
            </summary>
            <param name="mbs"></param>
            <param name="parameterNames"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.MethodExtensions.GetParamsMatchedLevel(System.Reflection.MethodBase,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            得到参数名称和方法参数的匹配度
            </summary>
            <param name="mi"></param>
            <param name="parameterNames"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.MethodExtensions.Invoke(System.Reflection.MethodBase,System.Object,System.Collections.Specialized.NameValueCollection)">
            <summary>
            根据参数，调用方法
            </summary>
            <param name="mi"></param>
            <param name="target"></param>
            <param name="reqParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.MethodExtensions.Invoke(System.Reflection.ConstructorInfo,System.Collections.Specialized.NameValueCollection)">
            <summary>
            根据参数，调用构造方法
            </summary>
            <param name="ci"></param>
            <param name="reqParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.MethodExtensions.IsCollectedParemeterClass(System.Type)">
            <summary>
            是否是可收集数据的类型
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.MethodExtensions.GetCollectedParameterInstance(System.Collections.Specialized.NameValueCollection,System.Type)">
            <summary>
            根据Request的参数得到可收集参数的值
            </summary>
            <param name="reqParams"></param>
            <param name="parameterType"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.TimePointContext">
            <summary>
            时间点上下文
            </summary>
        </member>
        <member name="M:MCS.Library.Core.TimePointContext.Clear">
            <summary>
            清除时间点模拟的上下文
            </summary>
        </member>
        <member name="M:MCS.Library.Core.TimePointContext.GetCurrentState">
            <summary>
            得到当前TimePointContext的值
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.TimePointContext.RestoreCurrentState(MCS.Library.Core.TimePointContext)">
            <summary>
            使用state的值恢复Current的值
            </summary>
            <param name="state"></param>
        </member>
        <member name="M:MCS.Library.Core.TimePointContext.LoadFromCookie">
            <summary>
            从Cookie中加载Context，Cookie的Key为TimePointSimulationSettings.GetConfig().CookieKey定义
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.TimePointContext.SaveToCookie">
            <summary>
            将Context保存到Cookie，Cookie的Key为TimePointSimulationSettings.GetConfig().CookieKey定义
            </summary>
        </member>
        <member name="P:MCS.Library.Core.TimePointContext.UseCurrentTime">
            <summary>
            是否使用当前时间
            </summary>
        </member>
        <member name="P:MCS.Library.Core.TimePointContext.SimulatedTime">
            <summary>
            获取仿真后的时间
            </summary>
        </member>
        <member name="P:MCS.Library.Core.TimePointContext.Current">
            <summary>
            获取时间点上下文对象
            </summary>
        </member>
        <member name="T:MCS.Library.Core.NameValueCollectionExtension">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.NameValueCollectionExtension.GetValue``1(System.Collections.Specialized.NameValueCollection,System.String,``0)">
            <summary>
            NameValueCollection的扩展，获取参数的值，并且转换为目标类型。如果不存在，则返回defaultValue
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="name"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.NameValueCollectionExtension.GetValue``1(System.Collections.Specialized.NameValueCollection,System.String,System.Boolean,``0)">
            <summary>
             NameValueCollection的扩展，获取参数的值，并且转换为目标类型。如果不存在，则返回defaultValue
            </summary>
            <typeparam name="T">返回值的类型</typeparam>
            <param name="collection">集合对象</param>
            <param name="name">集中的Key</param>
            <param name="urlDecode">是否进行urlDecode</param>
            <param name="defaultValue">默认值</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.NameValueCollectionExtension.CopyFrom(System.Collections.Specialized.NameValueCollection,System.Collections.Specialized.NameValueCollection)">
            <summary>
            从一个NameValueCollection复制到另一个NameValueCollection
            </summary>
            <param name="dest"></param>
            <param name="src"></param>
        </member>
        <member name="M:MCS.Library.Core.NameValueCollectionExtension.RemoveKeys(System.Collections.Specialized.NameValueCollection,System.String[])">
            <summary>
            删除NameValueCollection中指定的Key
            </summary>
            <param name="collection"></param>
            <param name="keysToRemove"></param>
        </member>
        <member name="M:MCS.Library.Core.NameValueCollectionExtension.ToUrlParameters(System.Collections.Specialized.NameValueCollection,System.Boolean)">
            <summary>
            转换为Url的参数串
            </summary>
            <param name="collection"></param>
            <param name="encodeUrl"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.NameValueCollectionExtension.ToUrlParameters(System.Collections.Specialized.NameValueCollection,System.Boolean,System.Text.Encoding)">
            <summary>
            转换为Url的参数串
            </summary>
            <param name="collection"></param>
            <param name="encodeUrl"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.LogonType">
            <summary>
            The type of logon operation to perform.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonType.Interactive">
            <summary>
            This logon type is intended for users who will be interactively using the computer, such as a user being logged on by a terminal server, remote shell, or similar process. This logon type has the additional expense of caching logon information for disconnected operations; therefore, it is inappropriate for some client/server applications, such as a mail server.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonType.Network">
            <summary>
            This logon type is intended for high performance servers to authenticate plaintext passwords. The LogonUser function does not cache credentials for this logon type.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonType.Batch">
            <summary>
            This logon type is intended for batch servers, where processes may be executing on behalf of a user without their direct intervention. This type is also for higher performance servers that process many plaintext authentication attempts at a time, such as mail or Web servers. The LogonUser function does not cache credentials for this logon type.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonType.Service">
            <summary>
            Indicates a service-type logon. The account provided must have the service privilege enabled.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonType.Unlock">
            <summary>
            This logon type is for GINA DLLs that log on users who will be interactively using the computer. This logon type can generate a unique audit record that shows when the workstation was unlocked.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonType.NetworkClearText">
            <summary>
            This logon type preserves the name and password in the authentication package, which allows the server to make connections to other network servers while impersonating the client. A server can accept plaintext credentials from a client, call LogonUser, verify that the user can access the system across the network, and still communicate with other servers.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonType.NewCredentials">
            <summary>
            This logon type allows the caller to clone its current token and specify new credentials for outbound connections. The new logon session has the same local identifier but uses different credentials for other network connections.<br/>
            This logon type is supported only by the LOGON32_PROVIDER_WINNT50 logon provider.
            </summary>
        </member>
        <member name="T:MCS.Library.Core.LogonProvider">
            <summary>
            LogonProvider
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonProvider.Default">
            <summary>
            Use the standard logon provider for the system.<br/>
            The default security provider is negotiate, unless you pass NULL for the domain name and the user name is not in UPN format. In this case, the default provider is NTLM.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonProvider.WinNT35">
            <summary>
            Use the Windows NT 3.5 logon provider.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonProvider.WinNT40">
            <summary>
            Use the NTLM logon provider.
            </summary>
        </member>
        <member name="F:MCS.Library.Core.LogonProvider.WinNT50">
            <summary>
            Use the negotiate logon provider.
            </summary>
        </member>
        <member name="T:MCS.Library.Core.NativeMethods">
            <summary>
            Windows API
            </summary>
        </member>
        <member name="T:MCS.Library.Core.PartitionedDictionary`2">
            <summary>
            带分区的字典，里面会根据Hash Code分散在不同的子Hash表中
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="count"></param>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.#ctor(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="count"></param>
            <param name="capacity"></param>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.#ctor(System.Int32,System.Int32,System.Collections.IEqualityComparer)">
            <summary>
            
            </summary>
            <param name="count"></param>
            <param name="capacity"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.Add(`0,`1)">
            <summary>
            在字典中添加一项
            </summary>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.Remove(`0)">
            <summary>
            在字典中删除一项
            </summary>
            <param name="key"></param>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.Clear">
            <summary>
            清除所有数据
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.ContainsKey(`0)">
            <summary>
            是否包含Key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            试图去获取Value，如果不为null，则返回true。这里和Dictionary(Key, Value)不一样。Value为null就表示不存在
            </summary>
            <param name="key">需要查找的Key</param>
            <param name="value">Key对应的Value</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.GetEnumerator">
            <summary>
            得到枚举器
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.PartitionedDictionary`2.GetAllPartitionsInfo">
            <summary>
            得到每一个分区的信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Core.PartitionedDictionary`2.ParitionCount">
            <summary>
            分区的个数
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PartitionedDictionary`2.Count">
            <summary>
            字典的总数
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PartitionedDictionary`2.AllPartitions">
            <summary>
            所有的分区信息
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PartitionedDictionary`2.SyncRoot">
            <summary>
            同步对象
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PartitionedDictionary`2.Item(`0)">
            <summary>
            根据Key访问数据
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Core.PartitionedDictionary`2.Keys">
            <summary>
            得到所有的Key
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PartitionedDictionary`2.Values">
            <summary>
            得到所有的Value
            </summary>
        </member>
        <member name="T:MCS.Library.Core.ProcessProgress">
            <summary>
            用来表示处理进度的类。它是上下文对象。运行时，当进度改变时，调用注册的插件进行进度处理。
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Initialize(System.Int32,System.Int32,System.Int32)">
            <summary>
            初始化
            </summary>
            <param name="minStep"></param>
            <param name="maxStep"></param>
            <param name="currentStep"></param>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Initialize(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            初始化步骤
            </summary>
            <param name="minStep"></param>
            <param name="maxStep"></param>
            <param name="currentStep"></param>
            <param name="status"></param>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.RegisterResponser(MCS.Library.Core.IProcessProgressResponser)">
            <summary>
            注册输出器
            </summary>
            <param name="responser"></param>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Response">
            <summary>
            调用输出器进行输出
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Response(System.String)">
            <summary>
            设置状态信息，调用输出器进行输出
            </summary>
            <param name="status"></param>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.GetDefaultOutput">
            <summary>
            得到默认的输出信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.GetDefaultError">
            <summary>
            得到默认的错误信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Increment">
            <summary>
            CurrentStep加1
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.IncrementBy(System.Int32)">
            <summary>
            CurrentStep增加nSteps，如果大于最大值，则等于最大值
            </summary>
            <param name="nSteps"></param>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Increment(System.String)">
            <summary>
            CurrentStep加1，并且设置状态信息
            </summary>
            <param name="status"></param>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Decrement(System.Int32)">
            <summary>
            CurrentStep减少nSteps，如果小于最小值，则等于最小值
            </summary>
            <param name="nSteps"></param>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Decrement">
            <summary>
            CurrentStep减1
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Decrement(System.String)">
            <summary>
            CurrentStep减1，并且设置状态信息
            </summary>
            <param name="status"></param>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Clear">
            <summary>
            清除当前上下文的ProcessProgress对象
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ProcessProgress.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ProcessProgress.MinStep">
            <summary>
            最小步骤
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ProcessProgress.MaxStep">
            <summary>
            最大的步骤
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ProcessProgress.CurrentStep">
            <summary>
            当前步骤
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ProcessProgress.StatusText">
            <summary>
            当前的描述信息
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ProcessProgress.Output">
            <summary>
            输出信息
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ProcessProgress.Error">
            <summary>
            输出的错误信息
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ProcessProgress.Current">
            <summary>
            返回当前上下文的ProcessProgress对象
            </summary>
        </member>
        <member name="T:MCS.Library.Core.UnknownSerializationType">
            <summary>
            未知的序列化类型。用于反序列化时，接住无法获取的类型信息。与UnknownTypeStrategyBinder配合使用
            </summary>
        </member>
        <member name="M:MCS.Library.Core.UnknownSerializationType.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.UnknownSerializationType.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Core.UnknownSerializationType.ToString">
            <summary>
            输出未知类型
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UnknownSerializationType.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:MCS.Library.Core.ValidatorSettings">
            <summary>
            注册和配置了系统相关的Validator，可以通过一个Key来表示一个Validator
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ValidatorSettings.GetConfig">
            <summary>
            得到Validator的配置信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Core.ValidatorSettings.Validators">
            <summary>
            Validator集合
            </summary>
        </member>
        <member name="T:MCS.Library.Core.ApplicationInformationException">
            <summary>
            应用程序提示信息类的异常
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ApplicationInformationException.#ctor">
            <summary>
            ApplicationInformationException的缺省构造函数
            </summary>
            <remarks>ApplicationInformationException的缺省构造函数.
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.ApplicationInformationException.#ctor(System.String)">
            <summary>
            ApplicationInformationException的带错误消息参数的构造函数
            </summary>
            <param name="strMessage">错误消息串</param>
            <remarks>ApplicationInformationException的带错误消息参数的构造函数,该错误消息将在消息抛出异常时显示出来。
            <seealso cref="T:MCS.Library.Expression.ExpTreeExecutor"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.ApplicationInformationException.#ctor(System.String,System.Exception)">
            <summary>
            ApplicationInformationException的构造函数。
            </summary>
            <param name="strMessage">错误消息串</param>
            <param name="ex">导致该异常的异常</param>
            <remarks>该构造函数把导致该异常的异常记录了下来。
            </remarks>
        </member>
        <member name="T:MCS.Library.Core.DataTypeConverterBase">
            <summary>
            数据类型转换器的基类
            </summary>
        </member>
        <member name="M:MCS.Library.Core.DataTypeConverterBase.Convert(System.Object,System.Object)">
            <summary>
            转换
            </summary>
            <param name="srcObject">源数据</param>
            <param name="targetObject">目标数据</param>
        </member>
        <member name="M:MCS.Library.Core.DataTypeConverterBase.CheckType(System.Object,System.Type,System.String)">
            <summary>
            检查类型
            </summary>
            <param name="data"></param>
            <param name="type"></param>
            <param name="paramName"></param>
        </member>
        <member name="T:MCS.Library.Core.DataTypeConverterGenericBase`2">
            <summary>
            泛型的类型转换器
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TTarget"></typeparam>
        </member>
        <member name="M:MCS.Library.Core.DataTypeConverterGenericBase`2.Convert(System.Object,System.Object)">
            <summary>
            转换
            </summary>
            <param name="srcObject"></param>
            <param name="targetObject"></param>
        </member>
        <member name="M:MCS.Library.Core.DataTypeConverterGenericBase`2.GenericConvert(`0,`1)">
            <summary>
            基于泛型的转换方法
            </summary>
            <param name="srcObject"></param>
            <param name="targetObject"></param>
        </member>
        <member name="T:MCS.Library.Core.DataTypeConverterHelper">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.DataTypeConverterHelper.RegisterConverter(System.Type,System.Type,MCS.Library.Core.DataTypeConverterBase)">
            <summary>
            注册数据类型转换器
            </summary>
            <param name="sourceType"></param>
            <param name="destType"></param>
            <param name="converter"></param>
        </member>
        <member name="M:MCS.Library.Core.DataTypeConverterHelper.GetConverter(System.Type,System.Type)">
            <summary>
            根据类型得到转换器
            </summary>
            <param name="sourceType"></param>
            <param name="destType"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.DictionaryHelper">
            <summary>
            字典访问的辅助类
            </summary>
        </member>
        <member name="M:MCS.Library.Core.DictionaryHelper.GetValue``3(System.Collections.Generic.IDictionary{``0,``1},``0,``2)">
            <summary>
            读取泛型字典中的某一项，如果不存在此项，返回缺省值
            </summary>
            <typeparam name="TKey">字典Key的类型</typeparam>
            <typeparam name="TValue">字典项的类型</typeparam>
            <typeparam name="TReturnValue">返回值的类型</typeparam>
            <param name="dict">泛型字典对象</param>
            <param name="key">需要访问的key值</param>
            <param name="defaultValue">如果不存在key时，返回的缺省值</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DictionaryHelper.GetValue``1(System.Collections.IDictionary,System.Object,``0)">
            <summary>
            读取字典中的某一项，如果不存在此项，返回缺省值
            </summary>
            <typeparam name="TReturnValue">字典的返回类型</typeparam>
            <param name="dict">字典对象</param>
            <param name="key">需要访问的key值</param>
            <param name="defaultValue">如果不存在key时，返回的缺省值</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DictionaryHelper.AddNonDefaultValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            当添加的字典项不是该类型的缺省值时，则添加此项
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dict"></param>
            <param name="key"></param>
            <param name="data"></param>
            <returns>是否添加了该项</returns>
        </member>
        <member name="M:MCS.Library.Core.DictionaryHelper.AddNonDefaultValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1,``1)">
            <summary>
            当添加的字典项不是指定的缺省值时，则添加此项
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dict"></param>
            <param name="key"></param>
            <param name="data"></param>
            <param name="defaultValue"></param>
            <returns>是否添加了该项</returns>
        </member>
        <member name="T:MCS.Library.Core.IEnumerableExtension">
            <summary>
            IEnumerable的接口扩展
            </summary>
        </member>
        <member name="M:MCS.Library.Core.IEnumerableExtension.AllAndNotEmpty``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            判断集合中每个元素是否都满足某条件，且集合不为空
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.IEnumerableExtension.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            枚举处理IEnumerable的内容
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.IEnumerableExtension.ForEach``1(System.Collections.IEnumerable,System.Action{``0})">
            <summary>
            枚举处理IEnumerable的内容
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.IEnumerableExtension.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            枚举每一项存在的值，判断是否存在满足条件的项
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.IEnumerableExtension.NotExists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            枚举每一项存在的值，判断是否都不存在满足条件的项
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.IEnumerableExtension.Exists``1(System.Collections.IEnumerable,System.Predicate{``0})">
            <summary>
            枚举每一项存在的值，判断是否存在满足条件的项
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.IEnumerableExtension.NotExists``1(System.Collections.IEnumerable,System.Predicate{``0})">
            <summary>
            枚举每一项存在的值，判断是否都不存在满足条件的项
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.IEnumerableExtension.FirstOrDefault``1(System.Collections.IEnumerable,System.Predicate{``0})">
            <summary>
            得到符合条件的第一项，如果没有找到，则返回默认值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.IEnumerableExtension.Distinct``1(System.Collections.Generic.IEnumerable{``0},MCS.Library.Core.EqualityComparerHandler{``0})">
            <summary>
            去除集合类中重复项
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.IListExtension">
            <summary>
            List的扩展方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.IListExtension.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Comparison{``0})">
            <summary>
            在一个有序的List中进行二分查找
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="target">查找目标</param>
            <param name="comparison"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.IListExtension.BinaryNearestSearch``1(System.Collections.Generic.IList{``0},``0,System.Comparison{``0})">
            <summary>
            查找最接近的项，返回最接近的项（小于等于）的下标。如果比第一项小，则返回0，如果比最后一项大，则返回集合的下标+1。
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="target"></param>
            <param name="comparison"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.IListExtension.QuickSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            快速排序，使用对象默认的比较规则
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:MCS.Library.Core.IListExtension.QuickSort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            按照一定的规则进行快速排序
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparison"></param>
        </member>
        <member name="M:MCS.Library.Core.IListExtension.QuickSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            按照一定的规则进行快速排序
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MCS.Library.Core.IListExtension.QuickSortList``1(System.Collections.IList)">
            <summary>
            快速排序，使用对象默认的比较规则
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
        </member>
        <member name="M:MCS.Library.Core.IListExtension.QuickSortList``1(System.Collections.IList,System.Comparison{``0})">
            <summary>
            按照一定的规则进行快速排序
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparison"></param>
        </member>
        <member name="M:MCS.Library.Core.IListExtension.QuickSortList``1(System.Collections.IList,System.Collections.Generic.IComparer{``0})">
            <summary>
            按照一定的规则进行快速排序
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="comparer"></param>
        </member>
        <member name="T:MCS.Library.Core.IXElementSerializable">
            <summary>
            对象可以通过实现此接口来完成Xml序列化和反序列化
            </summary>
        </member>
        <member name="M:MCS.Library.Core.IXElementSerializable.Serialize(System.Xml.Linq.XElement,MCS.Library.Core.XmlSerializeContext)">
            <summary>
            序列化
            </summary>
            <param name="node"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Core.IXElementSerializable.Deserialize(System.Xml.Linq.XElement,MCS.Library.Core.XmlDeserializeContext)">
            <summary>
            反序列化
            </summary>
            <param name="node"></param>
            <param name="context"></param>
        </member>
        <member name="T:MCS.Library.Core.IXmlSerilizableList">
            <summary>
            Xml序列化所需要实现的特殊List
            </summary>
        </member>
        <member name="M:MCS.Library.Core.IXmlSerilizableList.Add(System.Object)">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:MCS.Library.Core.IXmlSerilizableList.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Core.LogOnIdentity">
            <summary>
            封装用户登录信息的类  
            </summary>
            <remarks>封装用户登录信息的类，包括登录名（可包含域名），登录名（不含域名），域名和口令。</remarks>
        </member>
        <member name="M:MCS.Library.Core.LogOnIdentity.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Core.LogOnIdentity.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="logonName">登录名，可以含域名</param>
            <remarks>构造函数
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LogOnIdentityTest.cs" region="LogOnIdentityParserTest" lang="cs" title="创建一个LogOnIdentity实例" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LogOnIdentity.#ctor(System.String,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="logonUserName">登录名，可以含域名</param>
            <param name="pwd">口令</param>
            <remarks>
            构造函数
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LogOnIdentityTest.cs" region="LogOnIdentityParserTest" lang="cs" title="创建一个LogOnIdentity实例" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LogOnIdentity.#ctor(System.String,System.String,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="logonUserName">登录名，可以含域名</param>
            <param name="pwd">口令</param>
            <param name="logonDomain">域名</param>
            <remarks>
            构造函数
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LogOnIdentityTest.cs" region="LogOnIdentityParserTest" lang="cs" title="创建一个LogOnIdentity实例" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LogOnIdentity.ToNetworkCredentials">
            <summary>
            转换成NetworkCredential
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Core.LogOnIdentity.LogOnName">
            <summary>
            登录名，可以含域名
            </summary>
            <remarks>该属性是可读可写的</remarks>
        </member>
        <member name="P:MCS.Library.Core.LogOnIdentity.LogOnNameWithoutDomain">
            <summary>
            不含域名的登录名
            </summary>
            <remarks>该属性是只读的</remarks>
        </member>
        <member name="P:MCS.Library.Core.LogOnIdentity.LogOnNameWithDomain">
            <summary>
            包含域名的登录名
            </summary>
        </member>
        <member name="P:MCS.Library.Core.LogOnIdentity.Domain">
            <summary>
            域名
            </summary>
            <remarks>该属性是只读的</remarks>
        </member>
        <member name="P:MCS.Library.Core.LogOnIdentity.Password">
            <summary>
            口令
            </summary>
            <remarks>该属性是可读可写的</remarks>
        </member>
        <member name="P:MCS.Library.Core.LogOnIdentity.Context">
            <summary>
            上下文信息
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.TypeConfigurationElement">
            <summary>
            类型信息的配置项
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.TypeConfigurationElement.CreateInstance(System.Object[])">
            <summary>
            建立对象的实例
            </summary>
            <param name="ctorParams">创建实例的初始化参数</param>
            <returns>运用晚绑定方式动态创建一个实例</returns>
        </member>
        <member name="M:MCS.Library.Configuration.TypeConfigurationElement.CreateInstance``1(System.Object[])">
            <summary>
             建立对象的实例同时进行类型检查
            </summary>
            <typeparam name="T"></typeparam>
            <param name="ctorParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.TypeConfigurationElement.GetTypeInfo">
            <summary>
            得到System.Type信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.TypeConfigurationElement.Type">
            <summary>
            类型描述信息
            </summary>
            <remarks>一般采用QualifiedName （QuanlifiedTypeName, AssemblyName）方式</remarks>
        </member>
        <member name="T:MCS.Library.Configuration.TypeConfigurationCollection">
            <summary>
            类型的配置元素集合
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.UriConfigurationElement">
            <summary>
            关于Uri的配置项
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.UriConfigurationElement.UriString">
            <summary>
            Uri的地址字符串
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.UriConfigurationElement.Uri">
            <summary>
            配置的Uri
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.UriConfigurationCollection">
            <summary>
            关于Uri的配置项集合
            </summary>
        </member>
        <member name="T:MCS.Library.Core.InstanceMode">
            <summary>
            Instance mode
            </summary>
        </member>
        <member name="F:MCS.Library.Core.InstanceMode.Windows">
            <summary>
            Windows应用
            </summary>
        </member>
        <member name="F:MCS.Library.Core.InstanceMode.Web">
            <summary>
            Asp.net应用，能够获得HttpContext
            </summary>
        </member>
        <member name="T:MCS.Library.Core.EnvironmentSystemType">
            <summary>
            操作系统或运行环境的类型
            </summary>
        </member>
        <member name="F:MCS.Library.Core.EnvironmentSystemType.Windows32">
            <summary>
            Win32系统
            </summary>
        </member>
        <member name="F:MCS.Library.Core.EnvironmentSystemType.Windows64">
            <summary>
            Win64系统
            </summary>
        </member>
        <member name="F:MCS.Library.Core.EnvironmentSystemType.Windows128">
            <summary>
            Win128系统
            </summary>
        </member>
        <member name="T:MCS.Library.Core.EnvironmentHelper">
            <summary>
            处理应用环境问题的类
            </summary>
            <remarks>处理应用环境问题的类
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnvironmentHelper.#cctor">
            <summary>
            EnvironmentHelper的构造函数
            </summary>
            <remarks>EnvironmentHelper的构造函数,该构造函数不带任何参数。
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnvironmentHelper.ReplaceEnvironmentVariablesInString(System.String)">
            <summary>
            替代字符串中的环境变量
            </summary>
            <param name="filePath"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.EnvironmentHelper.GetEnvironmentInfo">
            <summary>
            得到当前环境的描述信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.EnvironmentHelper.GetClientIP">
            <summary>
            获取HttpRequest的客户端的IP
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Core.EnvironmentHelper.ComputerNetBIOSName">
            <summary>
            获取当前电脑的NetBIOS名称
            </summary>
        </member>
        <member name="P:MCS.Library.Core.EnvironmentHelper.IsUsingWebConfig">
            <summary>
            是否使用web.config作为配置文件
            </summary>
        </member>
        <member name="P:MCS.Library.Core.EnvironmentHelper.SystemType">
            <summary>
            获取运行环境的系统类型（32,64...）
            </summary>
        </member>
        <member name="P:MCS.Library.Core.EnvironmentHelper.Mode">
            <summary>
            当前应用是否为web应用的属性 ( Windows / Web)
            </summary>
            <remarks>该属性是只读的。
            <seealso cref="T:MCS.Library.Configuration.ConfigurationBroker"/>
            <seealso cref="T:MCS.Library.Configuration.MetaConfigurationSourceInstanceElement"/>
            <seealso cref="T:MCS.Library.Configuration.MetaConfigurationSourceMappingElement"/>
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnvironmentHelper.ShortDomainName">
            <summary>
            如果机器在域上注册，返回短域名
            </summary>
            <remarks>改属性只读。如果机器在域上的短名称是oa\hb2004-db，那么ShortDomainName就是oa。如果没有加入域，则返回空串</remarks>
        </member>
        <member name="P:MCS.Library.Core.EnvironmentHelper.DomainDnsName">
            <summary>
            如果机器在域上注册，返回长域名
            </summary>
            <remarks>改属性只读。域的长名称如oa.hgzs.ain.cn。如果没有加入域，则返回空串</remarks>
        </member>
        <member name="T:MCS.Library.Core.Extensions">
            <summary>
            为一般集合类所做的扩展
            </summary>
        </member>
        <member name="M:MCS.Library.Core.Extensions.ToJavascriptDateNumber(System.DateTime)">
            <summary>
            转换成Javascript的日期对应的整数（从1970年1月1日开始的毫秒数）
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.JavascriptDateNumberToDateTime(System.Int64)">
            <summary>
            Javascript的日期对应的整数（从1970年1月1日开始的毫秒数）转换成DateTime
            </summary>
            <param name="jsMilliseconds"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.ToDictionary(System.DateTime)">
            <summary>
            将日期类型转换为一个Dictionary，里面包含Ticks和DateKind，主要是和Json序列化中的类型转换相关
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.ToDateTime(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            将一个Dictionary转换成DateTime，需要这个Dictionaty中有DateValue值(Ticks)和DateKind值(DateTimeKind)。
            如果没有，则返回DateTime.MinValue
            </summary>
            <param name="dictionary"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNotEmpty(System.String)">
            <summary>
            字符串不是Null且Empty
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNotEmpty(System.String,System.Action{System.String})">
            <summary>
            如果字符串不为空，则执行Action
            </summary>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNotEmpty``1(System.String,System.Func{System.String,``0})">
            <summary>
            如果字符串不为空，则执行Func
            </summary>
            <typeparam name="R"></typeparam>
            <param name="data"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNullOrEmpty(System.String)">
            <summary>
            字符串是否为Null或Empty
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNullOrEmpty(System.String,System.Action)">
            <summary>
            如果字符串为空，则执行Action
            </summary>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNullOrWhiteSpace(System.String)">
            <summary>
            字符串是否为Null、Empty和WhiteSpace
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNullOrWhiteSpace(System.String,System.Action)">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNotWhiteSpace(System.String)">
            <summary>
            字符串不是Null、Empty和WhiteSpace
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNotWhiteSpace(System.String,System.Action{System.String})">
            <summary>
            
            </summary>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IgnoreCaseCompare(System.String,System.String)">
            <summary>
            大小写无关的比较
            </summary>
            <param name="strA"></param>
            <param name="strB"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNull(System.Object,System.Action)">
            <summary>
            如果对象为空，则执行Action
            </summary>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNotNull``1(``0,System.Action{``0})">
            <summary>
            如果对象不为空，则执行Action
            </summary>
            <typeparam name="T">对象的类型泛型</typeparam>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNotNull``2(``0,System.Func{``0,``1})">
            <summary>
            如果对象不为空，则执行Func，返回某个值
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="R"></typeparam>
            <param name="data"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsMinValue(System.DateTime,System.Action)">
            <summary>
            如果时间是MinValue，则执行Action
            </summary>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.Extensions.TrueFunc(System.Boolean,System.Func{System.Boolean})">
            <summary>
            当bool参数为true时，调用后续的比较函数。用于连续的条件比较。只要有一个为false，则返回false
            </summary>
            <param name="flag"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsNotMinValue(System.DateTime,System.Action{System.DateTime})">
            <summary>
            如果时间不是MinValue，则执行Action
            </summary>
            <param name="data"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.Extensions.ReferenceEqualWithNull(System.Object,System.Object,System.Boolean@)">
            <summary>
            比较两个对象的引用，如果都是null，返回true，如果有一个null，hasNull返回true
            </summary>
            <param name="objA"></param>
            <param name="objB"></param>
            <param name="hasNull"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.IsEnumerableObject(System.Object)">
            <summary>
            对象类型是否是枚举类型，且TypeCode为Object
            </summary>
            <param name="objectValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.Extensions.ToDescription(System.Enum)">
            <summary>
            得到某个枚举项的描述
            </summary>
            <param name="enumItem"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.MonitorData">
            <summary>
            需要监控和记录日志的性能对象。主要用于计量执行时间
            </summary>
        </member>
        <member name="M:MCS.Library.Core.MonitorData.WriteExecutionDuration(System.String,System.Action)">
            <summary>
            向Log中输出执行的时间
            </summary>
            <param name="operationName"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.MonitorData.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.MonitorData.InstanceName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.MonitorData.HasErrors">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.MonitorData.MonitorName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.MonitorData.EnablePFCounter">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.MonitorData.EnableLogging">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.MonitorData.LogWriter">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.MonitorData.Stopwatch">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Core.NonXElementSerializedFieldsAttribute">
            <summary>
            XElement序列化中，不需要序列化的字段定义属性
            </summary>
        </member>
        <member name="M:MCS.Library.Core.NonXElementSerializedFieldsAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.NonXElementSerializedFieldsAttribute.#ctor(System.Type,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="ownerType"></param>
            <param name="fieldName"></param>
        </member>
        <member name="P:MCS.Library.Core.NonXElementSerializedFieldsAttribute.OwnerType">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.NonXElementSerializedFieldsAttribute.FieldName">
            <summary>
            不需要序列化的字段名称，逗号分隔，大小写敏感
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlSerializableHashtable">
            <summary>
            支持Xml序列化的哈希表
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Collections.IDictionary)">
            <summary>
            
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Collections.IEqualityComparer)">
            <summary>
            
            </summary>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Int32)">
            <summary>
            
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Collections.IDictionary,System.Single)">
            <summary>
            
            </summary>
            <param name="d"></param>
            <param name="loadFactor"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Collections.IDictionary,System.Collections.IEqualityComparer)">
            <summary>
            
            </summary>
            <param name="d"></param>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Int32,System.Single)">
            <summary>
            
            </summary>
            <param name="capacity"></param>
            <param name="loadFactor"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Int32,System.Collections.IEqualityComparer)">
            <summary>
            
            </summary>
            <param name="capacity"></param>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Collections.IDictionary,System.Single,System.Collections.IEqualityComparer)">
            <summary>
            
            </summary>
            <param name="d"></param>
            <param name="loadFactor"></param>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.#ctor(System.Int32,System.Single,System.Collections.IEqualityComparer)">
            <summary>
            
            </summary>
            <param name="capacity"></param>
            <param name="loadFactor"></param>
            <param name="equalityComparer"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.GetSchema">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.ReadXml(System.Xml.XmlReader)">
            <summary>
            
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlSerializableHashtable.WriteXml(System.Xml.XmlWriter)">
            <summary>
            
            </summary>
            <param name="writer"></param>
        </member>
        <member name="T:MCS.Library.Data.Configuration.ConnectionMappingElement">
            <summary>
            连接映射的配置节
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Configuration.ConnectionMappingElement.Destination">
            <summary>
            目标连接串
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Configuration.ConnectionMappingElementCollection">
            <summary>
            接串映射信息集合
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ColumnDataType">
            <summary>
            参照TypeCode枚举值
            </summary>
        </member>
        <member name="F:MCS.Library.Data.DataObjects.ColumnDataType.DataObject">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Data.DataObjects.ColumnDataType.Boolean">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Data.DataObjects.ColumnDataType.Integer">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Data.DataObjects.ColumnDataType.Decimal">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Data.DataObjects.ColumnDataType.DateTime">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Data.DataObjects.ColumnDataType.String">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Data.DataObjects.ColumnDataType.Enum">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ColumnDefinitionBase">
            <summary>
            Table定义中的列定义
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ColumnDefinitionBase.DefaultValue">
            <summary>
            默认值
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ColumnDefinitionBase.RealDataType">
            <summary>
            实际的数据类型
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ColumnDefinitionBase.DataType">
            <summary>
            默认的数据类型
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ColumnDefinitionBase.Name">
            <summary>
            列名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ColumnDefinitionBase.Caption">
            <summary>
            列标题
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ColumnDefinitionCollectionBase`1">
            <summary>
            Table中的列定义集合
            </summary>
            <typeparam name="TColumnDefinition"></typeparam>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.SerializableEditableKeyedDataObjectCollectionBase`2">
            <summary>
            带序列化的EditableKeyedDataObjectCollectionBase的虚基类
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2">
            <summary>
            带Key的集合类，可以按照Key和Index两种方式索引
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1">
            <summary>
            能够编辑的数据对象集合类的虚基类
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.DataObjectCollectionBase`1">
            <summary>
            数据对象集合类的虚基类
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1">
            <summary>
            只读数据对象集合类的虚基类
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.#ctor(System.Int32)">
            <summary>
            构造方法。集合增加时的分配冗余
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.ForEach(System.Action{`0})">
            <summary>
            迭代处理每一个元素
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.Exists(System.Predicate{`0})">
            <summary>
            判断集合中是否存在某元素
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.TrueForAll(System.Predicate{`0})">
            <summary>
            判断集合中每个元素是否都满足某条件。如果集合为空，也返回True
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.TrueForAllAndNotEmpty(System.Predicate{`0})">
            <summary>
            判断集合中每个元素是否都满足某条件，且集合不为空
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.Find(System.Predicate{`0})">
            <summary>
            在集合中查找满足匹配条件的第一个元素
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.FindLast(System.Predicate{`0})">
            <summary>
            从后向前查找，找到第一个匹配的元素
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.FindAll(System.Predicate{`0})">
            <summary>
            找到满足匹配条件的所有元素
            </summary>
            <param name="match"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.Contains(`0)">
            <summary>
            是否包含某个元素
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.IndexOf(`0)">
            <summary>
            得到某个元素的位置
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.CopyTo(System.Collections.Generic.ICollection{`0})">
            <summary>
            复制到别的集合中
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.ToArray">
            <summary>
            转换到数组
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.ToString">
            <summary>
            重载ToString，将Count输出
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.InnerAdd(`0)">
            <summary>
            
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.Add(System.Object)">
            <summary>
            
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.OnInsertComplete(System.Int32,System.Object)">
            <summary>
            当数据添加后
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="E:MCS.Library.Data.DataObjects.ReadOnlyDataObjectCollectionBase`1.DataInserted">
            <summary>
            集合中数据添加后的事件
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.DataObjectCollectionBase`1.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.DataObjectCollectionBase`1.#ctor(System.Int32)">
            <summary>
            构造方法。集合增加时的分配冗余
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.DataObjectCollectionBase`1.CopyFrom(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            从别的集合中复制(添加到现有的集合中)
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.DataObjectCollectionBase`1.CopyFrom(System.Collections.Generic.IEnumerable{`0},System.Converter{`0,`0})">
            <summary>
            从别的集合中复制(添加到现有的集合中)，复制过程可以转换数据
            </summary>
            <param name="data"></param>
            <param name="converter">数据转换器</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.DataObjectCollectionBase`1.Remove(System.Predicate{`0})">
            <summary>
            删除满足条件的记录
            </summary>
            <param name="match"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.#ctor(System.Boolean)">
            <summary>
            构造方法
            </summary>
            <param name="isReadOnly">是否只读集合</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.#ctor(System.Int32)">
            <summary>
            构造方法。集合增加时的分配冗余
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.Add(`0)">
            <summary>
            添加一个对象
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.Sort">
            <summary>
            按照默认的规则进行排序(Comparer(T).Default)
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.Sort(System.Comparison{`0})">
            <summary>
            按照指定的规则进行排序
            </summary>
            <param name="comparison"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            按照指定的规则进行排序
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.Distinct(MCS.Library.Data.DataObjects.DistinctComparison{`0})">
            <summary>
            去除重复的元素
            </summary>
            <param name="comparison"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.OnInsert(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.OnSet(System.Int32,System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.OnRemove(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.OnClear">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="arrayIndex"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.Remove(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.IsReadOnly">
            <summary>
            是否只读集合
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.EditableDataObjectCollectionBase`1.Item(System.Int32)">
            <summary>
            读写对象
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="F:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2._Comparer">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.#ctor(System.Collections.IEqualityComparer)">
            <summary>
            构造方法
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.#ctor(System.Int32)">
            <summary>
            构造方法。集合增加时的分配冗余
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.#ctor(System.Int32,System.Collections.IEqualityComparer)">
            <summary>
            构造方法。集合增加时的分配冗余
            </summary>
            <param name="capacity"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.GetKeyForItem(`1)">
            <summary>
            确定Item的Key
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.AddNotExistsItem(`1)">
            <summary>
            增加不存在的数据（已经存在的将被忽略）
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.ContainsKey(`0)">
            <summary>
            指定的key是否存在
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.ContainsKey(`0,System.Action{`1})">
            <summary>
            如果key存在，则执行Action
            </summary>
            <param name="key"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.CopyTo(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            复制到字典中
            </summary>
            <param name="dict"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.CopyFrom(System.Collections.Generic.IDictionary{`0,`1})">
            <summary>
            从字段中复制
            </summary>
            <param name="dict"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.GetAllKeys">
            <summary>
            得到所有的Key
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.OnRemove(System.Int32,System.Object)">
            <summary>
            当删除时
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.OnClearComplete">
            <summary>
            当删除完成时
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.OnInsert(System.Int32,System.Object)">
            <summary>
            插入数据
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.OnDuplicateKey(`0,`1)">
            <summary>
            当试图插入重复Key时
            </summary>
            <param name="key"></param>
            <param name="data"></param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.EditableKeyedDataObjectCollectionBase`2.Item(`0)">
            <summary>
            按照Key的索引获取数据
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.SerializableEditableKeyedDataObjectCollectionBase`2.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.SerializableEditableKeyedDataObjectCollectionBase`2.#ctor(System.Int32)">
            <summary>
            构造方法。集合增加时的分配冗余
            </summary>
            <param name="capacity"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.SerializableEditableKeyedDataObjectCollectionBase`2.#ctor(System.Collections.IEqualityComparer)">
            <summary>
            构造方法，指定集合的Key比较器
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.SerializableEditableKeyedDataObjectCollectionBase`2.#ctor(System.Int32,System.Collections.IEqualityComparer)">
            <summary>
            构造方法。集合增加时的分配冗余
            </summary>
            <param name="capacity"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.SerializableEditableKeyedDataObjectCollectionBase`2.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.SerializableEditableKeyedDataObjectCollectionBase`2.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ColumnDefinitionCollectionBase`1.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ColumnDefinitionCollectionBase`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ColumnDefinitionCollectionBase`1.GetKeyForItem(`0)">
            <summary>
            从列定义中获取Key
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.DataObjectCollectionDataInsertedHandler`1">
            <summary>
            集合中的数据添加后
            </summary>
            <typeparam name="T"></typeparam>
            <param name="sender"></param>
            <param name="index"></param>
            <param name="data"></param>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.DistinctComparison`1">
            <summary>
            去除重复数据的比较器
            </summary>
            <typeparam name="T"></typeparam>
            <param name="srcData"></param>
            <param name="destData"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.GroupNode`2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TList"></typeparam>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.GroupNode`2.GroupKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.GroupNode`2.Data">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.GetGroupKeyForItemDelegate`2">
            <summary>
            
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TItem"></typeparam>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.GroupNodeCollection`3">
            <summary>
            
            </summary>
            <typeparam name="TGroupNode"></typeparam>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TList"></typeparam>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.GroupNodeCollection`3.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.GroupNodeCollection`3.GetKeyForItem(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.GroupNodeCollection`3.CreateGroupNode``1(`1,``0)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.GroupNodeCollection`3.TryGetValue(`1,`0@)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.GroupNodeCollection`3.FillData``1(System.Collections.IEnumerable,MCS.Library.Data.DataObjects.GetGroupKeyForItemDelegate{`1,``0})">
            <summary>
            
            </summary>
            <typeparam name="TItem"></typeparam>
            <param name="enumerator"></param>
            <param name="getKeyDelegate"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.GroupNodeCollection`3.SortGroups(System.Collections.Generic.IComparer{`0})">
            <summary>
            
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.GroupNodeCollection`3.Item(`1)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.IObjectCompareInfo">
            <summary>
            对象比较信息的接口
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.IObjectCompareInfo.KeyFields">
            <summary>
            需要比较的字段，可以还是多个字段，由逗号或分号分隔
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.IObjectCompareInfo.IsList">
            <summary>
            是否为List
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.IObjectCompareResult">
            <summary>
            对象比较的结果
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.IObjectCompareResult.ObjectTypeName">
            <summary>
            对象的类型名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.IObjectCompareResult.AreDifferent">
            <summary>
            对象的比较结果是否存在差异
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.IObjectCompareResult.AreEnumerable">
            <summary>
            参与比较的对象是否是可列举的（集合）
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.IPropertyCompareInfo">
            <summary>
            对象属性的比较信息
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.IPropertyCompareInfo.RequireCompare">
            <summary>
            是否需要进行比较
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.IPropertyCompareInfo.SortID">
            <summary>
            展示修改信息时的排序
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.IPropertyCompareInfo.Description">
            <summary>
            对该属性的文字描述
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.LruDataObjectCollectionBase`1">
            <summary>
            符合LRU算法的List，非线程安全
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.LruDataObjectCollectionBase`1.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.LruDataObjectCollectionBase`1.#ctor(System.Int32)">
            <summary>
            构造方法
            </summary>
            <param name="maxLength"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.LruDataObjectCollectionBase`1.Add(`0)">
            <summary>
            将对象添加到List中的第一项，如果集合超过了MaxLength，则删除最后一项
            </summary>
            <param name="obj"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.LruDataObjectCollectionBase`1.Advance(System.Int32)">
            <summary>
            将某个下标的对象提取到第一项
            </summary>
            <param name="index"></param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.LruDataObjectCollectionBase`1.MaxLength">
            <summary>
            队列的最大长度
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.LruDataObjectCollectionBase`1.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult">
            <summary>
            集合对象的比较结果
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult.#ctor(System.String)">
            <summary>
            对象的类型名称
            </summary>
            <param name="objectTypeName"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult.ToXElement(System.Xml.Linq.XElement,System.String)">
            <summary>
            将对象序列化到一个XElement元素上
            </summary>
            <param name="element"></param>
            <param name="refNodeName">可参照的节点名称，如果此参数不为空，则增加此名称的子节点</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult.FromXElement(System.Xml.Linq.XElement,System.String)">
            <summary>
            从XElement元素反序列化集合对象
            </summary>
            <param name="element"></param>
            <param name="refNodeName"></param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult.AreDifferent">
            <summary>
            对象的比较结果是否存在差异
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult.ObjectTypeName">
            <summary>
            对象的类型名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult.AreEnumerable">
            <summary>
            参与比较的对象是否是可列举的（集合）
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult.Added">
            <summary>
            新增的对象
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult.Updated">
            <summary>
            修改的对象
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCollectionCompareResult.Deleted">
            <summary>
            删除的对象
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ObjectCompareAttribute">
            <summary>
            定义了对象比较的相关信息
            </summary>
            <remarks>
            这些信息包括：keyField，是否为List。
            </remarks>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareAttribute.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="keyFieldsName"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareAttribute.#ctor(System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="list"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            构造函数
            </summary>
            <param name="keyFieldName"></param>
            <param name="list"></param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCompareAttribute.KeyFields">
            <summary>
            需要比较的字段，可以还是多个字段，由逗号或分号分隔
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCompareAttribute.IsList">
            <summary>
            是否为List
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ObjectCompareHelper">
            <summary>
            对象比较的集合类
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.CompareObject(System.Object,System.Object)">
            <summary>
                
            </summary>
            <param name="sourceObject"></param>
            <param name="compareObject"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.CompareObject(MCS.Library.Data.DataObjects.ObjectCompareInfo,System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="compareInfo"></param>
            <param name="sourceObject"></param>
            <param name="targetObject"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.CompareEnumerableObject(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
            比较两个集合对象
            </summary>
            <param name="sourceObject"></param>
            <param name="targetObject"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.GetCollectionByCompareValues(System.Object,System.Object,MCS.Library.Data.DataObjects.ObjectCompareResultCollection,MCS.Library.Data.DataObjects.ObjectCompareResultCollection)">
            <summary>
            根据比较前后的对象决定使用哪个集合
            </summary>
            <param name="sourceValue"></param>
            <param name="targetValue"></param>
            <param name="updated"></param>
            <param name="addOrDeleted"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.PropertyValueEquals(System.String,System.Object,System.Object)">
            <summary>
            两个对象的属性值是否相同
            </summary>
            <param name="propertyName"></param>
            <param name="sourceObject"></param>
            <param name="compareObject"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.GetCompareInfo``1">
            <summary>
            根据类信息得到对象的比较信息
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.GetCompareInfo(System.Object,System.Object)">
            <summary>
            根据两个对象的类型（不为空的）得到比较信息
            </summary>
            <param name="sourceObject"></param>
            <param name="targetObject"></param>
            <returns>哪一个对象不为null，则返回哪个对象的type对应的CompareInfo，如果都不为空，则返回sourceObject的。如果都是空，则返回null</returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.GetCompareInfo(System.Type)">
            <summary>
            根据类信息得到对象的比较信息
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.GetCompareKeyFields(MCS.Library.Data.DataObjects.IObjectCompareInfo)">
            <summary>
            得到关键字的属性集合
            </summary>
            <param name="compareInfo"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.CopyTo(MCS.Library.Data.DataObjects.IObjectCompareInfo,MCS.Library.Data.DataObjects.IObjectCompareInfo)">
            <summary>
            将某一个对象的比较信息复制给另一个对象
            </summary>
            <param name="source"></param>
            <param name="target"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.CopyTo(MCS.Library.Data.DataObjects.IPropertyCompareInfo,MCS.Library.Data.DataObjects.IPropertyCompareInfo)">
            <summary>
            将某一个对象的属性比较信息复制给另一个对象
            </summary>
            <param name="source"></param>
            <param name="target"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareHelper.FillPropertiesCompareInfo(System.Type,MCS.Library.Data.DataObjects.ObjectCompareInfo)">
            <summary>
            填充属性的比较信息
            </summary>
            <param name="type"></param>
            <param name="compareInfo"></param>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ObjectCompareInfo">
            <summary>
            对象的比较信息，包括每一个属性的比较信息
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCompareInfo.KeyFields">
            <summary>
            关键属性的名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCompareInfo.IsList">
            <summary>
            是否是列表对象
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCompareInfo.Properties">
            <summary>
            属性的比较信息
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCompareInfo.ObjectTypeName">
            <summary>
            对象的类型名称
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ObjectCompareInfoCache">
            <summary>
            对象比较信息的缓存
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ObjectCompareResult">
            <summary>
            对象的每个属性的比较结果
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="objectTypeName">对象的类型名称</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            序列化构造方法
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.GetKeyForItem(MCS.Library.Data.DataObjects.ObjectPropertyCompareResult)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.FindByOldPropertyValue(System.String,System.Object)">
            <summary>
            根据属性的原始值查找比较项
            </summary>
            <param name="propertyName"></param>
            <param name="propertyValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.FindByNewPropertyValue(System.String,System.Object)">
            <summary>
            根据的属性的新值查找比较项
            </summary>
            <param name="propertyName"></param>
            <param name="propertyValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.ToXElement">
            <summary>
            将整个对象序列化为一个XElement
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.ToXElement(System.Xml.Linq.XElement,System.String)">
            <summary>
            将对象序列化到一个XElement元素上
            </summary>
            <param name="element"></param>
            <param name="refNodeName">可参照的节点名称，如果此参数不为空，则增加此名称的子节点</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.FromXElement(System.Xml.Linq.XElement)">
            <summary>
            从XElement序列化为对象的内容
            </summary>
            <param name="root"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResult.FromXElement(System.Xml.Linq.XElement,System.String)">
            <summary>
            从一个XElement元素序列化对象
            </summary>
            <param name="element"></param>
            <param name="refNodeName">可参照的节点名称，如果此参数不为空，则从此名称的子节点序列化对象</param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCompareResult.AreDifferent">
            <summary>
            对象的比较结果是否存在差异
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCompareResult.ObjectTypeName">
            <summary>
            对象的类型名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectCompareResult.AreEnumerable">
            <summary>
            参与比较的对象是否是可列举的（集合）
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ObjectCompareResultCollection">
            <summary>
            对象比较结果的集合
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResultCollection.ToXElement(System.Xml.Linq.XElement,System.String)">
            <summary>
            将对象序列化到一个XElement元素上
            </summary>
            <param name="element"></param>
            <param name="refNodeName">可参照的节点名称，如果此参数不为空，则增加此名称的子节点</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectCompareResultCollection.FromXElement(System.Xml.Linq.XElement,System.String)">
            <summary>
            从XElement元素反序列化集合对象
            </summary>
            <param name="element"></param>
            <param name="refNodeName"></param>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult">
            <summary>
            两个对象的属性比较结果
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult.#ctor(MCS.Library.Data.DataObjects.PropertyCompareInfo,System.Object,System.Object)">
            <summary>
            构造方法
            </summary>
            <param name="pci"></param>
            <param name="sourceValue"></param>
            <param name="targetValue"></param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult.OldValue">
            <summary>
            保存修改前的值
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult.SortID">
            <summary>
            排序号
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult.NewValue">
            <summary>
            保存修改后的值
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult.PropertyName">
            <summary>
            属性名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult.PropertyTypeName">
            <summary>
            属性的类型名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult.Description">
            <summary>
            对该属性的文字描述
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.ObjectPropertyCompareResult.SubObjectCompareResult">
            <summary>
            子对象的比较结果
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.PropertyCompareAttribute">
            <summary>
            属性比较的相关信息
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.PropertyCompareAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.PropertyCompareAttribute.#ctor(System.Boolean)">
            <summary>
            构造方法
            </summary>
            <param name="requireCompare">是否需要进行比较</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.PropertyCompareAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="requireCompare">是否需要进行比较</param>
            <param name="description">文字描述</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.PropertyCompareAttribute.#ctor(System.Boolean,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="requireCompare">是否需要进行比较</param>
            <param name="sortID">排序</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.PropertyCompareAttribute.#ctor(System.Boolean,System.Int32,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="requireCompare">是否需要进行比较</param>
            <param name="sortID">排序</param>
            <param name="description">文字描述</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.PropertyCompareAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="description">文字描述</param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.PropertyCompareAttribute.RequireCompare">
            <summary>
            是否需要进行比较
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.PropertyCompareAttribute.SortID">
            <summary>
            展示修改信息时的排序
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.PropertyCompareAttribute.Description">
            <summary>
            对该属性的文字描述
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.PropertyCompareInfo">
            <summary>
            对象属性的比较信息
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.PropertyCompareInfo.RequireCompare">
            <summary>
            是否需要比较
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.PropertyCompareInfo.SortID">
            <summary>
            排序号
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.PropertyCompareInfo.Description">
            <summary>
            属性描述信息
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.PropertyCompareInfo.PropertyName">
            <summary>
            属性的名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.PropertyCompareInfo.PropertyTypeName">
            <summary>
            属性的类型名称
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.PropertyCompareInfoCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.PropertyCompareInfoCollection.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.PropertyCompareInfoCollection.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            序列化构造方法
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.PropertyCompareInfoCollection.GetKeyForItem(MCS.Library.Data.DataObjects.PropertyCompareInfo)">
            <summary>
            得到Key
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.QueryCondition">
            <summary>
            包装分页查询的查询参数
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.QueryCondition.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.QueryCondition.#ctor(System.Int32,System.Int32,System.String,System.String,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="rowIndex">从第几行开始</param>
            <param name="pageSize">每页的行数</param>
            <param name="select">sql语句返回的字段</param>
            <param name="from">sql语句的from部分</param>
            <param name="orderBy">sql语句的orderBy部分</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.QueryCondition.#ctor(System.Int32,System.Int32,System.String,System.String,System.String,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="rowIndex">从第几行开始</param>
            <param name="pageSize">每页的行数</param>
            <param name="select">sql语句返回的字段</param>
            <param name="from">sql语句的from部分</param>
            <param name="orderBy">sql语句的orderBy部分</param>
            <param name="where">sql语句的where部分</param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.QueryCondition.#ctor(System.Int32,System.Int32,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="rowIndex">从第几行开始</param>
            <param name="pageSize">每页的行数</param>
            <param name="select">sql语句返回的字段</param>
            <param name="from">sql语句的from部分</param>
            <param name="orderBy">sql语句的orderBy部分</param>
            <param name="where">sql语句的where部分</param>
            <param name="key">表的主键</param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.QueryCondition.PageSize">
            <summary>
            每页的行数
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.QueryCondition.RowIndex">
            <summary>
            从第几行开始
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.QueryCondition.OrderByClause">
            <summary>
            sql语句的orderBy部分
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.QueryCondition.WhereClause">
            <summary>
            sql语句的where部分
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.QueryCondition.FromClause">
            <summary>
            sql语句的from部分
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.QueryCondition.SelectFields">
            <summary>
            sql语句返回的字段
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.QueryCondition.PrimaryKey">
            <summary>
            表的主键
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.QueryCondition.GroupBy">
            <summary>
            GroupBy部分，包括Having部分
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.RowValueBase`2">
            <summary>
            Table中每一行中每一列的值
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.RowValueBase`2.Value">
            <summary>
            值
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.RowValueBase`2.Column">
            <summary>
            列信息
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.RowValueCollectionBase`3">
            <summary>
            Table中每一行中每一列的值的集合
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.RowValueCollectionBase`3.FindByColumnName(System.String)">
            <summary>
            根据列名找到行的值
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.RowValueCollectionBase`3.GetValue(System.String,`2)">
            <summary>
            根据列名得到值
            </summary>
            <param name="name"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.TableBase`7">
            <summary>
            基于Table的数据类型定义
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TableBase`7.ToDataView">
            <summary>
            转换到DataView类型
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TableBase`7.Rows">
            <summary>
            行信息
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TableBase`7.Columns">
            <summary>
            列定义
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.TableRowBase`4">
            <summary>
            Table中的行
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TableRowBase`4.Values">
            <summary>
            行中的值集合
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.TableRowCollectionBase`5">
            <summary>
            Table行
            </summary>
            <typeparam name="TTableRow"></typeparam>
            <typeparam name="TColumnDefinition"></typeparam>
            <typeparam name="TRowValueCollection"></typeparam>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TRowValue"></typeparam>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TableRowCollectionBase`5.ToDataView(MCS.Library.Data.DataObjects.ColumnDefinitionCollectionBase{`1})">
            <summary>
            转换为DataView
            </summary>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.TreeNodeBase`2">
            <summary>
            树节点的基类
            </summary>
            <typeparam name="TNode">树节点的类型</typeparam>
            <typeparam name="TCollection">树节点的集合类型</typeparam>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBase`2.TraverseChildren(MCS.Library.Data.DataObjects.TreeNodeBase{`0,`1}.TraverseNodeHandler)">
            <summary>
            按照深度优先遍历子节点
            </summary>
            <param name="handler"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBase`2.TraverseChildren(MCS.Library.Data.DataObjects.TreeNodeBase{`0,`1}.TraverseNodeHandler,System.Object)">
            <summary>
            按照深度优先遍历子节点
            </summary>
            <param name="handler"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBase`2.TraverseChildren(MCS.Library.Data.DataObjects.TreeNodeBase{`0,`1}.TraverseNodeHandler,MCS.Library.Data.DataObjects.TreeNodeBase{`0,`1}.BeforeTraverseNodeHandler,System.Object)">
            <summary>
            按照深度优先遍历子节点
            </summary>
            /// <param name="beforeHandler"></param>
            <param name="handler"></param>
            <param name="context"></param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TreeNodeBase`2.Parent">
            <summary>
            父节点
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TreeNodeBase`2.NextSibling">
            <summary>
            下一个兄弟节点
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TreeNodeBase`2.PreviousSibing">
            <summary>
            前一个兄弟节点
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TreeNodeBase`2.Children">
            <summary>
            子节点集合
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TreeNodeBase`2.FirstChild">
            <summary>
            第一个子节点
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TreeNodeBase`2.LastChild">
            <summary>
            最后一个子节点
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.TreeNodeBase`2.TraverseNodeHandler">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.TreeNodeBase`2.BeforeTraverseNodeHandler">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2">
            <summary>
            树节点的集合
            </summary>
            <typeparam name="TNode">集合中元素的类型</typeparam>
            <typeparam name="TCollection">集合的类型</typeparam>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2.Add(`0)">
            <summary>
            
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2.Remove(`0)">
            <summary>
            
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2.InnerAdd(`0)">
            <summary>
            
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2.OnInsert(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2.OnSet(System.Int32,System.Object,System.Object)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="oldValue"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2.OnRemove(System.Int32,System.Object)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
        </member>
        <member name="M:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2.OnValidate(System.Object)">
            <summary>
            
            </summary>
            <param name="value"></param>
        </member>
        <member name="P:MCS.Library.Data.DataObjects.TreeNodeBaseCollection`2.Item(System.Int32)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Data.DbConnectionMappingContext">
            <summary>
            数据库联接名称的映射。在上下文中维护一个连接名称的映射字典。
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DbConnectionMappingContext.CreateMapping(System.String,System.String)">
            <summary>
            创建连接名称的对应关系
            </summary>
            <param name="srcConnectionName"></param>
            <param name="destConnectionName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DbConnectionMappingContext.DoMappingAction(System.String,System.String,System.Action)">
            <summary>
            在连接串映射完成后，执行映射后的动作。执行完后，恢复原有的映射
            </summary>
            <param name="srcConnectionName"></param>
            <param name="destConnectionName"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Data.DbConnectionMappingContext.GetMappedConnectionName(System.String)">
            <summary>
            得到映射后的连接名称
            </summary>
            <param name="srcConnectionName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Data.DbConnectionMappingContext.ClearAllMappings">
            <summary>
            清除所有映射
            </summary>
        </member>
        <member name="M:MCS.Library.Data.DbConnectionMappingContext.Dispose">
            <summary>
            释放对应关系
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DbConnectionMappingContext.SourceConnectionName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DbConnectionMappingContext.DestinationConnectionName">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Data.DbConnectionMappingContextCache">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Data.DbConnectionMappingContextCache.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.ConditionMappingAttribute">
            <summary>
            条件对象的映射属性
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.ConditionMappingAttribute.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.ConditionMappingAttribute.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="fieldName"></param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.ConditionMappingAttribute.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="fieldName"></param>
            <param name="op"></param>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ConditionMappingAttribute.Operation">
            <summary>
            操作符，缺省为“=”
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ConditionMappingAttribute.IsExpression">
            <summary>
            是否是表达式
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ConditionMappingAttribute.DataFieldName">
            <summary>
            数据字段的类型
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ConditionMappingAttribute.EnumUsage">
            <summary>
            枚举类型的使用方法（值/还是描述）
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ConditionMappingAttribute.Prefix">
            <summary>
            生成Value时的前缀
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ConditionMappingAttribute.Postfix">
            <summary>
            生成Value时的后缀
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ConditionMappingAttribute.AdjustDays">
            <summary>
            如果是日期型，需要调整天数。
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ConditionMappingAttribute.Template">
            <summary>
            生成的SQL子句的表达式模板。默认是${DataField}$ ${Operation}$ ${Data}$
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ConditionMappingAttribute.EscapeLikeString">
            <summary>
            是否按照LIKE子句转义字符串中的LIKE保留字
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.SubConditionMappingAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubConditionMappingAttribute.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="subPropertyName"></param>
            <param name="fieldName"></param>
        </member>
        <member name="P:MCS.Library.Data.Mapping.SubConditionMappingAttribute.SubPropertyName">
            <summary>
            源对象的属性名称
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.ClauseBindingFlags">
            <summary>
            为操作绑定标记
            </summary>
        </member>
        <member name="F:MCS.Library.Data.Mapping.ClauseBindingFlags.None">
            <summary>
            任何情况下都不出现
            </summary>
        </member>
        <member name="F:MCS.Library.Data.Mapping.ClauseBindingFlags.Insert">
            <summary>
            表示属性会出现在Insert中
            </summary>
        </member>
        <member name="F:MCS.Library.Data.Mapping.ClauseBindingFlags.Update">
            <summary>
            表示属性会出现在Update中
            </summary>
        </member>
        <member name="F:MCS.Library.Data.Mapping.ClauseBindingFlags.Where">
            <summary>
            表示属性会出现在Where语句部分
            </summary>
        </member>
        <member name="F:MCS.Library.Data.Mapping.ClauseBindingFlags.Select">
            <summary>
            表示属性会出现在查询的返回字段中
            </summary>
        </member>
        <member name="F:MCS.Library.Data.Mapping.ClauseBindingFlags.All">
            <summary>
            在所有情况下都会出现
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.EnumUsageTypes">
            <summary>
            枚举类型的使用方法
            </summary>
        </member>
        <member name="F:MCS.Library.Data.Mapping.EnumUsageTypes.UseEnumValue">
            <summary>
            使用枚举类型的值(整型)
            </summary>
        </member>
        <member name="F:MCS.Library.Data.Mapping.EnumUsageTypes.UseEnumString">
            <summary>
            使用枚举类型的字符串
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.ORFieldMappingAttribute">
            <summary>
            ORM映射属性
            </summary>
            <remarks>
            ORM映射的属性类
            </remarks>
        </member>
        <member name="M:MCS.Library.Data.Mapping.ORFieldMappingAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.ORFieldMappingAttribute.#ctor(System.String)">
            <summary>
            取字段对应的值
            </summary>
            <param name="fieldName">字段</param>
            <remarks>
            
            </remarks>
        </member>
        <member name="M:MCS.Library.Data.Mapping.ORFieldMappingAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            取字段对应的值
            </summary>
            <param name="fieldName">字段</param>
            <param name="nullable">是否为空</param>
            <remarks>
            
            </remarks>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ORFieldMappingAttribute.IsNullable">
            <summary>
            字段是否可为空
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ORFieldMappingAttribute.Length">
            <summary>
            长度
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ORFieldMappingAttribute.DataFieldName">
            <summary>
            字段名
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ORFieldMappingAttribute.Format">
            <summary>
            生成SQL Value的格式化串{0:0000}
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ORFieldMappingAttribute.IsIdentity">
            <summary>
            是否标识列
            </summary>
            <remarks>
            是否标识列，是返回TRUE，否返回FALSE
            </remarks>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ORFieldMappingAttribute.PrimaryKey">
            <summary>
            是否主键
            </summary>
            <remarks>
            是否主键，是返回TRUE，否返回FALSE
            </remarks>
        </member>
        <member name="T:MCS.Library.Data.Mapping.NoMappingAttribute">
            <summary>
            进行Mapping时忽略的属性
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.ORTableMappingAttribute">
            <summary>
            加在类定义之前，用于表示表名的Attribute
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.ORTableMappingAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="tblName">表名</param>
        </member>
        <member name="P:MCS.Library.Data.Mapping.ORTableMappingAttribute.TableName">
            <summary>
            表名
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.PropertyEncryptionAttribute">
            <summary>
            需要加密的属性
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.PropertyEncryptionAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.PropertyEncryptionAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="encName"></param>
        </member>
        <member name="P:MCS.Library.Data.Mapping.PropertyEncryptionAttribute.EncryptorName">
            <summary>
            加密器的名称，如果没有则是用默认的
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.SqlBehaviorAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SqlBehaviorAttribute.#ctor">
            <summary>
            缺省构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SqlBehaviorAttribute.#ctor(MCS.Library.Data.Mapping.ClauseBindingFlags)">
            <summary>
            构造方法
            </summary>
            <param name="flags">对应的属性值会出现在哪些Sql语句中</param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SqlBehaviorAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="defaultExpression">如果对应的属性值为空，使用的缺省值表达式</param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SqlBehaviorAttribute.#ctor(MCS.Library.Data.Mapping.ClauseBindingFlags,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="flags">对应的属性值会出现在哪些Sql语句中</param>
            <param name="defaultExpression">如果对应的属性值为空，使用的缺省值表达式</param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SqlBehaviorAttribute.#ctor(MCS.Library.Data.Mapping.EnumUsageTypes)">
            <summary>
            构造方法
            </summary>
            <param name="usage">如果对应的属性是枚举类型，生成Sql时，是否使用枚举类型的值（整型），否则使用字符串</param>
        </member>
        <member name="P:MCS.Library.Data.Mapping.SqlBehaviorAttribute.EnumUsage">
            <summary>
            如果对应的属性是枚举类型，生成Sql时，是否使用枚举类型的值（整型），否则使用字符串
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.SqlBehaviorAttribute.DefaultExpression">
            <summary>
            对应的属性为空时，所提供的缺省值表达式
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.SqlBehaviorAttribute.BindingFlags">
            <summary>
            对应的属性值会出现在哪些Sql语句中
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.SubClassORFieldMappingAttribute">
            <summary>
            属性为子对象时的ORMaping关系
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassORFieldMappingAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassORFieldMappingAttribute.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="subPropertyName"></param>
            <param name="fieldName"></param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassORFieldMappingAttribute.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="subPropertyName"></param>
            <param name="fieldName"></param>
            <param name="nullable"></param>
        </member>
        <member name="P:MCS.Library.Data.Mapping.SubClassORFieldMappingAttribute.SubPropertyName">
            <summary>
            源对象的属性名称
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.SubClassPropertyEncryptionAttribute">
            <summary>
            属性为子对象时的加密属性定义
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassPropertyEncryptionAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassPropertyEncryptionAttribute.#ctor(System.String,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="subPropertyName">子对象的属性名称</param>
            <param name="encName">加密器的名称</param>
        </member>
        <member name="P:MCS.Library.Data.Mapping.SubClassPropertyEncryptionAttribute.SubPropertyName">
            <summary>
            源对象的属性名称
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.SubClassSqlBehaviorAttribute">
            <summary>
            属性为子对象时的Sql语句生成关系
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassSqlBehaviorAttribute.#ctor">
            <summary>
            缺省构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassSqlBehaviorAttribute.#ctor(System.String,MCS.Library.Data.Mapping.ClauseBindingFlags)">
            <summary>
            构造方法
            </summary>
            <param name="subPropertyName"></param>
            <param name="flags">对应的属性值会出现在哪些Sql语句中</param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassSqlBehaviorAttribute.#ctor(System.String,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="subPropertyName"></param>
            <param name="defaultExpression">如果对应的属性值为空，使用的缺省值表达式</param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassSqlBehaviorAttribute.#ctor(System.String,MCS.Library.Data.Mapping.ClauseBindingFlags,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="subPropertyName"></param>
            <param name="flags">对应的属性值会出现在哪些Sql语句中</param>
            <param name="defaultExpression">如果对应的属性值为空，使用的缺省值表达式</param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassSqlBehaviorAttribute.#ctor(System.String,MCS.Library.Data.Mapping.EnumUsageTypes)">
            <summary>
            构造方法
            </summary>
            <param name="subPropertyName"></param>
            <param name="usage">如果对应的属性是枚举类型，生成Sql时，是否使用枚举类型的值（整型），否则使用字符串</param>
        </member>
        <member name="P:MCS.Library.Data.Mapping.SubClassSqlBehaviorAttribute.SubPropertyName">
            <summary>
            源对象的属性名称
            </summary>
        </member>
        <member name="T:MCS.Library.Data.Mapping.SubClassTypeAttribute">
            <summary>
            描述子对象类型的属性
            </summary>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassTypeAttribute.#ctor(System.Type)">
            <summary>
            构造方法，通过类型信息构造
            </summary>
            <param name="type">类型信息</param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassTypeAttribute.#ctor(System.String)">
            <summary>
            构造方法，通过类型描述构造
            </summary>
            <param name="typeDesp">类型描述</param>
        </member>
        <member name="M:MCS.Library.Data.Mapping.SubClassTypeAttribute.ToString">
            <summary>
            输出类型描述
            </summary>
            <returns>类型描述</returns>
        </member>
        <member name="P:MCS.Library.Data.Mapping.SubClassTypeAttribute.Type">
            <summary>
            类型信息
            </summary>
        </member>
        <member name="P:MCS.Library.Data.Mapping.SubClassTypeAttribute.TypeDescription">
            <summary>
            类型描述
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.BuiltInFunctionAttribute">
            <summary>
            内置函数的属性说明
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionAttribute.#ctor(System.String,System.String)">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.BuiltInFunctionAttribute.FunctionName">
            <summary>
            函数名称
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.BuiltInFunctionAttribute.Description">
            <summary>
            函数说明
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.BuiltInFunctionHelper">
            <summary>
            得到内置函数信息类
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionHelper.ExecuteFunction(System.String,System.Object,MCS.Library.Expression.ParamObjectCollection,System.Object)">
            <summary>
            执行函数
            </summary>
            <param name="funcName"></param>
            <param name="target"></param>
            <param name="arrParams"></param>
            <param name="callerContext"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionHelper.ExecuteFunction(System.String,System.Type,MCS.Library.Expression.ParamObjectCollection,System.Object)">
            <summary>
            执行静态函数
            </summary>
            <param name="funcName"></param>
            <param name="type"></param>
            <param name="arrParams"></param>
            <param name="callerContext"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionHelper.GetBuiltInFunctionsInfo(System.Type)">
            <summary>
            从类型上获取内置表达式函数集合
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionHelper.BuildBuiltInFunctionsInfo(System.Type)">
            <summary>
            从类型上获取内置表达式函数集合
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Expression.BuiltInFunctionInfo">
            <summary>
            内置函数说明
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionInfo.#ctor(MCS.Library.Expression.BuiltInFunctionAttribute,System.Reflection.MethodInfo)">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionInfo.ExecuteFunction(System.Object,MCS.Library.Expression.ParamObjectCollection,System.Object)">
            <summary>
            执行方法
            </summary>
            <param name="target"></param>
            <param name="arrParams"></param>
            <param name="callerContext"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Expression.BuiltInFunctionInfo.FunctionName">
            <summary>
            函数名称
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.BuiltInFunctionInfo.Description">
            <summary>
            函数说明
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.BuiltInFunctionInfo.MethodInfo">
            <summary>
            方法的反射信息
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.BuiltInFunctionInfoCollection">
            <summary>
            内置的方法信息集合
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionInfoCollection.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.BuiltInFunctionInfoCollection.GetKeyForItem(MCS.Library.Expression.BuiltInFunctionInfo)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionaryCalculatorContext">
            <summary>
            字典项计算的上下文对象
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryCalculatorContext.#ctor(MCS.Library.Expression.ExpressionDictionary,System.Object)">
            <summary>
            构造方法
            </summary>
            <param name="dictionaryInfo"></param>
            <param name="callerContext"></param>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionaryCalculatorContext.DictionaryInfo">
            <summary>
            对应的配置元素
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionaryCalculatorContext.CallerContext">
            <summary>
            表达式计算的调用上下文
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionary">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionary.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionary.#ctor(MCS.Library.Expression.ExpressionDictionaryConfigurationElement)">
            <summary>
            
            </summary>
            <param name="element"></param>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionary.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionary.Calculator">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionary.Description">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionary.Items">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionaryCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryCollection.InitFromConfiguration(MCS.Library.Expression.ExpressionDictionarySettings)">
            <summary>
            
            </summary>
            <param name="settings"></param>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryCollection.GetKeyForItem(MCS.Library.Expression.ExpressionDictionary)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionaryItem">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryItem.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryItem.#ctor(MCS.Library.Expression.ExpressionDictionaryItemConfigurationElement)">
            <summary>
            
            </summary>
            <param name="element"></param>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionaryItem.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionaryItem.Description">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionaryItem.DataType">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionaryItem.DefaultValue">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionaryItemCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryItemCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryItemCollection.InitFromConfiguration(MCS.Library.Expression.ExpressionDictionaryItemConfigurationElementCollection)">
            <summary>
            
            </summary>
            <param name="elements"></param>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryItemCollection.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionaryItemCollection.GetKeyForItem(MCS.Library.Expression.ExpressionDictionaryItem)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionarySettings">
            <summary>
            表达式中的预定义字典的配置信息
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionDictionarySettings.GetConfig">
            <summary>
            获得表达式预定义字典的配置信息
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionarySettings.Dictionaries">
            <summary>
            字典项的配置信息集合
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionaryConfigurationElement">
            <summary>
            表达式字典配置项
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionaryConfigurationElement.Items">
            <summary>
            字典描述项集合
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionaryConfigurationElementCollection">
            <summary>
            表达式字典配置项集合
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionaryItemConfigurationElement">
            <summary>
            表达式字典项说明的配置项
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionaryItemConfigurationElement.DataType">
            <summary>
            数据类型
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpressionDictionaryItemConfigurationElement.DefaultValue">
            <summary>
            默认值
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDictionaryItemConfigurationElementCollection">
            <summary>
            表达式字典项说明的配置项集合
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionExtensions.ToRealType(MCS.Library.Expression.ExpressionDataType)">
            <summary>
            将ExpressionDataType转换成.Net的数据类型
            </summary>
            <param name="pdt"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionExtensions.TryToRealType(MCS.Library.Expression.ExpressionDataType,System.Type@)">
            <summary>
            试图转换成真实的类型
            </summary>
            <param name="pdt"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionParser">
            <summary>
            表达式识别类
            </summary>
            <remarks>
            对表达式进行解析的类
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.Parse(System.String)">
            <summary>
            分析表达式，
            </summary>
            <param name="expression">表达式</param>
            <returns>分析结果</returns>
            <remarks>
            对传入的表达式进行分析
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="parse" lang="cs" title="调用分析表达式的函数" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.Calculate(System.String)">
            <summary>
            计算表达式，直接获得结果
            </summary>
            <param name="expression">表达式</param>
            <returns>运算结果</returns>
            <remarks>
            直接计算出表达式的结果
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="Calculate" lang="cs" title="计算表达式" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.Calculate(System.String,MCS.Library.Expression.CalculateUserFunction,System.Object)">
            <summary>
            计算表达式，直接获得结果
            </summary>
            <param name="expression">表达式</param>
            <param name="calculateUserFunction">自定义函数</param>
            <param name="callerContext">自定义函数上下文</param>
            <returns>运算值</returns>
            <remarks>
            对包含自定义函数的表达式进行运算
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="Calculate" lang="cs" title="计算表达式" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.Calculate(System.String,System.Object,System.Object)">
            <summary>
            计算表达式，直接获得结果
            </summary>
            <param name="expression">表达式</param>
            <param name="builtInFunctionsWrapper">包含内置函数的实现类</param>
            <param name="callerContext">自定义函数上下文</param>
            <returns>运算值</returns>
            <remarks>
            对包含自定义函数和自定义上下文的表达式进行运算
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="Calculate" lang="cs" title="计算表达式" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.Calculate(System.String,MCS.Library.Expression.CalculateUserFunction,System.Object,System.Boolean)">
            <summary>
            计算表达式，直接获得结果
            </summary>
            <param name="expression">表达式</param>
            <param name="calculateUserFunction">自定义函数</param>
            <param name="callerContext">自定义函数上下文</param>
            <param name="optimize">是否进行bool运算优化，缺省为true</param>
            <returns>运算值</returns>
            <remarks>
            对包含自定义函数和自定义上下文的表达式进行运算
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="Calculate" lang="cs" title="计算表达式" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.Calculate(System.String,System.Object,System.Object,System.Boolean)">
            <summary>
            计算表达式，直接获得结果
            </summary>
            <param name="expression">表达式</param>
            <param name="builtInFunctionsWrapper">包含内置函数的实现类</param>
            <param name="callerContext">自定义函数上下文</param>
            <param name="optimize">是否进行bool运算优化，缺省为true</param>
            <returns>运算值</returns>
            <remarks>
            对包含自定义函数和自定义上下文的表达式进行运算
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="Calculate" lang="cs" title="计算表达式" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.GetTreeValue(MCS.Library.Expression.ExpTreeNode)">
            <summary>
            根据语法解析完的Tree，计算出结果
            </summary>
            <param name="tree">语法解析树</param>
            <returns>结果返回值</returns>
            <remarks>
            计算解析出的二叉树，得到运算结果
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="getreevalue" lang="cs" title="对解析生成的二叉树进行计算" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.GetTreeValue(MCS.Library.Expression.ExpTreeNode,MCS.Library.Expression.CalculateUserFunction,System.Object)">
            <summary>
            根据语法解析完的Tree，计算出结果
            </summary>
            <param name="tree">解析生成的二叉树</param>
            <param name="calculateUserFunction">用户自定义函数的实现</param>
            <param name="callerContext">自定义函数上下文</param>
            <returns>运算结果</returns>
            <remarks>
             对含自定义函数的表达式进行解析后生成的二叉树，调用该函数进行运算得出结果值
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="parse" lang="cs" title="对解析生成的二叉树进行计算" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.GetTreeValue(MCS.Library.Expression.ExpTreeNode,System.Object,System.Object)">
            <summary>
            根据语法解析完的Tree，计算出结果
            </summary>
            <param name="tree"></param>
            <param name="builtInFunctionsWrapper">包含内置函数的实现类</param>
            <param name="callerContext">调用者上下文</param>
            <returns>树结点值</returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.GetTreeValue(MCS.Library.Expression.ExpTreeNode,MCS.Library.Expression.CalculateUserFunction,System.Object,System.Boolean)">
            <summary>
            根据语法解析完的Tree，计算出结果
            </summary>
            <param name="tree"></param>
            <param name="calculateUserFunction">用户自定义函数的实现</param>
            <param name="callerContext"></param>
            <param name="optimize">是否进行bool运算优化，缺省为true</param>
            <returns></returns>
            <remarks>
            对含自定义函数的表达式进行解析后生成的二叉树，调用该函数进行运算得出结果值
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="parse" lang="cs" title="对解析生成的二叉树进行计算" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.GetTreeValue(MCS.Library.Expression.ExpTreeNode,System.Object,System.Object,System.Boolean)">
            <summary>
            根据语法解析完的Tree，计算出结果
            </summary>
            <param name="tree"></param>
            <param name="builtInFunctionsWrapper">包含内置函数的实现类</param>
            <param name="callerContext">调用者上下文</param>
            <param name="optimize">最优化选项</param>
            <returns>树结点值</returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.DoExpression(MCS.Library.Expression.ExpressionParser.ParsingContext)">
            <summary>
            开始分析一段表达式
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.DoLogicalAND(MCS.Library.Expression.ExpressionParser.ParsingContext)">
            <summary>
            逻辑与
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.DoLogicalOP(MCS.Library.Expression.ExpressionParser.ParsingContext)">
            <summary>
            逻辑比较运算
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.DoAddSub(MCS.Library.Expression.ExpressionParser.ParsingContext)">
            <summary>
            处理加减运算
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.DoMulDiv(MCS.Library.Expression.ExpressionParser.ParsingContext)">
            <summary>
            处理乘除运算
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.DoSgOP(MCS.Library.Expression.ExpressionParser.ParsingContext)">
            <summary>
            处理逻辑非"!"运算符
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.DoFactor(MCS.Library.Expression.ExpressionParser.ParsingContext)">
            <summary>
            处理各种系数、负数、括号等
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.DoIdentifier(MCS.Library.Expression.ExpressionParser.ParsingContext)">
            <summary>
            处理各种数字、标识符、自定义函数、字符串等
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.NewTreeNode(MCS.Library.Expression.ExpressionParser.ParsingContext)">
            <summary>
            生成一个新的二叉树节点
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpressionParser.NewTreeNode(MCS.Library.Expression.ExpressionParser.ParsingContext,MCS.Library.Expression.ExpTreeNode,MCS.Library.Expression.ExpTreeNode,MCS.Library.Expression.Operation_IDs)">
            <summary>
            生成一个新的二叉树节点
            </summary>
            <param name="context">运行上下文</param>
            <param name="left">左子树</param>
            <param name="right">右子树</param>
            <param name="oID">操作类型</param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Expression.IExpressionDictionaryCalculator">
            <summary>
            表达式字典需要计算需要实现的接口
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.IExpressionDictionaryCalculator.Calculate(System.String,System.String,MCS.Library.Expression.ExpressionDictionaryCalculatorContext)">
            <summary>
            计算并返回字典项的值
            </summary>
            <param name="dictionaryName">字典的名称</param>
            <param name="key">字典的Key</param>
            <param name="context">计算上下文</param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Globalization.SessionCookieUserCultureInfoAccessor">
            <summary>
            基于Cookie的用户信息存储
            </summary>
        </member>
        <member name="T:MCS.Library.Globalization.IUserCultureInfoAccessor">
            <summary>
            用户全球化的参数设置
            </summary>
        </member>
        <member name="M:MCS.Library.Globalization.IUserCultureInfoAccessor.GetCurrentUserLanguageID(System.String,System.String)">
            <summary>
            得到当前用户的语言ID（zh-CN，或者en-US）
            </summary>
            <param name="userID"></param>
            <param name="defaultLanguageID">默认的语言ID</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Globalization.IUserCultureInfoAccessor.SaveUserLanguageID(System.String,System.String)">
            <summary>
            保存当前用户的语言ID（zh-CN，或者en-US）
            </summary>
            <param name="userID"></param>
            <param name="languageID"></param>
        </member>
        <member name="M:MCS.Library.Globalization.SessionCookieUserCultureInfoAccessor.GetCurrentUserLanguageID(System.String,System.String)">
            <summary>
            从Cookie中读取用户的文种信息
            </summary>
            <param name="userID"></param>
            <param name="defaultLanguageID"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Globalization.SessionCookieUserCultureInfoAccessor.SaveUserLanguageID(System.String,System.String)">
            <summary>
            保存用户文种信息到Cookie中
            </summary>
            <param name="userID"></param>
            <param name="languageID"></param>
        </member>
        <member name="T:MCS.Web.Library.DictionaryCache">
            <summary>
            基于字典的Cache
            </summary>
        </member>
        <member name="F:MCS.Web.Library.DictionaryCache.Instance">
            <summary>
            Instance
            </summary>
        </member>
        <member name="T:MCS.Web.Library.DictionaryItemKey">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Web.Library.DictionaryItemKey.SourceText">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Web.Library.DictionaryItemKey.SourceCultureName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Web.Library.DictionaryItemKey.TargetCultureName">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Web.Library.GlobalizationWebHelper">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Web.Library.GlobalizationWebHelper.LanguageParameterName">
            <summary>
            url中，表示语言的参数名
            </summary>
        </member>
        <member name="M:MCS.Web.Library.GlobalizationWebHelper.TryGetLanguageFromQueryString(System.String@)">
            <summary>
            从Url的参数中获取文种信息
            </summary>
            <param name="language">默认和返回的文种</param>
            <returns>url中是否包含了文种参数</returns>
        </member>
        <member name="M:MCS.Web.Library.GlobalizationWebHelper.GetCurrentHandlerLanguageID">
            <summary>
            如果当前的Handler是页面，则从页面中获取language信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Web.Library.GlobalizationWebHelper.GetUserDefaultLanguage">
            <summary>
            得到用户缺省的语言
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Web.Library.GlobalizationWebHelper.SaveUserDefaultLanguage(System.String)">
            <summary>
            在Cookie中保存用户选择语言
            </summary>
            <param name="language"></param>
        </member>
        <member name="M:MCS.Web.Library.GlobalizationWebHelper.GetMatchedCulture(System.String[])">
            <summary>
            得到匹配的Culture
            </summary>
            <param name="userLanguages"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Web.Library.GlobalizationWebHelper.GetSystemCultures">
            <summary>
            从Cache中得到系统所包含的Culture
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Web.Library.DeluxeNameTableContextCache">
            <summary>
            客户端的名字表
            </summary>
        </member>
        <member name="M:MCS.Web.Library.DeluxeNameTableContextCache.Add(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="category"></param>
            <param name="sourceText"></param>
        </member>
        <member name="M:MCS.Web.Library.DeluxeNameTableContextCache.Add(System.String,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="category"></param>
            <param name="sourceText"></param>
            <param name="targetText"></param>
        </member>
        <member name="M:MCS.Web.Library.DeluxeNameTableContextCache.RegisterNameTable(System.Web.UI.Page)">
            <summary>
            注册客户端脚本名称表
            </summary>
            <param name="page"></param>
        </member>
        <member name="M:MCS.Web.Library.DeluxeNameTableContextCache.GetNameTableScript">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Web.Library.DeluxeNameTableContextCache.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="T:MCS.Web.Library.DeluxeNameTableCacheKey">
            <summary>
            客户端名字表的Key
            </summary>
        </member>
        <member name="P:MCS.Web.Library.DeluxeNameTableCacheKey.SourceText">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Web.Library.DeluxeNameTableCacheKey.Category">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Globalization.UserCultureInfoSettings">
            <summary>
            获取用户CultureInfo的配置节
            </summary>
        </member>
        <member name="M:MCS.Library.Globalization.UserCultureInfoSettings.GetConfig">
            <summary>
            得到配置节
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Globalization.UserCultureInfoSettings.UserCultureInfoAccessor">
            <summary>
            用户的Culture信息的获取器
            </summary>
        </member>
        <member name="T:MCS.Web.Library.WebTranslator">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Globalization.ITranslator">
            <summary>
            默认的翻译器
            </summary>
        </member>
        <member name="M:MCS.Library.Globalization.ITranslator.Translate(System.String,System.Globalization.CultureInfo,System.String,System.Globalization.CultureInfo,System.Object[])">
            <summary>
            翻译字符串
            </summary>
            <param name="category"></param>
            <param name="sourceCulture"></param>
            <param name="sourceText"></param>
            <param name="targetCulture"></param>
            <param name="objParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Web.Library.WebTranslator.Translate(System.String,System.Globalization.CultureInfo,System.String,System.Globalization.CultureInfo,System.Object[])">
            <summary>
            
            </summary>
            <param name="category"></param>
            <param name="sourceCulture"></param>
            <param name="sourceText"></param>
            <param name="targetCulture"></param>
            <param name="objParams"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Web.Library.WebTranslatorConfigSettings">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Web.Library.WebTranslatorConfigSettings.GetConfig">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Web.Library.WebTranslatorConfigSettings.CultureFileRoot">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Passport.ITicketIdentity">
            <summary>
            带票据的Identity
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ITicketIdentity.Ticket">
            <summary>
            Identity中包含的票据
            </summary>
        </member>
        <member name="T:MCS.Library.Passport.ISignInInfo">
            <summary>
            登录信息的接口
            </summary>
        </member>
        <member name="M:MCS.Library.Passport.ISignInInfo.SaveToCookie">
            <summary>
            将登录信息保存到Cookie中
            </summary>
        </member>
        <member name="M:MCS.Library.Passport.ISignInInfo.SaveToXml">
            <summary>
            将登录信息保存到Xml文档对象中
            </summary>
        </member>
        <member name="M:MCS.Library.Passport.ISignInInfo.IsValid">
            <summary>
            SignInInfo是否合法
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.UserID">
            <summary>
            登录用户的ID
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.OriginalUserID">
            <summary>
            扮演前的登录名
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.Domain">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.UserIDWithDomain">
            <summary>
            带域名的用户ID
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.WindowsIntegrated">
            <summary>
            是否集成认证
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.SignInSessionID">
            <summary>
            登录的SessionID
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.SignInTime">
            <summary>
            登录的时间
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.SignInTimeout">
            <summary>
            登录的过期时间
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.AuthenticateServer">
            <summary>
            认证服务器的域名(或者IP)
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.ExistsSignInTimeout">
            <summary>
            是否存在登录超时时间（不是日期的最大和最小值）
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInInfo.Properties">
            <summary>
            扩展属性集合（不入库）
            </summary>
        </member>
        <member name="T:MCS.Library.Passport.ITicket">
            <summary>
            应用登录以后生成的Ticket
            </summary>
        </member>
        <member name="M:MCS.Library.Passport.ITicket.SaveToCookie">
            <summary>
            将应用登录信息保存到Cookie中
            </summary>
        </member>
        <member name="M:MCS.Library.Passport.ITicket.SaveToXml">
            <summary>
            将应用登录信息保存到Xml文档对象中
            </summary>
        </member>
        <member name="M:MCS.Library.Passport.ITicket.IsValid">
            <summary>
            Ticket是否合法
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Passport.ITicket.ToEncryptString">
            <summary>
            生成加密的字符串
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Passport.ITicket.SignInInfo">
            <summary>
            登录的信息
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ITicket.AppSignInSessionID">
            <summary>
            应用登录以后的应用ID
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ITicket.AppID">
            <summary>
            应用的ID
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ITicket.AppSignInTime">
            <summary>
            应用登录的时间
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ITicket.AppSignInTimeout">
            <summary>
            应用登录的Session过期时间
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ITicket.AppSignInIP">
            <summary>
            应用登录时的IP地址
            </summary>
        </member>
        <member name="T:MCS.Library.Passport.ISignInUserInfo">
            <summary>
            登录用户的信息
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInUserInfo.UserID">
            <summary>
            登录用户的ID
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInUserInfo.Domain">
            <summary>
            用户的域名
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInUserInfo.OriginalUserID">
            <summary>
            原始的登录ID
            </summary>
        </member>
        <member name="P:MCS.Library.Passport.ISignInUserInfo.Properties">
            <summary>
            属性集合
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerConfigurationElement">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerConfigurationElement.Enabled">
            <summary>
            Logger是否可用的标志
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerConfigurationElement.Filters">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerConfigurationElement.Listeners">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerConfigurationElement.FiltersElements">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerConfigurationElement.ListenerElements">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerConfigurationElementCollection">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerFilterConfigurationElement">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerItemConfigurationElementBase">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.LoggerItemConfigurationElementBase.OnDeserializeUnrecognizedAttribute(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Logging.LoggerFilterConfigurationElement.MinPriority">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerFilterConfigurationElementCollection">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerFormatterConfigurationElement">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerFormatterConfigurationElement.Template">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerFormatterConfigurationElementCollection">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerListenerConfigurationElement">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerListenerConfigurationElement.LogFormatterName">
            <summary>
            LogFormatter的名称
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerListenerConfigurationElement.LogName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerListenerConfigurationElement.Source">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerListenerConfigurationElement.FileName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerListenerConfigurationElement.Header">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggerListenerConfigurationElement.Footer">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerListenerConfigurationElementCollection">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggingSection">
            <summary>
            日志部分的配置信息
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.LoggingSection.GetConfig">
            <summary>
            得到配置节
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Logging.LoggingSection.Loggers">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LoggingSection.Formatters">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LoggerDescriptionAttribute">
            <summary>
            Logger描述信息的属性
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.LoggerDescriptionAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.LoggerDescriptionAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:MCS.Library.Logging.LoggerDescriptionAttribute.Name">
            <summary>
            Logger的名称
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LogSourceAttribute">
            <summary>
            Log的源描述信息
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.LogSourceAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.LogSourceAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:MCS.Library.Logging.LogSourceAttribute.Name">
            <summary>
            Logger的名称
            </summary>
        </member>
        <member name="T:MCS.Library.Core.PerformanceCounterNameAttribute">
            <summary>
            描述性能监视指针名称的Attribute
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterNameAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterNameAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="counterName"></param>
        </member>
        <member name="P:MCS.Library.Core.PerformanceCounterNameAttribute.CounterName">
            <summary>
            Counter的名称
            </summary>
        </member>
        <member name="T:MCS.Library.Core.PerformanceCounterDescriptionAttribute">
            <summary>
            描述性能监视指针信息的属性，用于HitPerformanceCountersBase等类
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterDescriptionAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterDescriptionAttribute.#ctor(System.String,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="categoryName"></param>
            <param name="counterNames">使用逗号分隔的计数器名称</param>
        </member>
        <member name="P:MCS.Library.Core.PerformanceCounterDescriptionAttribute.CategoryName">
            <summary>
            类别的名称
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PerformanceCounterDescriptionAttribute.CounterNames">
            <summary>
            使用逗号分隔的计数器名称
            </summary>
        </member>
        <member name="T:MCS.Library.Core.PerformanceCounterInitData">
            <summary>
            初始化性能计数器时的参数
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterInitData.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterInitData.#ctor(System.String,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="categoryName">性能计数器的类别</param>
            <param name="counterName">性能计数器的名字</param>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterInitData.#ctor(System.String,System.String,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="perCategoryName">性能计数器的类别</param>
            <param name="perCounterName">性能计数器的名字</param>
            <param name="perInstanceName">实例名称</param>
        </member>
        <member name="P:MCS.Library.Core.PerformanceCounterInitData.CategoryName">
            <summary>
            性能计数器的类别
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PerformanceCounterInitData.CounterName">
            <summary>
            性能计数器的名称
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PerformanceCounterInitData.InstanceName">
            <summary>
            实例名称
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PerformanceCounterInitData.Readonly">
            <summary>
            是否是只读
            </summary>
        </member>
        <member name="P:MCS.Library.Core.PerformanceCounterInitData.MachineName">
            <summary>
            性能计数器所在的机器名
            </summary>
        </member>
        <member name="T:MCS.Library.Core.PerformanceCounterWrapper">
            <summary>
            性能计数器的包装类，如果初始化性能计数器失败，可以忽略掉所有操作
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterWrapper.#ctor(MCS.Library.Core.PerformanceCounterInitData)">
            <summary>
            构造方法
            </summary>
            <param name="data">性能计数器的初始化参数</param>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterWrapper.Increment">
            <summary>
            性能计数器加一
            </summary>
            <returns>加一之后的计数器值</returns>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterWrapper.IncrementBy(System.Int64)">
            <summary>
            性能计数器增加一个整数
            </summary>
            <param name="value">需要增加的整数</param>
            <returns>增加之后的计数器值</returns>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterWrapper.Decrement">
            <summary>
            性能计数器值减一
            </summary>
            <returns>减一之后的计数器值</returns>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterWrapper.NextValue">
            <summary>
            获取性能计数器下一个数值
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.PerformanceCounterWrapper.NextSample">
            <summary>
            获取性能计数器下一个采样
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Core.PerformanceCounterWrapper.RawValue">
            <summary>
            读取和设置性能计数器的原始值
            </summary>
        </member>
        <member name="T:MCS.Library.Core.PerformanceMonitorHelper">
            <summary>
            操作MonitorData的Helper类
            </summary>
        </member>
        <member name="M:MCS.Library.Core.PerformanceMonitorHelper.StartMonitor(System.String)">
            <summary>
            开始执行计数
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.PerformanceMonitorHelper.ExistsMonitor(System.String)">
            <summary>
            计数器是否已经存在
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.PerformanceMonitorHelper.RemoveMonitor(System.String)">
            <summary>
            移除计数器
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:MCS.Library.Core.PerformanceMonitorHelper.GetMonitor(System.String)">
            <summary>
            得到指定名称的监控数据
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.PerformanceMonitorHelper.GetDefaultMonitor">
            <summary>
            得到默认的Monitor
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Core.PerformanceMonitorHelper.DefaultMonitorName">
            <summary>
            默认的监视器的名称
            </summary>
        </member>
        <member name="T:MCS.Library.Core.ResourceHelper">
            <summary>
            资源访问的Helper
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ResourceHelper.LoadStringFromResource(System.Reflection.Assembly,System.String)">
            <summary>
            从资源中加载字符串
            </summary>
            <param name="assembly"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ResourceHelper.LoadStringFromResourceAsync(System.Reflection.Assembly,System.String)">
            <summary>
            异步从资源中读取字符串信息
            </summary>
            <param name="assembly"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ResourceHelper.LoadXmlFromResource(System.Reflection.Assembly,System.String)">
            <summary>
            从资源中加载xml文档对象
            </summary>
            <param name="assembly"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ResourceHelper.LoadXmlFromResourceAsync(System.Reflection.Assembly,System.String)">
            <summary>
            从资源中异步加载xml对象
            </summary>
            <param name="assembly"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ResourceHelper.LoadXmlReaderFromResource(System.Reflection.Assembly,System.String,System.IO.Stream@)">
            <summary>
            从资源中加载xml Reader
            </summary>
            <param name="assembly"></param>
            <param name="path"></param>
            <param name="stm"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ResourceHelper.LoadXElementFromResource(System.Reflection.Assembly,System.String)">
            <summary>
            从资源中加载XElement
            </summary>
            <param name="assembly"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ResourceHelper.LoadXElementFromResourceAsync(System.Reflection.Assembly,System.String)">
            <summary>
            从资源中异步加载XElement
            </summary>
            <param name="assembly"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ResourceHelper.GetResourceStream(System.Reflection.Assembly,System.String)">
            <summary>
            从资源中得到流
            </summary>
            <param name="assembly"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ResourceHelper.GetResourceBytes(System.Reflection.Assembly,System.String)">
            <summary>
            得到资源的二进制流
            </summary>
            <param name="assembly"></param>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.ServerInfo">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ServerInfo.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ServerInfo.#ctor(System.String,MCS.Library.Core.LogOnIdentity)">
            <summary>
            
            </summary>
            <param name="serverName"></param>
            <param name="identity"></param>
        </member>
        <member name="P:MCS.Library.Core.ServerInfo.Identity">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ServerInfo.ServerName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ServerInfo.Port">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ServerInfo.AuthenticateType">
            <summary>
            认证方式
            </summary>
        </member>
        <member name="T:MCS.Library.Core.ServiceProxy">
            <summary>
            WCF服务调用的客户端代理
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``1(System.String,System.Action{``0})">
            <summary>
            执行一次SingleCall
            </summary>
            <typeparam name="TChannel">服务接口</typeparam>
            <param name="endPointName">EndPoint的名称</param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``2(System.String,System.Func{``0,``1})">
            <summary>
            执行一次SingleCall，并且有返回值
            </summary>
            <typeparam name="TChannel"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="endPointName"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``1(System.ServiceModel.EndpointAddress,System.Action{``0})">
            <summary>
            默认使用BasicHttpBinding，调用address的服务
            </summary>
            <typeparam name="TChannel"></typeparam>
            <param name="address"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``2(System.ServiceModel.EndpointAddress,System.Func{``0,``1})">
            <summary>
            执行一次SingleCall，并且有返回值
            </summary>
            <typeparam name="TChannel"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="address"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``1(System.ServiceModel.BasicHttpBinding,System.ServiceModel.EndpointAddress,System.Action{``0})">
            <summary>
            执行一次SingleCall
            </summary>
            <typeparam name="TChannel"></typeparam>
            <param name="binding"></param>
            <param name="address"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``2(System.ServiceModel.BasicHttpBinding,System.ServiceModel.EndpointAddress,System.Func{``0,``1})">
            <summary>
            执行一次SingleCall，并且有返回值
            </summary>
            <typeparam name="TChannel"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="binding"></param>
            <param name="address"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``1(System.ServiceModel.BasicHttpBinding,System.ServiceModel.EndpointAddress,System.ServiceModel.Description.IEndpointBehavior,System.Action{``0})">
            <summary>
             执行一次SingleCall
            </summary>
            <typeparam name="TChannel"></typeparam>
            <param name="binding"></param>
            <param name="address"></param>
            <param name="behavior"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``2(System.ServiceModel.BasicHttpBinding,System.ServiceModel.EndpointAddress,System.ServiceModel.Description.IEndpointBehavior,System.Func{``0,``1})">
            <summary>
            执行一次SingleCall，并且有返回值
            </summary>
            <typeparam name="TChannel"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="binding"></param>
            <param name="address"></param>
            <param name="behavior"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``1(System.ServiceModel.ChannelFactory{``0},System.Action{``0})">
            <summary>
            执行一次SingleCall。其中Factory已经初始化了binding和address
            </summary>
            <typeparam name="TChannel"></typeparam>
            <param name="factory"></param>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.ServiceProxy.SingleCall``2(System.ServiceModel.ChannelFactory{``0},System.Func{``0,``1})">
            <summary>
            执行一次SingleCall，并且有返回值
            </summary>
            <typeparam name="TChannel"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="factory"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.StringExtension">
            <summary>
            字符串操作的扩展方法
            </summary>
        </member>
        <member name="F:MCS.Library.Core.StringExtension.EmptyStringArray">
            <summary>
            空的数组
            </summary>
        </member>
        <member name="M:MCS.Library.Core.StringExtension.ToBase16String(System.Byte[])">
            <summary>
            将byte数组转换为base16的字符串
            </summary>
            <param name="data">待转换的byte数组</param>
            <returns>转换好的16进制字符串</returns>
        </member>
        <member name="M:MCS.Library.Core.StringExtension.ToBase16Bytes(System.String)">
            <summary>
            将保存好的16进制字符串转换为byte数组
            </summary>
            <param name="strData"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.StringExtension.AppendWithSplitChars(System.Text.StringBuilder,System.String)">
            <summary>
            
            </summary>
            <param name="strB"></param>
            <param name="data"></param>
        </member>
        <member name="M:MCS.Library.Core.StringExtension.AppendWithSplitChars(System.Text.StringBuilder,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="strB"></param>
            <param name="data"></param>
            <param name="splitChars"></param>
        </member>
        <member name="T:MCS.Library.Core.CheckCidResult">
            <summary>
            身份证验证结果
            </summary>
        </member>
        <member name="F:MCS.Library.Core.CheckCidResult.None">
            <summary>
            空
            </summary>
        </member>
        <member name="F:MCS.Library.Core.CheckCidResult.Success">
            <summary>
            身份证验证成功
            </summary>
        </member>
        <member name="F:MCS.Library.Core.CheckCidResult.ErrorString">
            <summary>
            身份证串非法
            </summary>
        </member>
        <member name="F:MCS.Library.Core.CheckCidResult.ErrorProvince">
            <summary>
            身份证地区非法
            </summary>
        </member>
        <member name="F:MCS.Library.Core.CheckCidResult.ErrorBirthay">
            <summary>
            身份证生日非法
            </summary>
        </member>
        <member name="F:MCS.Library.Core.CheckCidResult.ErrorCard">
            <summary>
            身份证验证码非法
            </summary>
        </member>
        <member name="T:MCS.Library.Core.HZSpellOption">
            <summary>
            提供用于设置转换选项的枚举值。
            </summary>
        </member>
        <member name="F:MCS.Library.Core.HZSpellOption.FirstLetterOnly">
            <summary>
            只转换拼音首字母，默认转换全部
            </summary>
        </member>
        <member name="F:MCS.Library.Core.HZSpellOption.FirstLetterUpper">
            <summary>
            拼音中首字母大些
            </summary>
        </member>
        <member name="F:MCS.Library.Core.HZSpellOption.EnableUnknownWord">
            <summary>
            转换未知汉字为问号，默认不转换
            </summary>
        </member>
        <member name="F:MCS.Library.Core.HZSpellOption.EnableUnicodeLetter">
            <summary>
            保留非字母、非数字字符，默认不保留
            </summary>
        </member>
        <member name="T:MCS.Library.Core.StringHelper">
            <summary>
            此Class提供常用字符串数据的综合处理
            </summary>
            <remarks>
            处理内容包括有：
            1、半角全角数据的转换；
            2、中国大陆身份证的验证以及15位转换18位的实现；
            3、汉字拼音转换实现；
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.ToDBC(System.String)">
             <summary>
             全角转半角的函数(DBC case)
             </summary>
             <param name="source">任意字符串</param>
             <returns>半角字符串</returns>
            <remarks>
            全角空格为12288，半角空格为32
            其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.ToSBC(System.String)">
             <summary>
             半角转全角的函数(SBC case)
             </summary>
             <param name="source">任意字符串</param>
             <returns>全角字符串</returns>
            <remarks>
            全角空格为12288，半角空格为32
            其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248
            </remarks> 
        </member>
        <member name="M:MCS.Library.Core.StringHelper.CheckCidInfo(System.String)">
            <summary>
            中国大陆身份证验证程序
            </summary>
            <param name="userCid">待验证的用户身份证编号</param>
            <returns>检查结果</returns>
            <remarks>
            根据〖中华人民共和国国家标准 GB 11643-1999〗中有关公民身份号码的规定，公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。
            排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 
            地址码 : 表示编码对象常住户口所在县(市、旗、区)的行政区划代码,按gb/t2260的规定执行。
            生日期码 : 表示编码对象出生的年、月、日，其中年份用四位数字表示，年、月、日之间不用分隔符。
            顺序码 : 表示同一地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号。顺序码的奇数分给男性，偶数分给女性。
            校验码 : 是根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。
            
            15位的身份证编码首先把出生年扩展为4位，简单的就是增加一个19，但是这对于1900年出生的人不使用（这样的寿星不多了） 
            
            某男性公民身份号码本体码为34052419800101001?，首先按照公式⑴计算： 
            ∑(ai×Wi)(mod 11)……………………………………(1) 
            
            公式(1)中： 
            i----表示号码字符从由至左包括校验码在内的位置序号； 
            ai----表示第i位置上的号码字符值； 
            Wi----示第i位置上的加权因子，其数值依据公式Wi=2（n-1）(mod 11)计算得出。
            i		18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1 
            ai		3	4	0	5	2	4	1	9	8	0	0	1	0	1	0	0	1	? 
            Wi		7	9	10	5	8	4	2	1	6	3	7	9	10	5	8	4	2	 
            ai×Wi	21	36	0	25	16	16	2	9	48	0	0	9	0	5	0	0	2	? 
            
            根据公式(1)进行计算：
            ∑(ai×Wi) =（21+36+0+25+16+16+2+9+48++0+0+9+0+5+0+0+2) = 189 
            189 ÷ 11 = 17 + 2/11 
            ∑(ai×Wi)(mod 11) = 2 
            然后根据计算的结果，从下面的表中查出相应的校验码，其中X表示计算结果为10： 
            ∑(ai×WI)(mod 11) 0 1 2 3 4 5 6 7 8 9 10 
            校验码字符值ai 1 0 X 9 8 7 6 5 4 3 2 
            根据上表，查出计算结果为2的校验码为所以该人员的公民身份号码应该为 34052419800101001X
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.ConvertCid15to18(System.String)">
            <summary>
            中国大陆身份证15位转换位18位
            </summary>
            <param name="userCid15">待转换的15位身份证</param>
            <returns>转换成功的身份证编号</returns>
            <remarks>
            根据〖中华人民共和国国家标准 GB 11643-1999〗中有关公民身份号码的规定，公民身份号码是特征组合码，由十七位数字本体码和一位数字校验码组成。
            排列顺序从左至右依次为：六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 
            地址码 : 表示编码对象常住户口所在县(市、旗、区)的行政区划代码,按gb/t2260的规定执行。
            生日期码 : 表示编码对象出生的年、月、日，其中年份用四位数字表示，年、月、日之间不用分隔符。
            顺序码 : 表示同一地址码所标识的区域范围内，对同年、月、日出生的人员编定的顺序号。顺序码的奇数分给男性，偶数分给女性。
            校验码 : 是根据前面十七位数字码，按照ISO 7064:1983.MOD 11-2校验码计算出来的检验码。
            
            15位的身份证编码首先把出生年扩展为4位，简单的就是增加一个19，但是这对于1900年出生的人不使用（这样的寿星不多了） 
            
            某男性公民身份号码本体码为34052419800101001?，首先按照公式⑴计算： 
            ∑(ai×Wi)(mod 11)……………………………………(1) 
            
            公式(1)中： 
            i----表示号码字符从由至左包括校验码在内的位置序号； 
            ai----表示第i位置上的号码字符值； 
            Wi----示第i位置上的加权因子，其数值依据公式Wi=2（n-1）(mod 11)计算得出。
            i		18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1 
            ai		3	4	0	5	2	4	1	9	8	0	0	1	0	1	0	0	1	? 
            Wi		7	9	10	5	8	4	2	1	6	3	7	9	10	5	8	4	2	 
            ai×Wi	21	36	0	25	16	16	2	9	48	0	0	9	0	5	0	0	2	? 
            
            根据公式(1)进行计算：
            ∑(ai×Wi) =（21+36+0+25+16+16+2+9+48++0+0+9+0+5+0+0+2) = 189 
            189 ÷ 11 = 17 + 2/11 
            ∑(ai×Wi)(mod 11) = 2 
            然后根据计算的结果，从下面的表中查出相应的校验码，其中X表示计算结果为10： 
            ∑(ai×WI)(mod 11) 0 1 2 3 4 5 6 7 8 9 10 
            校验码字符值ai 1 0 X 9 8 7 6 5 4 3 2 
            根据上表，查出计算结果为2的校验码为所以该人员的公民身份号码应该为 34052419800101001X
            </remarks>
        </member>
        <member name="F:MCS.Library.Core.StringHelper.pystr">
            <summary>
            拼音代码表
            </summary>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.ConvertChsToPinYin(System.String,MCS.Library.Core.HZSpellOption)">
            <summary>
            获取汉字的汉语拼音
            </summary>
            <param name="source">欲转换的字符串</param>
            <param name="spellOptions">SpellOptions枚举值的按位 OR 组合</param>
            <example>
            <code>
            string source = "一只棕色狐狸跳过那只狗";
            string result = StringHelper.ConvertChsToPinYin(source, HZSpellOption.EnableUnicodeLetter);
            </code>
            </example>
            <returns>转换之后的结果</returns>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.HasPattern(System.String,System.String)">
            <summary>
            是否存在正则表达式的匹配成功项目
            </summary>
            <param name="pattern">正则表达式的定义</param>
            <param name="input">待匹配的字符创</param>
            <returns>匹配是否成功</returns>
            <remarks>是否存在正则表达式的匹配成功项目。该函数的目的在于简化正则表达式的构造过程</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidEmail(System.String)">
            <summary>
            检查字符串是否合法 Email 格式
            </summary>
            <param name="source">待检查的字符串</param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法Email格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidInterger(System.String)">
            <summary>
            检查字符串是否合法 Interger[整数] 格式
            </summary>
            <param name="source">待检查的字符串</param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法 Interger[整数] 格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidMoney(System.String)">
            <summary>
            检查字符串是否合法 金额【最多两位小树】 格式
            </summary>
            <param name="source">待检查的字符串</param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法 金额【最多两位小数】 格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidAlpha(System.String)">
            <summary>
            检查字符串是否合法 全字母【不分大小写】 格式
            </summary>
            <param name="source">待检查的字符串</param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法 全字母【不分大小写】 格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidAlphaAndNumber(System.String)">
            <summary>
            检查字符串是否合法 字母【不分大小写】和数字 格式
            </summary>
            <param name="source"></param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法 字母【不分大小写】和数字 格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidAlphaUpper(System.String)">
            <summary>
            检查字符串是否合法 大些字母 格式
            </summary>
            <param name="source">待检查的字符串</param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法 大些字母 格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidAlphaLower(System.String)">
            <summary>
            检查字符串是否合法 小写字母 格式
            </summary>
            <param name="source">待检查的字符串</param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法 小写字母 格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidNumber(System.String)">
            <summary>
            检查字符串是否合法 数字串 格式
            </summary>
            <param name="source">待检查的字符串</param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法 数字串 格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidChinese(System.String)">
            <summary>
            检查字符串是否合法 汉字字符串 格式
            </summary>
            <param name="source">待检查的字符串</param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法 汉字字符串 格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidUrl(System.String)">
            <summary>
            检查字符串是否合法 Url地址【Ftp、Http等】 格式
            </summary>
            <param name="source">待检查的字符串</param>
            <returns>是否合法</returns>
            <remarks>检查字符串是否合法 Url地址【Ftp、Http等】 格式</remarks>
        </member>
        <member name="M:MCS.Library.Core.StringHelper.IsValidIPAddress(System.String)">
            <summary>
            是不是IP地址
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.SystemSupportException">
            <summary>
            定制的异常类
            </summary>
            <remarks>定制的异常类,这种异常类会提醒前端程序显示出技术支持信息的提示信息，该类继承自ApplicationException类。
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.SystemSupportException.#ctor">
            <summary>
            SystemSupportException的缺省构造函数
            </summary>
            <remarks>SystemSupportException的缺省构造函数.
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.SystemSupportException.#ctor(System.String)">
            <summary>
            SystemSupportException的带错误消息参数的构造函数
            </summary>
            <param name="strMessage">错误消息串</param>
            <remarks>SystemSupportException的带错误消息参数的构造函数,该错误消息将在消息抛出异常时显示出来。
            <seealso cref="T:MCS.Library.Expression.ExpTreeExecutor"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.SystemSupportException.#ctor(System.String,System.Exception)">
            <summary>
            SystemSupportException的构造函数。
            </summary>
            <param name="strMessage">错误消息串</param>
            <param name="ex">导致该异常的异常</param>
            <remarks>该构造函数把导致该异常的异常记录了下来。
            </remarks>
        </member>
        <member name="T:MCS.Library.Caching.MixedDependency">
            <summary>
            混合Cache依赖类，是AbsoluteTimeDependency、SlidingTimeDependency和FileCacheDependency的任意组合
            当其中任何一项过期时，认为与此MixedDependency相关的Cache项过期
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.MixedDependency.#ctor(MCS.Library.Caching.DependencyBase[])">
            <summary>
            构造函数
            </summary>
            <param name="dependencyArray">包含AbsoluteTimeDependency、SlidingTimeDependency、FileCacheDependency或自身的数组</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\MixedDependencyTest.cs" region="HasChangedTest" lang="cs" title="组合的Dependency" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.MixedDependency.SetChanged">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.MixedDependency.Dispose(System.Boolean)">
            <summary>
            释放资源
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:MCS.Library.Caching.MixedDependency.CacheItemBinded">
            <summary>
            当Dependency对象绑定到CacheItem时调用此方法。回递归调用子Dependency的CacheItemBinded方法
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.MixedDependency.HasChanged">
            <summary>
            属性，判断此Cache依赖是否过期
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\MixedDependencyTest.cs" region="HasChangedTest" lang="cs" title="组合的Dependency" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Caching.MixedDependency.UtcLastAccessTime">
            <summary>
            属性,获取或设置Cache项的最后访问时间的UTC时间值
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.MixedDependency.UtcLastModified">
            <summary>
            属性,获取或设置Cache项最后修改时间的UTC时间值
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.PortableCacheQueue`2">
            <summary>
            为一泛型Cache类，和CacheQueue不同的是，PortableCacheQueue内部没有实现LRU算法，
            而且容量大小也不做限制。用户在使用此Cache时同样需要从此类派生一新类，并手工注册，
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.#ctor(System.Boolean)">
            <summary>
            构造方法
            </summary>
            <param name="overrideExists">Add Cache项时，是否覆盖已有的数据</param>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.Add(`0,`1)">
            <summary>
            向CacheQueue中增加一Cache项值对，如果相应的key已经存在，则抛出异常
            此种构造方法无相关Dependency，所以此增加Cache项不会过期，只可能当CacheQueue
            的长度超过预先设定时，才可能被清理掉
            </summary>
            <param name="key">键</param>
            <param name="data">值</param>
            <returns>值</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\PortableCacheQueueTest.cs" region="AddRemoveClearTest" lang="cs" title="增加、移除、获取CahceItem项" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.Add(`0,`1,MCS.Library.Caching.DependencyBase)">
            <summary>
            向CacheQueue中增加一个有关联Dependency的Cache项，如果相应的key已经存在，则抛出异常
            </summary>
            <param name="key">键</param>
            <param name="data">值</param>
            <param name="dependency">依赖：相对时间依赖、绝对时间依赖、文件依赖或混合依赖</param>
            <returns>值</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\PortableCacheQueueTest.cs" region="AddRemoveClearTest" lang="cs" title="增加、移除、获取CahceItem项" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.ContainsKey(`0)">
            <summary>
            判断PortableCacheQueue中是否包含key键的Cache项
            </summary>
            <param name="key">查询的cache项的键值</param>
            <returns>如果包含此键值，返回true，否则返回false</returns>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.TryGetValue(`0,`1@)">
            <summary>
            通过key，获取Cache项的value，如果相应的cache项存在的话
            则将cache项的value作为输出参数，返回给客户端代码
            </summary>
            <param name="key">cache项的key</param>
            <param name="data">cache项的value</param>
            <returns>如果CacheQueue中包含此Cache项，则返回true，否则返回false</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\PortableCacheQueueTest.cs" region="GetCacheItemTest" lang="cs" title="通过key，获取Cache项的value" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.GetOrAddNewValue(`0,MCS.Library.Caching.PortableCacheQueue{`0,`1}.PortableCacheItemNotExistsAction)">
            <summary>
            在Cache中读取Cache项，如果不存在，则调用action
            </summary>
            <param name="key">键值</param>
            <param name="action">不存在时的回调</param>
            <returns>Cache项的值</returns>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.Remove(`0)">
            <summary>
            通过key，删除一Cache项
            </summary>
            <param name="key">键</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\PortableCacheQueueTest.cs" region="AddRemoveClearTest" lang="cs" title="增加、移除、获取CahceItem项" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.RemoveItem(MCS.Library.Caching.CacheItemBase)">
            <summary>
            重载基类方法，删除传入的CacheItem
            </summary>
            <param name="cacheItem"></param>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.Clear">
            <summary>
            清空整个CacheQueue，删除CacheQueue中所有的Cache项
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\PortableCacheQueueTest.cs" region="AddRemoveClearTest" lang="cs" title="增加、移除、获取CahceItem项" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.SetChanged">
            <summary>
            全部更新了
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.DoScavenging">
            <summary>
            清理方法，清理本CacheQueue中过期的cache项
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.GetAllItemsInfo">
            <summary>
            得到所有项的信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.InnerRemove(`0,MCS.Library.Caching.CacheItem{`0,`1})">
            <summary>
            删除Cache项
            </summary>
            <param name="key">Cache项键值</param>
            <param name="item">Cache项</param>
        </member>
        <member name="M:MCS.Library.Caching.PortableCacheQueue`2.CheckDependencyChanged(`0,MCS.Library.Caching.CacheItem{`0,`1})">
            <summary>
            判断一Cache项是否过期
            </summary>
            <param name="key">Cache项的键值</param>
            <param name="item">Cache项</param>
            <returns>如果Cache项过期，返回true，并将其删除，否则返回false</returns>
        </member>
        <member name="P:MCS.Library.Caching.PortableCacheQueue`2.Count">
            <summary>
            属性，获取CacheQueue的最大容量
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.PortableCacheQueue`2.Item(`0)">
            <summary>
            通过Cache项的key获取Cache项Value的索引器
            </summary>
            <param name="key">cache项key</param>
            <returns>cache项Value</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\PortableCacheQueueTest.cs" region="GetCacheItemTest" lang="cs" title="通过Cache项的key获取Cache项Value" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Caching.PortableCacheQueue`2.PortableCacheItemNotExistsAction">
            <summary>
            Cache项不存在时的委托定义
            </summary>
            <param name="cache">Cache对列</param>
            <param name="key">键值</param>
            <returns>新的Cache项</returns>
        </member>
        <member name="T:MCS.Library.Reflection.DynamicFieldDelegation`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MCS.Library.Reflection.DynamicMemberDelegationBase`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:MCS.Library.Core.IMemberAccessor">
            <summary>
            类成员访问器的接口
            </summary>
        </member>
        <member name="M:MCS.Library.Core.IMemberAccessor.GetValue(System.Object,System.String)">
            <summary>
            读取成员的值
            </summary>
            <param name="instance">对象实例</param>
            <param name="memberName">成员名称</param>
            <returns>成员的值</returns>
        </member>
        <member name="M:MCS.Library.Core.IMemberAccessor.SetValue(System.Object,System.String,System.Object)">
            <summary>
            设置成员的值
            </summary>
            <param name="instance">对象实例</param>
            <param name="memberName">成员名称</param>
            <param name="newValue">值</param>
        </member>
        <member name="T:MCS.Library.Reflection.IMemberDelegation">
            <summary>
            成员委托需要实现的接口
            </summary>
        </member>
        <member name="M:MCS.Library.Reflection.IMemberDelegation.InitDelegations">
            <summary>
            初始化委托信息
            </summary>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberDelegationBase`1.GetValue(`0,System.String)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <param name="memberName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberDelegationBase`1.SetValue(`0,System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <param name="memberName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberDelegationBase`1.GetValue(System.Object,System.String)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <param name="memberName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberDelegationBase`1.SetValue(System.Object,System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <param name="memberName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberDelegationBase`1.InitDelegations">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberDelegationBase`1.GenerateGetValue(System.Type)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberDelegationBase`1.GenerateSetValue(System.Type)">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberDelegationBase`1.AddGetValueCaseExpression(System.Type,System.Linq.Expressions.ParameterExpression,System.Collections.Generic.IList{System.Linq.Expressions.SwitchCase})">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="instance"></param>
            <param name="cases"></param>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberDelegationBase`1.AddSetValueCaseExpression(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Collections.Generic.IList{System.Linq.Expressions.SwitchCase})">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="instance"></param>
            <param name="newValue"></param>
            <param name="cases"></param>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicFieldDelegation`1.AddGetValueCaseExpression(System.Type,System.Linq.Expressions.ParameterExpression,System.Collections.Generic.IList{System.Linq.Expressions.SwitchCase})">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="instance"></param>
            <param name="cases"></param>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicFieldDelegation`1.AddSetValueCaseExpression(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Collections.Generic.IList{System.Linq.Expressions.SwitchCase})">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="instance"></param>
            <param name="newValue"></param>
            <param name="cases"></param>
        </member>
        <member name="T:MCS.Library.Reflection.DynamicFieldValueAccessor">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Reflection.DynamicMemberValueAccessorBase">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Reflection.DynamicMemberValueAccessorBase._classAccessors">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Reflection.DynamicMemberValueAccessorBase._SyncObject">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberValueAccessorBase.GetValue(System.Object,System.String)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <param name="memberName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberValueAccessorBase.GetValue(System.Type,System.Object,System.String)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="instance"></param>
            <param name="memberName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberValueAccessorBase.SetValue(System.Object,System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="instance"></param>
            <param name="memberName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberValueAccessorBase.SetValue(System.Type,System.Object,System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="instance"></param>
            <param name="memberName"></param>
            <param name="newValue"></param>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicMemberValueAccessorBase.CreateDelegationClass(System.Type)">
            <summary>
            创建委托类的实例
            </summary>
            <param name="genericType"></param>
            <returns></returns>
        </member>
        <member name="F:MCS.Library.Reflection.DynamicFieldValueAccessor.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicFieldValueAccessor.CreateDelegationClass(System.Type)">
            <summary>
            
            </summary>
            <param name="genericType"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.DynamicHelper">
            <summary>
            方法或属性动态调用的帮助类
            </summary>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.GetMethodInvokeDelegate(System.Reflection.MethodInfo)">
            <summary>
            得到创建方法动态调用的委托。已经创建过的，会放在缓存中
            </summary>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.BuildMethodInvokeDelegate(System.Reflection.MethodInfo)">
            <summary>
            创建方法动态调用的委托
            </summary>
            <param name="methodInfo"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.GetPropertySetterDelegate(System.Reflection.PropertyInfo)">
            <summary>
            从Cache中得到设置对象属性的委托
            </summary>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.GetPropertySetterDelegate(System.Reflection.PropertyInfo,System.Type)">
            <summary>
            从Cache中得到设置对象属性的委托
            </summary>
            <param name="propertyInfo"></param>
            <param name="valueType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.BuildPropertySetterDelegate(System.Reflection.PropertyInfo,System.Type)">
            <summary>
            创建设置对象属性委托
            </summary>
            <param name="propertyInfo"></param>
            <param name="valueType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.GetPropertyGetterDelegate(System.Reflection.PropertyInfo)">
            <summary>
            从Cache中读取对象属性的委托
            </summary>
            <param name="propertyInfo"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.GetPropertyGetterDelegate(System.Reflection.PropertyInfo,System.Type)">
            <summary>
            从Cache中读取对象属性的委托
            </summary>
            <param name="propertyInfo"></param>
            <param name="valueType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.BuildPropertyGetterDelegate(System.Reflection.PropertyInfo,System.Type)">
            <summary>
            创建读取对象属性的委托
            </summary>
            <param name="propertyInfo"></param>
            <param name="valueType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.GetFiledGetterDelegate(System.Reflection.FieldInfo)">
            <summary>
            从Cache中读取对象字段的委托
            </summary>
            <param name="fieldInfo"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.GetFiledGetterDelegate(System.Reflection.FieldInfo,System.Type)">
            <summary>
            从Cache中读取对象字段的委托
            </summary>
            <param name="fieldInfo"></param>
            <param name="valueType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.BuildFieldGetterDelegate(System.Reflection.FieldInfo,System.Type)">
            <summary>
            创建读取对象字段的委托
            </summary>
            <param name="fieldInfo"></param>
            <param name="valueType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.GetFieldSetterDelegate(System.Reflection.FieldInfo)">
            <summary>
            从Cache中得到设置对象字段的委托
            </summary>
            <param name="fieldInfo"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.GetFieldSetterDelegate(System.Reflection.FieldInfo,System.Type)">
            <summary>
            从Cache中得到设置对象字段的委托
            </summary>
            <param name="fieldInfo"></param>
            <param name="valueType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.DynamicHelper.BuildFieldSetterDelegate(System.Reflection.FieldInfo,System.Type)">
            <summary>
            创建设置对象字段委托
            </summary>
            <param name="fieldInfo"></param>
            <param name="valueType">值类型</param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Reflection.DynamicPropertyDelegation`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicPropertyDelegation`1.AddGetValueCaseExpression(System.Type,System.Linq.Expressions.ParameterExpression,System.Collections.Generic.IList{System.Linq.Expressions.SwitchCase})">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="instance"></param>
            <param name="cases"></param>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicPropertyDelegation`1.AddSetValueCaseExpression(System.Type,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Collections.Generic.IList{System.Linq.Expressions.SwitchCase})">
            <summary>
            
            </summary>
            <param name="type"></param>
            <param name="instance"></param>
            <param name="newValue"></param>
            <param name="cases"></param>
        </member>
        <member name="T:MCS.Library.Reflection.DynamicPropertyValueAccessor">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Reflection.DynamicPropertyValueAccessor.Instance">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Reflection.DynamicPropertyValueAccessor.CreateDelegationClass(System.Type)">
            <summary>
            
            </summary>
            <param name="genericType"></param>
            <returns></returns>
        </member>
        <member name="F:MCS.Library.Core.FieldGetMethodDelegateCache.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="F:MCS.Library.Core.FieldSetMethodDelegateCache.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="F:MCS.Library.Core.InvokeMethodDelegateCache.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="F:MCS.Library.Core.PropertyGetMethodDelegateCache.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="F:MCS.Library.Core.PropertySetMethodDelegateCache.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="T:MCS.Library.Core.TypeCreator">
            <summary>
            运用晚绑定方式动态生成实例
            </summary>
            <remarks>运用晚绑定方式动态生成实例。
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.CreateInstance(System.String,System.Object[])">
            <summary>
            运用后绑定方式动态的创建一个实例。
            </summary>
            <param name="typeDescription">创建实例的完整类型名称</param>
            <param name="constructorParams">创建实例的初始化参数</param>
            <returns>实例对象</returns>
            <remarks>运用晚绑定方式动态创建一个实例
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\TypeCreatorTest.cs" region="CreateInstanceTest" lang="cs" title="运用晚绑定创建一个实例"/>
            <seealso cref="T:MCS.Library.Logging.LogFilterFactory"/>
            <seealso cref="T:MCS.Library.Logging.LogFormatterFactory"/>
            <seealso cref="T:MCS.Library.Logging.TraceListenerFactory"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.CreateInstance``1(System.String,System.Object[])">
            <summary>
            根据类型信息，通过反射构造此类型，并且根据构造参数名称找到最匹配的构造方法，然后调用构造方法。会进行类型检查
            </summary>
            <typeparam name="T"></typeparam>
            <param name="typeDescription"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.CreateInstance(System.Type,System.Object[])">
            <summary>
            根据类型信息创建对象，该对象即使没有公有的构造方法，也可以创建实例
            </summary>
            <param name="type">创建类型时的类型信息</param>
            <param name="constructorParams">创建实例的初始化参数</param>
            <returns>实例对象</returns>
            <remarks>运用晚绑定方式动态创建一个实例</remarks>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.CreateInstance``1(System.Type,System.Object[])">
            <summary>
            根据类型信息，通过反射构造此类型，并且根据构造参数名称找到最匹配的构造方法，然后调用构造方法。会进行类型检查
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.CreateInstance(System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            根据类型信息，通过反射构造此类型，并且根据构造参数名称找到最匹配的构造方法，然后调用构造方法
            </summary>
            <param name="typeDescription"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.CreateInstance``1(System.String,System.Collections.Specialized.NameValueCollection)">
            <summary>
            根据类型信息，通过反射构造此类型，并且根据构造参数名称找到最匹配的构造方法，然后调用构造方法。会进行类型检查
            </summary>
            <typeparam name="T"></typeparam>
            <param name="typeDescription"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.CreateInstance(System.Type,System.Collections.Specialized.NameValueCollection)">
            <summary>
            根据类型信息，通过反射构造此类型，并且根据构造参数名称找到最匹配的构造方法，然后调用构造方法
            </summary>
            <param name="type"></param>
            <param name="constructorParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.GetTypeInfo(System.String)">
            <summary>
            根据类型描述得到类型对象
            </summary>
            <param name="typeDescription">完整类型描述，应该是Namespace.ClassName, AssemblyName</param>
            <returns>类型对象</returns>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.TryGetTypeInfo(System.String,System.Type@)">
            <summary>
            根据类型描述试图得到类型对象，如果成功，返回true，否则为false
            </summary>
            <param name="typeDescription"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.TypeCreator.GetTypeDefaultValue(System.Type)">
            <summary>
            得到某个数据类型的缺省值
            </summary>
            <param name="type">类型</param>
            <returns>该类型的缺省值</returns>
            <remarks>如果该类型为引用类型，则返回null，否则返回值类型的缺省值。如Int32返回0，DateTime返回DateTime.MinValue</remarks>
        </member>
        <member name="T:MCS.Library.Core.TypeFieldInfo">
            <summary>
            类型的属性信息
            </summary>
        </member>
        <member name="F:MCS.Library.Core.TypeFieldInfo.ObjectType">
            <summary>
            Field所属的对象的类型
            </summary>
        </member>
        <member name="F:MCS.Library.Core.TypeFieldInfo.FieldName">
            <summary>
            Field的名字
            </summary>
        </member>
        <member name="T:MCS.Library.Core.ExtendedFieldInfo">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.ExtendedFieldInfo.#ctor(System.Reflection.FieldInfo)">
            <summary>
            
            </summary>
            <param name="fieldInfo"></param>
        </member>
        <member name="P:MCS.Library.Core.ExtendedFieldInfo.FieldInfo">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ExtendedFieldInfo.IsNotSerialized">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ExtendedFieldInfo.AlternateFieldName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.ExtendedFieldInfo.IgnoreDeserializeError">
            <summary>
            忽略反序列化时的错误
            </summary>
        </member>
        <member name="M:MCS.Library.Core.TypeFields.GetTypeFields(System.Type)">
            <summary>
            得到类型的Fields信息
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.TypeFields.GetTypeField(System.Type,System.String)">
            <summary>
            得到类型具体的Field信息
            </summary>
            <param name="type"></param>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Core.TypeFields.Fields">
            <summary>
            字段信息
            </summary>
        </member>
        <member name="T:MCS.Library.Core.TypeFieldsCache">
            <summary>
            类型属性信息的缓存类
            </summary>
        </member>
        <member name="F:MCS.Library.Core.TypeFieldsCache.Instance">
            <summary>
            获取缓存实例
            </summary>
        </member>
        <member name="T:MCS.Library.Core.UriHelper">
            <summary>
            提供和Uri相关处理的相关函数。这里采用静态方法的形式提供出Uri中的参数提取及Uri解析等功能。 
            </summary>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetUrlWithoutParameters(System.String)">
            <summary>
            得到Url中不带参数的部分，也就是？左边的部分
            </summary>
            <param name="uriString"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetUriParamsCollection(System.Uri)">
            <summary>
            分析Url，得到所有的参数集合
            </summary>
            <param name="url">Uri类型的Url，绝对路径或相对路径</param>
            <returns>NameValueCollection，参数集合</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetUriParamsCollection(System.String)">
            <summary>
            从url中，获取参数的集合
            </summary>
            <param name="uriString">url</param>
            <returns>参数集合</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetUriParamsCollection(System.String,System.Boolean)">
            <summary>
            从url中，获取参数的集合
            </summary>
            <param name="uriString">url</param>
            <param name="urlDecode">是否执行decode</param>
            <returns>参数集合</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetUrlWithSortedParams(System.Uri)">
            <summary>
            将Url中的参数进行排序，返回参数排序后的url串
            </summary>
            <param name="url">Uri类型的Url，绝对路径或相对路径</param>
            <returns>参数排序后的url串</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetUrlWithSortedParams(System.String)">
            <summary>
            将Url中的参数进行排序，返回参数排序后的url串
            </summary>
            <param name="uriString">Url，绝对路径或相对路径</param>
            <returns>参数排序后的url串</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.RemoveUriParams(System.String,System.String[])">
            <summary>
            移除Url中指定的参数
            </summary>
            <param name="uriString"></param>
            <param name="paramNames"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.RemoveUriParams(System.String,System.Text.Encoding,System.String[])">
            <summary>
            移除Url中指定的参数
            </summary>
            <param name="uriString"></param>
            <param name="encoding"></param>
            <param name="paramNames"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.RemoveUriParams(System.Uri,System.String[])">
            <summary>
            移除Url中指定的参数
            </summary>
            <param name="uriString"></param>
            <param name="paramNames"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.RemoveUriParams(System.Uri,System.Text.Encoding,System.String[])">
            <summary>
            移除Url中指定的参数
            </summary>
            <param name="uriString"></param>
            <param name="encoding"></param>
            <param name="paramNames"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.ReplaceUriParams(System.String,System.Action{System.Collections.Specialized.NameValueCollection})">
            <summary>
            替换Url中的参数。将参数变成NameValueCollection后提供给调用者，由调用者提供的替换方式
            </summary>
            <param name="uri"></param>
            <param name="action"></param>
            <returns>返回替换参数后的Url</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.ReplaceUriParams(System.String,System.Boolean,System.Action{System.Collections.Specialized.NameValueCollection})">
            <summary>
            替换Url中的参数。将参数变成NameValueCollection后提供给调用者，由调用者提供的替换方式
            </summary>
            <param name="uri"></param>
            <param name="encodeParams">是否使用UTF编码替换参数</param>
            <param name="action"></param>
            <returns>返回替换参数后的Url</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.ReplaceUriParams(System.String,System.Text.Encoding,System.Action{System.Collections.Specialized.NameValueCollection})">
            <summary>
            替换Url中的参数。将参数变成NameValueCollection后提供给调用者，由调用者提供的替换方式
            </summary>
            <param name="uri"></param>
            <param name="encoding">编码方式，如果是null，则不编码</param>
            <param name="action"></param>
            <returns>返回替换参数后的Url</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.MakeAbsolute(System.Uri,System.Uri)">
            <summary>
            将当前的Url转换成绝对路径的Url，这个地址相对于refUri的地址
            </summary>
            <param name="thisUri"></param>
            <param name="refUri"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.CombineUrlParams(System.String,System.Text.Encoding,System.Collections.Specialized.NameValueCollection[])">
            <summary>
            将参数重新组合成Url
            </summary>
            <param name="uriString">url</param>
            <param name="encoding">字符编码，如果为null，表示不用Encode</param>
            <param name="requestParamsArray">参数集合的数组</param>
            <returns>补充了参数的url</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.CombineUrlParams(System.String,System.Collections.Specialized.NameValueCollection[])">
            <summary>
            将参数重新组合成Url
            </summary>
            <param name="uriString">url</param>
            <param name="requestParamsArray">参数集合的数组</param>
            <returns>补充了参数的url</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.CombineUrlParams(System.String,System.Boolean,System.Collections.Specialized.NameValueCollection[])">
            <summary>
            是否需要Encode
            </summary>
            <param name="uriString"></param>
            <param name="encodeParams"></param>
            <param name="requestParamsArray"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetBookmarkStringInUrl(System.String)">
            <summary>
            得到url中的书签部分。“#”后面的部分
            </summary>
            <param name="queryString">http://localhost/lianhome#littleTurtle</param>
            <returns>littleTurtle</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.ResolveUri(System.String)">
            <summary>
            解析Uri，如果Uri为相对路径，处理Uri中~，将其替换为当前的Web应用
            </summary>
            <param name="uriString">Uri</param>
            <returns>如果Uri为相对路径，处理Uri中~，将其替换为当前的Web应用</returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.ResolveRelativeUri(System.String)">
            <summary>
            解析Uri，如果Uri为相对路径，处理Uri中~，将其替换为当前的Web应用相对路径
            </summary>
            <param name="uriString"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetDiractoryUri(System.String)">
            <summary>
            得到Url中的目录部分。从后面数第一个斜线的左侧部分，包括斜线本身
            </summary>
            <param name="uriString"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetDiractoryUri(System.Uri)">
            <summary>
            得到Url中的目录部分。从后面数第一个斜线的左侧部分，包括斜线本身。如果uriString为null，则返回地址为空串的uri。
            </summary>
            <param name="uriString"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.GetAllDirectories(System.Uri)">
            <summary>
            得到Uri中所有的目录
            </summary>
            <param name="uriString"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.CombinePath(System.Uri,System.Uri[])">
            <summary>
            组合不同的Uri，将两个Url之间合并在一起，并且去除它们之间的双斜线
            </summary>
            <param name="uriString1"></param>
            <param name="strings"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.CombinePath(System.String,System.String[])">
            <summary>
            组合不同的Uri，去除它们之间的双斜线
            </summary>
            <param name="uriString1"></param>
            <param name="strings"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.MergePath(System.Uri,System.Uri)">
            <summary>
            合并多个Url，并且根据..或.进行目录合并
            </summary>
            <param name="baseUri"></param>
            <param name="relUri"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.ToUriString(System.Uri)">
            <summary>
            直接转成字符串，可以保证uri为null的时候转换成空串
            </summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.CompareSchemeAndHost(System.Uri,System.Uri)">
            <summary>
            比较两个Url的scheme部分host部分和port部分
            </summary>
            <param name="uri1"></param>
            <param name="uri2"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.ComparePathAndParameters(System.Uri,System.Uri,System.String[])">
            <summary>
            比较两个url的路径和参数部分，不包含host，scheme和port。两个Uri必须都是绝对路径，如果有一个为相对，则返回false。两个都是，则抛出异常
            </summary>
            <param name="uri1"></param>
            <param name="uri2"></param>
            <param name="ignoreParameters">需要忽略的参数名称</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.UriHelper.AreSameUri(System.Uri,System.Uri,System.String[])">
            <summary>
            是否是相同的Uri。两者都是null，则返回true
            </summary>
            <param name="uri1"></param>
            <param name="uri2"></param>
            <param name="ignoreParameters"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.UuidHelper">
            <summary>
            辅助生成连续的UUID的类
            </summary>
        </member>
        <member name="M:MCS.Library.Core.UuidHelper.NewUuid">
            <summary>
            生成连续的UUID，底层调用了Windows API UuidCreateSequential。经测试发现，
            UuidCreateSequential，在多CPU并发状态下，有可能会产生重复数据，因此这个方法进行的并发控制，并延迟1毫秒。
            另外，UuidCreateSequential的生成和网络连接有关（网卡），如果电脑上插了Windows Mobile的手机，会产生新的网络连接，
            导致UuidCreateSequential出错，此时，这个方法将使用传统的Guid来替代Uuid。
            </summary>
            <returns>在本机生成连续的Guid</returns>
        </member>
        <member name="M:MCS.Library.Core.UuidHelper.NewUuidString">
            <summary>
            生成连续的UUID，底层调用了Windows API UuidCreateSequential
            </summary>
            <returns>在本机生成连续的Guid</returns>
        </member>
        <member name="T:MCS.Library.Core.XElementExtension">
            <summary>
            XElement的扩展
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XElementExtension.Element``1(System.Xml.Linq.XElement,System.Xml.Linq.XName,``0)">
            <summary>
            扩展Element方法，如果Element不存在，返回缺省值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XElementExtension.ElementValue(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            得到Element的字符串Value，如果不存在，返回空串
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XElementExtension.Attribute``1(System.Xml.Linq.XElement,System.Xml.Linq.XName,``0)">
            <summary>
            得到属性的值，如果不存在，则返回缺省值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XElementExtension.AttributeValue(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            得到Attribute的字符串Value，如果不存在，返回空串
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XElementExtension.AttributeWithAlterName``1(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName,``0)">
            <summary>
            得到属性的值，先用AlterName去取，如果不存在，则使用name，如果还不存在，则返回缺省值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="alterName"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XElementExtension.AttributeValueWithAlterName(System.Xml.Linq.XElement,System.Xml.Linq.XName,System.Xml.Linq.XName)">
            <summary>
            得到Attribute的字符串Value，先用AlterName去取，如果不存在，则使用name，如果还不存在，返回空串
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="alterName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XElementExtension.AddChildElement(System.Xml.Linq.XElement,System.Xml.Linq.XName)">
            <summary>
            添加子节点
            </summary>
            <param name="parent"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XElementExtension.AddChildElement``1(System.Xml.Linq.XElement,System.Xml.Linq.XName,``0)">
            <summary>
            添加子节点的同时，设置子节点的内容
            </summary>
            <typeparam name="T"></typeparam>
            <param name="parent"></param>
            <param name="name"></param>
            <param name="nodeValue"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.XElementFieldSerializeAttribute">
            <summary>
            XElement序列化的属性，作用在Field上
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XElementFieldSerializeAttribute.AlternateFieldName">
            <summary>
            序列化时用的属性名称
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XElementFieldSerializeAttribute.IgnoreDeserializeError">
            <summary>
            反序列化时，是否忽略错误（不停止反序列化）
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XElementFormattingStatus">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Core.XElementFormattingStatus.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Core.XElementFormattingStatus.Serializing">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Core.XElementFormattingStatus.Deserializing">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XElementFormatter">
            <summary>
            对象序列化成XElement
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XElementFormatter.Serialize(System.Object)">
            <summary>
            对象序列化为XElement
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XElementFormatter.Deserialize(System.Xml.Linq.XElement)">
            <summary>
            反序列化对象
            </summary>
            <param name="root"></param>
        </member>
        <member name="M:MCS.Library.Core.XElementFormatter.CreateSerializableInstance(System.Type,System.Object[])">
            <summary>
            根据类型信息创建对象，该对象即使没有公有的构造方法，也可以创建实例
            </summary>
            <param name="type">创建类型时的类型信息</param>
            <param name="constructorParams">创建实例的初始化参数</param>
            <returns>实例对象</returns>
            <remarks>运用晚绑定方式动态创建一个实例</remarks>
        </member>
        <member name="E:MCS.Library.Core.XElementFormatter.FieldCanXElementSerialize">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XElementFormatter.OutputShortType">
            <summary>
            序列化时是否输出ShortType
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XElementFormatter.Binder">
            <summary>
            序列化时的Binder(类型映射)
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XElementFormatter.FormattingStatus">
            <summary>
            处理状态
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XElementSerializableAttribute">
            <summary>
            对象是否按照字段进行XElement序列化的
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlObjectMapping">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMapping.GetMappingInfoByObject``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMapping.GetMappingInfo``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMapping.GetMappingInfo(System.Type)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMapping.InnerGetMappingInfo(System.Type)">
            <summary>
            
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.XmlObjectMappingAttribute">
            <summary>
            Xml节点(属性)和对象属性之间的映射
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMappingAttribute.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMappingAttribute.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="nodeName"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMappingAttribute.#ctor(System.String,MCS.Library.Core.XmlNodeMappingType)">
            <summary>
            
            </summary>
            <param name="nodeName"></param>
            <param name="mappingType"></param>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectMappingAttribute.NodeName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectMappingAttribute.MappingType">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Core.NoXmlObjectMappingAttribute">
            <summary>
            进行Mapping时忽略的属性
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlNodeMappingType">
            <summary>
            属性的映射方式，节点或属性
            </summary>
        </member>
        <member name="F:MCS.Library.Core.XmlNodeMappingType.Attribute">
            <summary>
            
            </summary>
        </member>
        <member name="F:MCS.Library.Core.XmlNodeMappingType.Entity">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlObjectMappingItem">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMappingItem.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMappingItem.#ctor(MCS.Library.Core.XmlObjectMappingAttribute)">
            <summary>
            
            </summary>
            <param name="attr"></param>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectMappingItem.PropertyName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectMappingItem.SubClassPropertyName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectMappingItem.NodeName">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectMappingItem.SubClassTypeDescription">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectMappingItem.MemberInfo">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectMappingItem.MappingType">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlObjectMappingItemCollection">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMappingItemCollection.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectMappingItemCollection.GetKeyForItem(MCS.Library.Core.XmlObjectMappingItem)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectMappingItemCollection.RootName">
            <summary>
            表名
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlObjectSubClassMappingAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectSubClassMappingAttribute.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectSubClassMappingAttribute.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="subPropertyName"></param>
            <param name="nodeName"></param>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectSubClassMappingAttribute.SubPropertyName">
            <summary>
            源对象的属性名称
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlObjectSubClassTypeAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectSubClassTypeAttribute.#ctor(System.Type)">
            <summary>
            构造方法，通过类型信息构造
            </summary>
            <param name="type">类型信息</param>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectSubClassTypeAttribute.#ctor(System.String)">
            <summary>
            构造方法，通过类型描述构造
            </summary>
            <param name="typeDesp">类型描述</param>
        </member>
        <member name="M:MCS.Library.Core.XmlObjectSubClassTypeAttribute.ToString">
            <summary>
            输出类型描述
            </summary>
            <returns>类型描述</returns>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectSubClassTypeAttribute.Type">
            <summary>
            类型信息
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlObjectSubClassTypeAttribute.TypeDescription">
            <summary>
            类型描述
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlRootMappingAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Core.XmlRootMappingAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="rootName">根节点名</param>
        </member>
        <member name="M:MCS.Library.Core.XmlRootMappingAttribute.#ctor(System.String,System.Boolean)">
            <summary>
            构造方法
            </summary>
            <param name="rootName">根节点名</param>
            <param name="onlyMapMarkedProperties">仅映射标记的属性</param>
        </member>
        <member name="P:MCS.Library.Core.XmlRootMappingAttribute.RootName">
            <summary>
            根节点名
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlRootMappingAttribute.OnlyMapMarkedProperties">
            <summary>
            仅映射标记的属性
            </summary>
        </member>
        <member name="T:MCS.Library.Core.FieldCanXElementSerializeHandler">
            <summary>
            决定属性是否可以序列化的的委托定义
            </summary>
            <param name="efi"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.XmlSerializeContext">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlSerializeContext.CurrentID">
            <summary>
            当前对象ID
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlSerializeContext.ObjectContext">
            <summary>
            实例上下文
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlSerializeContext.TypeContext">
            <summary>
            类型上下文
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlListDeserializeItem">
            <summary>
            IXmlSerilizableList类型的列表的操作项
            </summary>
        </member>
        <member name="T:MCS.Library.Core.XmlDeserializeContext">
            <summary>
            
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlDeserializeContext.ObjectContext">
            <summary>
            实例上下文
            </summary>
        </member>
        <member name="P:MCS.Library.Core.XmlDeserializeContext.TypeContext">
            <summary>
            类型上下文
            </summary>
        </member>
        <member name="T:MCS.Library.Core.IXmlDeserialize">
            <summary>
            Xml反序列化的相关接口
            </summary>
        </member>
        <member name="M:MCS.Library.Core.IXmlDeserialize.AfterDeserialize(MCS.Library.Core.XmlDeserializeContext)">
            <summary>
            反序列化完成
            </summary>
            <param name="context">上下文对象，暂时内部使用</param>
        </member>
        <member name="T:MCS.Library.Data.CommandBase">
            <summary>
            实现ICommand接口的虚基类。为Command提供了基础的数据结构
            </summary>
        </member>
        <member name="T:MCS.Library.Data.ICommand">
            <summary>
            描述命令的接口
            </summary>
        </member>
        <member name="M:MCS.Library.Data.ICommand.Execute(System.String)">
            <summary>
            执行命令
            </summary>
            <param name="argument"></param>
        </member>
        <member name="P:MCS.Library.Data.ICommand.Name">
            <summary>
            命令名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.ICommand.HelperString">
            <summary>
            命令的描述
            </summary>
        </member>
        <member name="M:MCS.Library.Data.CommandBase.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:MCS.Library.Data.CommandBase.Execute(System.String)">
            <summary>
            执行命令
            </summary>
            <param name="argument"></param>
        </member>
        <member name="M:MCS.Library.Data.CommandBase.ToString">
            <summary>
            转换成String
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Data.CommandBase.Name">
            <summary>
            命令的名称
            </summary>
        </member>
        <member name="P:MCS.Library.Data.CommandBase.HelperString">
            <summary>
            帮助信息
            </summary>
        </member>
        <member name="T:MCS.Library.Data.CommandHelper">
            <summary>
            操作ICommand对象的相关类别
            </summary>
        </member>
        <member name="M:MCS.Library.Data.CommandHelper.RegisterCommand(MCS.Library.Data.ICommand)">
            <summary>
            在全局字典中注册一个Command
            </summary>
            <param name="command"></param>
        </member>
        <member name="M:MCS.Library.Data.CommandHelper.GetCommand(System.String)">
            <summary>
            从字典中获取一个Command
            </summary>
            <param name="commandName">命令的名称</param>
            <returns>得到命令</returns>
        </member>
        <member name="M:MCS.Library.Data.CommandHelper.GetCommandList">
            <summary>
            得到按照名称排序后的命令列表
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Globalization.DefaultTranslator">
            <summary>
            默认的翻译器
            </summary>
        </member>
        <member name="M:MCS.Library.Globalization.DefaultTranslator.Translate(System.String,System.Globalization.CultureInfo,System.String,System.Globalization.CultureInfo,System.Object[])">
            <summary>
            直接翻译，不做转换
            </summary>
            <param name="category"></param>
            <param name="sourceCulture"></param>
            <param name="sourceText"></param>
            <param name="targetCulture"></param>
            <param name="objParams"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Globalization.Translator">
            <summary>
            翻译器
            </summary>
        </member>
        <member name="M:MCS.Library.Globalization.Translator.Translate(System.String,System.Globalization.CultureInfo,System.String,System.Globalization.CultureInfo,System.Object[])">
            <summary>
            翻译
            </summary>
            <param name="category"></param>
            <param name="sourceCulture"></param>
            <param name="sourceText"></param>
            <param name="targetCulture"></param>
            <param name="objParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Globalization.Translator.Translate(System.String,System.String,System.Globalization.CultureInfo,System.Object[])">
            <summary>
            翻译
            </summary>
            <param name="category"></param>
            <param name="sourceText"></param>
            <param name="targetCulture"></param>
            <param name="objParams"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Globalization.Translator.Translate(System.String,System.String,System.Object[])">
            <summary>
            翻译
            </summary>
            <param name="category"></param>
            <param name="sourceText"></param>
            <param name="objParams"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Globalization.TranslatorConfigSettings">
            <summary>
            翻译器的配置节
            </summary>
        </member>
        <member name="M:MCS.Library.Globalization.TranslatorConfigSettings.GetConfig">
            <summary>
            得到配置节
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Globalization.TranslatorConfigSettings.DefaultCulture">
            <summary>
            缺省的文种
            </summary>
        </member>
        <member name="P:MCS.Library.Globalization.TranslatorConfigSettings.DefaultCultureString">
            <summary>
            默认的Culture
            </summary>
        </member>
        <member name="P:MCS.Library.Globalization.TranslatorConfigSettings.Translator">
            <summary>
            翻译器
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.TokenFunction">
            <summary>
            抽象基类，各种格式化函数
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.TokenFunction.#ctor(System.String)">
            <summary>
            Initializes an instance of a TokenFunction with a start delimiter and the default end delimiter.
            </summary>
            <param name="tokenStartDelimiter">Start delimiter.</param>
        </member>
        <member name="M:MCS.Library.Logging.TokenFunction.#ctor(System.String,System.String)">
            <summary>
            Initializes an instance of a TokenFunction with a start and end delimiter.
            </summary>
            <param name="tokenStartDelimiter">Start delimiter.</param>
            <param name="tokenEndDelimiter">End delimiter.</param>
        </member>
        <member name="M:MCS.Library.Logging.TokenFunction.Format(System.Text.StringBuilder,MCS.Library.Logging.LogEntity)">
            <summary>
            Searches for token functions in the message and replace all with formatted values.
            </summary>
            <param name="messageBuilder">Message template containing tokens.</param>
            <param name="log">Log entry containing properties to format.</param>
        </member>
        <member name="M:MCS.Library.Logging.TokenFunction.FormatToken(System.String,MCS.Library.Logging.LogEntity)">
            <summary>
            Abstract method to process the token value between the start and end delimiter.
            </summary>
            <param name="tokenTemplate">Token value between the start and end delimiters.</param>
            <param name="log">Log entry to process.</param>
            <returns>Formatted value to replace the token.</returns>
        </member>
        <member name="M:MCS.Library.Logging.TokenFunction.GetInnerTemplate(System.Int32,System.String)">
            <summary>
            Returns the template in between the paratheses for a token function.
            Expecting tokens in this format: {keyvalue(myKey1)}.
            </summary>
            <param name="startPos">Start index to search for the next token function.</param>
            <param name="message">Message template containing tokens.</param>
            <returns>Inner template of the function.</returns>
        </member>
        <member name="M:MCS.Library.Logging.TimeStampToken.#ctor">
            <summary>
            Initializes a new instance of a <see cref="T:MCS.Library.Logging.TimeStampToken"/>.
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.TimeStampToken.FormatToken(System.String,MCS.Library.Logging.LogEntity)">
            <summary>
            Formats the timestamp property with the specified date time format string.
            </summary>
            <param name="tokenTemplate">Date time format string.</param>
            <param name="log">Log entry containing the timestamp.</param>
            <returns>Returns the formatted time stamp.</returns>
        </member>
        <member name="M:MCS.Library.Logging.DictionaryToken.#ctor">
            <summary>
            Initializes a new instance of a <see cref="T:MCS.Library.Logging.DictionaryToken"/>.
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.DictionaryToken.FormatToken(System.String,MCS.Library.Logging.LogEntity)">
            <summary>
            Iterates through each entry in the dictionary and display the key and/or value.
            </summary>
            <param name="tokenTemplate">Template to repeat for each key/value pair.</param>
            <param name="log">Log entry containing the extended properties dictionary.</param>
            <returns>Repeated template for each key/value pair.</returns>
        </member>
        <member name="M:MCS.Library.Logging.ReflectedPropertyToken.#ctor">
            <summary>
            Constructor that initializes the token with the token name
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.ReflectedPropertyToken.FormatToken(System.String,MCS.Library.Logging.LogEntity)">
            <summary>
            Searches for the reflected property and returns its value as a string
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.KeyValueToken.#ctor">
            <summary>
            Initializes a new instance of a <see cref="T:MCS.Library.Logging.TimeStampToken"/>.
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.KeyValueToken.FormatToken(System.String,MCS.Library.Logging.LogEntity)">
            <summary>
            Gets the value of a property from the log entry.
            </summary>
            <param name="tokenTemplate">Dictionary key name.</param>
            <param name="log">Log entry containing with extended properties dictionary values.</param>
            <returns>The value of the key from the extended properties dictionary, or <see langword="null"/> 
            (Nothing in Visual Basic) if there is no entry with that key.</returns>
        </member>
        <member name="T:MCS.Library.Logging.LogException">
            <summary>
            日志异常类
            </summary>
            <remarks>
            日志系统自定义异常类型
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogException.#ctor">
            <summary>
            缺省构造函数
            </summary>
            <remarks>
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" 
            lang="cs" region="Process Log" title="写日志的异常处理"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogException.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="message">异常消息</param>
            <remarks>
            根据异常消息，生成日志异常类
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogException.#ctor(System.String,System.Exception)">
            <summary>
            重载的构造函数
            </summary>
            <param name="message">异常消息</param>
            <param name="exception">原始异常对象</param>
            <remarks>
            将原始异常，转义成LogException
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" 
            lang="cs" region="Process Log" title="写日志的异常处理"></code>
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.LogPriority">
            <summary>
            日志记录优先级枚举
            </summary>
            <remarks>
            共分五级优先级
            </remarks>
        </member>
        <member name="F:MCS.Library.Logging.LogPriority.Lowest">
            <summary>
            最低优先级
            </summary>
        </member>
        <member name="F:MCS.Library.Logging.LogPriority.BelowNormal">
            <summary>
            低优先级
            </summary>
        </member>
        <member name="F:MCS.Library.Logging.LogPriority.Normal">
            <summary>
            普通
            </summary>
        </member>
        <member name="F:MCS.Library.Logging.LogPriority.AboveNormal">
            <summary>
            高优先级
            </summary>
        </member>
        <member name="F:MCS.Library.Logging.LogPriority.Highest">
            <summary>
            最高优先级
            </summary>
        </member>
        <member name="T:MCS.Library.Properties.CompressionRes">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.CompressionRes.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.CompressionRes.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.CompressionRes.InvalidCRC">
            <summary>
              Looks up a localized string similar to CRC校验失败.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.CompressionRes.InvalidFileDir">
            <summary>
              Looks up a localized string similar to 非法的压缩文件目录区.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.CompressionRes.InvalidFileEnding">
            <summary>
              Looks up a localized string similar to 非法的压缩文件目录结束标志.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.CompressionRes.InvalidFileHeader">
            <summary>
              Looks up a localized string similar to 非法的压缩文件头结构.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.CompressionRes.InvalidMethod">
            <summary>
              Looks up a localized string similar to 非法的压缩算法编号.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.CompressionRes.InvalidSFXFile">
            <summary>
              Looks up a localized string similar to 非法的SFX文件.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.CompressionRes.InvalidStream">
            <summary>
              Looks up a localized string similar to 存在非法的文件流.
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LogFormatter">
            <summary>
            抽象基类，实现ILogFormatter接口
            </summary>
            <remarks>
            所有LogFormatter的基类，
            派生时，为使定制的Formatter支持可配置，必须在该派生类中实现参数为LogConfigurationElement对象的构造函数
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.ILogFormatter">
            <summary>
            接口，格式化日志记录
            </summary>
            <remarks>
            定义将日志记录LogEntity对象格式化成字符串的格式化器，通过实现该接口来实现定制的格式化器，如：文本、XML等
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.ILogFormatter.Format(MCS.Library.Logging.LogEntity)">
            <summary>
            接口方法，格式化LogEntity对象成一个字符串
            </summary>
            <param name="log">LogEntity对象</param>
            <returns>格式化成的字符串</returns>
        </member>
        <member name="P:MCS.Library.Logging.ILogFormatter.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.LogFormatter.#ctor">
            <summary>
             缺省构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.LogFormatter.#ctor(System.String)">
            <summary>
            构造函数，根据Name创建LogFormatter对象
            </summary>
            <param name="formattername">Formatter的名称</param>
            <remarks>
            formattername参数不能为空，否则抛出异常
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogFormatter.Format(MCS.Library.Logging.LogEntity)">
            <summary>
            抽象方法，格式化LogEntity对象成一个字符串
            </summary>
            <param name="log">待格式化的LogEntity对象</param>
            <returns>格式化成的字符串</returns>
            <remarks>
            由派生类具体实现
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Formatters\TextFormatter.cs" 
            lang="cs" region="Format Implementation" title="文本格式化方法"></code>
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.LogFormatter.Name">
            <summary>
            Formatter的名称
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.TextLogFormatter">
            <summary>
            文本格式化器
            </summary>
            <remarks>
            LogFormatter的派生类，具体实现文本格式化
            </remarks>
        </member>
        <member name="F:MCS.Library.Logging.TextLogFormatter.template">
            <summary>
            格式模板
            </summary>
        </member>
        <member name="F:MCS.Library.Logging.TextLogFormatter.tokenFunctions">
            <summary>
            Array of token formatters.
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.TextLogFormatter.#ctor">
            <summary>
             缺省构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.TextLogFormatter.#ctor(MCS.Library.Logging.LoggerFormatterConfigurationElement)">
            <summary>
            构造函数
            </summary>
            <param name="element">配置节对象</param>
            <remarks>
            根据配置信息，创建TextLogFormatter对象
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\FormatterTest.cs"
            lang="cs" region="Get Formatter Test" tittle="获取Formatter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.TextLogFormatter.#ctor(System.String,System.String)">
            <summary>
             构造函数
            </summary>
            <param name="name">Formatter名称</param>
            <param name="template">格式模板</param>
            <remarks>
            如果template参数为空，则使用缺省格式模板
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\FormatterTest.cs"
            lang="cs" region="Get Formatter Test" tittle="获取Formatter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.TextLogFormatter.#ctor(System.String)">
            <summary>
            构造函数，使用缺省文本格式
            </summary>
            <param name="name">Formatter名称</param>
            <remarks>
            根据名称和缺省的格式模板创建TextLogFormatter对象
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\FormatterTest.cs"
            lang="cs" region="Get Formatter Test" tittle="获取Formatter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.TextLogFormatter.Format(MCS.Library.Logging.LogEntity)">
            <summary>
            文本格式化方法
            </summary>
            <param name="log">待格式化的LogEntity对象</param>
            <returns>格式化成的文本串</returns>
            <remarks>
            重载方法，实现文本格式化
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\FormatterTest.cs"
            lang="cs" region="Format Test" tittle="获取Formatter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.TextLogFormatter.Format(System.Text.StringBuilder,MCS.Library.Logging.LogEntity)">
            <summary>
            文本格式化
            </summary>
            <param name="templateBuilder">包含格式化模板串的StringBuilder</param>
            <param name="log">待格式化的LogEntity对象</param>
            <returns>格式化成的文本串</returns>
        </member>
        <member name="M:MCS.Library.Logging.TextLogFormatter.CreateTemplateBuilder">
            <summary>
            创建模板构建器
            </summary>
            <returns>包含格式化模板串的StringBuilder</returns>
        </member>
        <member name="P:MCS.Library.Logging.TextLogFormatter.Template">
            <summary>
            格式模板
            </summary>
            <remarks>
            要格式化成的模板字符串
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.XmlLogFormatter">
            <summary>
            Xml格式化器
            </summary>
            <remarks>
            LogFormatter的派生类，具体实现Xml格式化
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.XmlLogFormatter.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="name">Formatter名称</param>
            <remarks>
            根据名称，创建XmlLogFormatter对象
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.XmlLogFormatter.#ctor(MCS.Library.Logging.LoggerFormatterConfigurationElement)">
            <summary>
            构造函数
            </summary>
            <param name="element">配置节对象</param>
            <remarks>
            根据配置信息，创建TextLogFormatter对象
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\FormatterTest.cs"
            lang="cs" region="Get Formatter Test" tittle="获取Formatter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.XmlLogFormatter.Format(MCS.Library.Logging.LogEntity)">
            <summary>
            将LogEntity对象格式化成XML串
            </summary>
            <param name="log">LogEntity对象</param>
            <returns>格式化好的XML串</returns>
            <remarks>
            重载方法，实现格式化
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\FormatterTest.cs"
            lang="cs" region="Format Test" tittle="获取Formatter对象"></code>
            </remarks>
        </member>
        <member name="T:MCS.Library.Compression.GenericZip">
            <summary>
            压缩类
            </summary>
            <remarks>
            提供对二进制流、字符串、物理文件的压缩功能。
            </remarks>
        </member>
        <member name="M:MCS.Library.Compression.GenericZip.PreCheck(System.IO.Stream)">
            <summary>
            预检
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Compression.GenericZip.ZipStream(System.IO.Stream)">
            <summary>
            压缩二进制流
            </summary>
            <param name="stream">待压缩的二进制流</param>
            <returns>返回压缩后的二进制流</returns>
            <remarks>
            压缩二进制流：通过CreateTempFile()生成临时文件；生成待压缩的二进制流inStream；返回压缩后的二进制流outStream；
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\GenericZipTest.cs" region="StreamZipTest" lang="cs" title="压缩二进制流" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Compression.GenericZip.UnzipStream(System.IO.Stream)">
            <summary>
            解压缩二进制流
            </summary>
            <param name="stream">待解压缩的二进制流</param>
            <returns>返回解压缩后的二进制流</returns>
            <remarks>
            解压缩二进制流：待解压缩的二进制流outStream；生成解压后的二进制流unzipStream；
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\GenericZipTest.cs" region="StreamUnzipTest" lang="cs" title="解压缩二进制流" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Compression.GenericZip.ZipString(System.String)">
            <summary>
            压缩字符串
            </summary>
            <param name="uncompressedString">待压缩的字符串</param>
            <returns>返回压缩后的字符串</returns>
            <remarks>
            压缩字符串：压缩后的字符串 = GenericZip.ZipStream(待压缩的字符串)
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\GenericZipTest.cs" region="StringZipTest" lang="cs" title="压缩字符串" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Compression.GenericZip.ZipString(System.String,System.Text.Encoding)">
            <summary>
            压缩字符串
            </summary>
            <param name="unCompressedString">待压缩的字符串</param>
            <param name="defultEncode">字符串编码</param>
            <returns>返回压缩后的字符串</returns>
            <remarks>
            压缩字符串：压缩后的字符串 = GenericZip.ZipStream(待压缩的字符串)
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\GenericZipTest.cs" region="StringZipTest1" lang="cs" title="压缩字符串" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Compression.GenericZip.UnzipString(System.String)">
            <summary>
            解压缩字符串
            </summary>
            <param name="compressedString">待解压缩的字符串</param>
            <returns>返回解压缩后的字符串</returns>
            <remarks>
            解压缩字符串：解压缩后的字符串 = GenericZip.UnzipStream(待解压缩的字符串);
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\GenericZipTest.cs" region="StringUnzipTest" lang="cs" title="解压缩字符串" />
            </remarks> 
        </member>
        <member name="M:MCS.Library.Compression.GenericZip.UnzipString(System.String,System.Text.Encoding)">
            <summary>
            解压缩字符串
            </summary>
            <param name="compressedString">待解压缩的字符串</param>
            <param name="defultEncode">字符串编码</param>
            <returns>返回解压缩后的字符串</returns>
            <remarks>
            解压缩字符串：解压缩后的字符串 = GenericZip.UnzipStream(待解压缩的字符串);
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\GenericZipTest.cs" region="StringUnzipTest1" lang="cs" title="解压缩字符串" />
            </remarks> 
        </member>
        <member name="M:MCS.Library.Compression.GenericZip.ZipFiles(System.String[],System.String)">
            <summary>
            压缩文件
            </summary>
            <param name="sourceFile">待压缩的文件的绝对路径，包括文件名</param>
            <param name="destinationFileName">生成的压缩文件的绝对路径，包括文件名</param>
            <remarks>
            压缩文件：GenericZip.ZipFiles(待压缩的文件, 生成的压缩文件);
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\GenericZipTest.cs" region="FileZipTest" lang="cs" title="压缩文件" />
            </remarks> 
        </member>
        <member name="M:MCS.Library.Compression.GenericZip.UnzipFiles(System.String,System.String)">
            <summary>
            解压缩文件
            </summary>
            <param name="sourceFile">待解压缩的文件的绝对路径，包括文件名</param>
            <param name="destPath">压缩文件中被释放文件的存储目录(绝对路径)</param>
            <remarks>
            解压缩文件：GenericZip.UnzipFiles(待解压缩的文件, 被释放文件的存储目录);
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\GenericZipTest.cs" region="FileUnzipTest" lang="cs" title="解压缩文件" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Compression.CompressionError">
            <summary>
            错误类别
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.CompressionError.InvalidStream">
            <summary>
            非法Stream
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.CompressionError.InvalidFileHeader">
            <summary>
            非法的压缩文件头结构
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.CompressionError.InvalidFileDir">
            <summary>
            非法的压缩文件目录区
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.CompressionError.InvalidFileEnding">
            <summary>
            非法的压缩文件目录结束
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.CompressionError.InvalidSFXFile">
            <summary>
            非法的SFX文件
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.CompressionError.InvalidMethod">
            <summary>
            非法的压缩算法编号
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.CompressionError.InvalidCRC">
            <summary>
            CRC校验失败
            </summary>
        </member>
        <member name="T:MCS.Library.Compression.ZipConstants">
            <summary>
            ZipConstants中定义了压缩中使用到的常量。
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.ZipConstants.LOCHDR">
            <summary>
            Size of local entry header (excluding variable length fields at end)
            </summary>
        </member>
        <member name="F:MCS.Library.Compression.ZipConstants.ENDHDR">
            <summary>
            Size of end of central record (excluding variable fields)
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipConstants.ConvertToString(System.Byte[],System.Int32)">
            <summary>
            将byte数组的指定部分转换为字符串
            </summary>		
            <param name="data">
            需要转换的byte数组
            </param>
            <param name="length">
            需要转换部分的长度，从索引0处开始计算。
            </param>
            <returns>
            由data[0]..data[length - 1] 部分转换成的字符串
            </returns>
        </member>
        <member name="M:MCS.Library.Compression.ZipConstants.ConvertToArray(System.String)">
            <summary>
            将字符串转换成byte数组
            </summary>
            <param name="str">
            需要转换的字符串
            </param>
            <returns>转换后的byte数组</returns>
        </member>
        <member name="P:MCS.Library.Compression.ZipConstants.DefaultCodePage">
            <summary>
            默认代码页，为字符串转换提供默认编码。
            0是系统默认Ansi编码。如果希望与Zip压缩兼容请不要使用unicode编码。
            </summary>
        </member>
        <member name="T:MCS.Library.Compression.ZipEntry">
            <summary>
            压缩文件实体类
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipEntry.#ctor(System.String)">
            <summary>
            用文件名创建一个压缩文件实体对象
            </summary>
            <param name="name">
            文件名，可以包含路径。
            </param>
        </member>
        <member name="P:MCS.Library.Compression.ZipEntry.DosTime">
            <summary>
            表现为int型的操作时间
            </summary>
        </member>
        <member name="P:MCS.Library.Compression.ZipEntry.DateTime">
            <summary>
            设置实体的最后修改时间
            </summary>
        </member>
        <member name="P:MCS.Library.Compression.ZipEntry.Name">
            <summary>
            获取或设置实体名称，路径用“/”分割。
            </summary>
        </member>
        <member name="P:MCS.Library.Compression.ZipEntry.Size">
            <summary>
            获取或设置待压缩数据的大小。
            </summary>
            <exception cref="T:System.ArgumentException">
            如果大小不在0..0xffffffffL之间则抛出异常
            </exception>
            <returns>
            待压缩数据的大小 
            </returns>
        </member>
        <member name="P:MCS.Library.Compression.ZipEntry.CompressedSize">
            <summary>
            获取或设置压缩数据的大小。
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            如果大小不在0..0xffffffffL之间则抛出异常
            </exception>
            <returns>
            压缩数据的大小 
            </returns>
        </member>
        <member name="P:MCS.Library.Compression.ZipEntry.Crc">
            <summary>
            获取或设置待压缩文件的crc
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            如果Crc不在0..0xffffffffL范围内则抛出异常
            </exception>
            <returns>
            crc的值，如果crc未知则为-1。
            </returns>
        </member>
        <member name="P:MCS.Library.Compression.ZipEntry.Offset">
            <summary>
            获取或设置central header的偏移量
            </summary>
        </member>
        <member name="P:MCS.Library.Compression.ZipEntry.ExtraData">
            <summary>
            设置超大数据
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            超大数据长度超过0xffff字节则抛出异常
            </exception>
        </member>
        <member name="T:MCS.Library.Caching.ObjectCacheQueue">
            <summary>
            用于存放通用类型的CacheQueue
            </summary>
        </member>
        <member name="F:MCS.Library.Caching.ObjectCacheQueue.instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="P:MCS.Library.Caching.ObjectCacheQueue.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.SlidingTimeDependency">
            <summary>
            相对时间依赖，客户端代码在初始化此类的对象时，需要提供一个TimeSpan类型的过期时间段，
            当从初始化此类对象到经过此时间段时，认为与此依赖项相关的Cache项过期。
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.SlidingTimeDependency.#ctor(System.TimeSpan)">
            <summary>
            构造函数
            </summary>
            <param name="expirationTime">过期时间间隔</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\SlidingTimeDependencyTest.cs" region="ConstructorTest" lang="cs" title="构造函数" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Caching.SlidingTimeDependency.CacheItemExpirationTime">
            <summary>
            获取初始化时设定的过期时间间隔
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\SlidingTimeDependencyTest.cs" region="CacheItemExpirationTimeTest" lang="cs" title="初始化时设定的过期时间间隔" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Caching.SlidingTimeDependency.HasChanged">
            <summary>
            属性，获取本Dependency是否过期
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\SlidingTimeDependencyTest.cs" region="HasChangedTest" lang="cs" title="本Dependency是否过期" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Compression.ZipFile">
            <summary>
            文件压缩和解压
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipFile.#ctor(System.String,System.Byte,System.IO.FileMode)">
            <summary>
            按文件名创建压缩文件
            </summary>
            <param name="mode">系统打开文件的方式</param>
            <param name="method">压缩方式</param>
            <param name="name">压缩文件名</param>
        </member>
        <member name="M:MCS.Library.Compression.ZipFile.#ctor(System.String)">
            <summary>
            按文件名打开压缩文件.
            </summary>
            <param name="name">压缩文件名</param>
        </member>
        <member name="M:MCS.Library.Compression.ZipFile.Add(System.String)">
            <summary>
            压缩文件
            </summary>
            <param name="fileName">待压缩文件名</param>
        </member>
        <member name="M:MCS.Library.Compression.ZipFile.ExtractAll(System.String)">
            <summary>
            解压文件
            </summary>
            <param name="path">解压后的文件存放路径</param>
        </member>
        <member name="M:MCS.Library.Compression.ZipFile.CloseWriter">
            <summary>
            关闭压缩文件
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipFile.Close">
            <summary>
            关闭流
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipFile.Dispose">
            <summary>
            实现IDisposable接口
            </summary>
        </member>
        <member name="T:MCS.Library.Compression.ZipReader">
            <summary>
            通过读取文件流获取一个压缩文件实体对象，其中包含文件名，原文件大小，
            压缩后大小，CRC，etc等信息。
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipReader.#ctor(System.IO.Stream)">
            <summary>
            创建一个Zip的输入流，读取压缩文件。
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipReader.ReadLeByte">
            <summary>
            Read a byte from baseStream.
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipReader.ReadLeInt16">
            <summary>
            Read an unsigned short baseStream little endian byte order.
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipReader.ReadLeInt32">
            <summary>
            Read an int baseStream little endian byte order.
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipReader.WriteDecompressedFile(MCS.Library.Compression.ZipEntry,System.String)">
            <summary>
            Writes the uncompressed data into the filename in the 
            entry. It instantiates a memory stream which will serve 
            as a temp store and decompresses it using Gzip Stream or
            Deflate stream
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipReader.ExtractAll(System.Collections.Generic.List{MCS.Library.Compression.ZipEntry},System.String)">
            <summary>
            解压缩zipEntries中的文件，释放文件到目录destPath
            </summary>
            <param name="zipEntries">被压缩文件的文件信息</param>
            <param name="destPath">文件释放的存储目录</param>
        </member>
        <member name="M:MCS.Library.Compression.ZipReader.GetAllEntries">
            <summary>
            获得压缩文件中所有被压缩文件信息
            </summary>
            <returns>被压缩文件的文件信息</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\ZipReaderTest.cs" region="GetAllEntriesTest" lang="cs" title="获得压缩文件中所有被压缩文件信息" />  
            </remarks>
        </member>
        <member name="M:MCS.Library.Compression.ZipReader.Dispose">
            <summary>
            实现IDisposable接口
            </summary>
        </member>
        <member name="T:MCS.Library.Compression.ZipWriter">
            <summary>
            压缩文件
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipWriter.#ctor(System.IO.Stream)">
            <summary>
            用流创建压缩文件
            </summary>
            <param name="fileStream">
            用于写文件的流
            </param>
        </member>
        <member name="M:MCS.Library.Compression.ZipWriter.WriteLeInt16(System.Int16)">
            <summary>
            Write an int16 in little endian byte order.
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipWriter.WriteLeInt32(System.Int32)">
            <summary>
            Write an int32 in little endian byte order.
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipWriter.PutNextHeader(MCS.Library.Compression.ZipEntry)">
            <summary>
            Puts the next header in a predefined order
            </summary>
            <param name="entry">
            the ZipEntry which contains all the information
            </param>
        </member>
        <member name="M:MCS.Library.Compression.ZipWriter.WriteCompressedFile(System.IO.FileStream,MCS.Library.Compression.ZipEntry)">
            <summary>
            Writes the compressed data into the basestream 
            It instantiates a memory stream which will serve 
            as a temp store and then compresses it using Gzip Stream or
            Deflate stream and writes it to the base stream
            </summary>
        </member>
        <member name="M:MCS.Library.Compression.ZipWriter.Add(MCS.Library.Compression.ZipEntry)">
            <summary>
            增加文件ZipEntry并生成压缩文件
            </summary>
            <param name="entry">被压缩文件的文件信息</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\ZipWriterTest.cs" region="AddTest" lang="cs" title="增加文件ZipEntry并生成压缩文件" /> 
            </remarks>
        </member>
        <member name="M:MCS.Library.Compression.ZipWriter.Finish(System.Collections.Generic.List{MCS.Library.Compression.ZipEntry})">
            <summary>
            生成压缩文件结束标志
            </summary>
            <param name="entries">被压缩文件的文件信息</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Compression\ZipWriterTest.cs" region="FinishTest" lang="cs" title="生成压缩文件结束标志" /> 
            </remarks>
        </member>
        <member name="M:MCS.Library.Compression.ZipWriter.Dispose">
            <summary>
            实现IDisposable接口
            </summary>
        </member>
        <member name="P:MCS.Library.Compression.ZipWriter.Method">
            <summary>
            设置默认压缩方式
            </summary>
        </member>
        <member name="T:MCS.Library.Caching.AbsoluteTimeDependency">
            <summary>
            绝对时间依赖，客户端代码在初始化此类的对象时，
            需要提供一个本地的绝对时间作为过期截止时间，当当前时间超过预先设定的过期时间时，
            认为与此依赖项相关的Cache 项过期。
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.AbsoluteTimeDependency.#ctor(System.DateTime)">
            <summary>
            构造函数
            </summary>
            <param name="expiredTime">依赖项的过期时间</param>
            <remarks>构造函数</remarks>
        </member>
        <member name="P:MCS.Library.Caching.AbsoluteTimeDependency.ExpiredUtcTime">
            <summary>
            属性，获取过期时间的UTC时间值
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\AbsoluteTimeDependencyTest.cs" region="ExpiredUtcTimeTest" lang="cs" title="过期时间的UTC时间属性" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Caching.AbsoluteTimeDependency.ExpiredTime">
            <summary>
            属性，获取过期时间的本地时间值
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\AbsoluteTimeDependencyTest.cs" region="ExpiredTimeTest" lang="cs" title="过期时间的本地时间属性" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Caching.AbsoluteTimeDependency.HasChanged">
            <summary>
            属性，获取本Dependency是否过期
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Caching\AbsoluteTimeDependencyTest.cs" region="HasChangedTest" lang="cs" title="获取本Dependency是否过期" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Caching.DependencyChangedException">
            <summary>
            Dependency失效，导致Cache的Key访问失效所使用的异常
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.DependencyChangedException.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Caching.DependencyChangedException.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="message">异常信息</param>
        </member>
        <member name="M:MCS.Library.Caching.DependencyChangedException.#ctor(System.String,System.Exception)">
            <summary>
            构造方法
            </summary>
            <param name="message">异常信息</param>
            <param name="innerException">异常对象</param>
        </member>
        <member name="T:MCS.Library.Caching.CacheItem`2">
            <summary>
            组件内部泛型类,封装存储用户提供的Value值,以及相应的Dependency
            此类实现了IDisposable
            </summary>
            <typeparam name="TValue">值类型</typeparam>
            <typeparam name="TKey" >键类型</typeparam>
        </member>
        <member name="M:MCS.Library.Caching.CacheItem`2.#ctor(`0,`1,MCS.Library.Caching.CacheQueueBase)">
            <summary>
            构造函数，初始化没有Dependency的CacheItem
            </summary>
            <param name="tKey">初始化CacheItem的Key值</param>
            <param name="data">初始化CacheItem的Value值</param>
            <param name="cacheQueue">本CacheItem所属的CacheQueue的引用</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheItem`2.#ctor(`0,`1,MCS.Library.Caching.DependencyBase,MCS.Library.Caching.CacheQueueBase)">
            <summary>
            构造函数，初始化具有Dependency的CacheItem
            </summary>
            <param name="tKey">初始化CacheItem的键值</param>
            <param name="data">CacheItem的Value</param>
            <param name="dependencyBase">与此CacheItem相关的Dependency，用以判断过期</param>
            <param name="cacheQueue"> 本CacheItem所属的CacheQueue的引用</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheItem`2.GetKeyValue">
            <summary>
            得到CacheItem的KeyValue值
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Caching.CacheItem`2.SetValue(System.Object)">
            <summary>
            设置CacheItem的值
            </summary>
            <param name="value">设置值</param>
        </member>
        <member name="M:MCS.Library.Caching.CacheItem`2.ToCacheItemInfo">
            <summary>
            转换成Cache的信息项
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Caching.CacheItem`2.Value">
            <summary>
            属性,获取或设置CacheItem的value
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.ConfigurationBroker">
            <summary>
            <remarks>
            Broker类管理所有本地配置文件和映射配置文件。
            远程配置文件映射由ConfigurationFileMap和ConfigurationManager.OpenMappedMachineConfiguration处理.
            
            约束:
                <list type="bullet">
                    <item>
                    映射文件必须以ConfigurationSectionGroup或ConfigurationSection开始.
                    </item>
                    <item>
                    </item>
                </list>
            </remarks>
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.ConfigurationBroker.LocalItem">
            <summary>
            Private const
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.ConfigurationBroker.MachineConfigurationFile">
            <summary>
            Private static field
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.#cctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.CreateConfigurationCacheKey(System.String[])">
            <summary>
            生成configuration对象的缓存key值
            </summary>
            <param name="fileNames">文件列表</param>
            <returns>cache key</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.LoadFilesSetting">
            <summary>
            加载machine、local配置文件，meta配置文件，meta中的配置节，将其缓存并建立缓存失效依赖。
            查找并在 ConfigFilesSetting 类实例中记录machine、local、meta和global配置文件的地址和
            meta配置文件位置（枚举）
            </summary>
            <returns>ConfigFilesSetting 类实例</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetMetaSourceInstanceSection(MCS.Library.Configuration.ConfigurationBroker.ConfigFilesSetting)">
            <summary>
            获取meta配置中的 sourceMappings 节点
            </summary>
            <param name="fileSettings">ConfigFilesSetting 类实例</param>
            <returns>meta配置中的 sourceMappings 节点</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.LoadMetaSourceInstanceSectionFromLocal(MCS.Library.Configuration.ConfigurationBroker.ConfigFilesSetting)">
            <summary>
            从本地config文件中读取meta配置
            </summary>
            <param name="fileSettings">ConfigFilesSetting 类实例</param>
            <returns>MetaConfigurationSourceInstanceSection 实体</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.LoadMetaSourceInstanceSectionFromMetaFile(MCS.Library.Configuration.ConfigurationBroker.ConfigFilesSetting)">
            <summary>
            从单独的meta.config文件中读取meta配置
            </summary>
            <param name="fileSettings">ConfigFilesSetting 实体</param>
            <returns>MetaConfigurationSourceInstanceSection 实体</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetMetaFileSettings(MCS.Library.Configuration.ConfigurationBroker.ConfigFilesSetting)">
            <summary>
            获取meta文件的地址和位置
            </summary>
            <param name="fileSettings">ConfigFilesSetting 类实例</param>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetFinalConfiguration(MCS.Library.Configuration.ConfigurationBroker.ConfigFilesSetting,System.Configuration.Configuration@)">
            <summary>
            获取最终 local 和 global 合并后的 Configuration
            </summary>
            <param name="fileSettings">ConfigFilesSetting 类实例</param>
            <param name="globalConfig">返回全局配置的Config</param>
            <returns>local 和 global 合并后的 Configuration</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetLocalAppSettingsSection">
            <summary>
            获取本地config的AppSettings节点
            </summary>
            <returns>AppSettingsSection</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetSingleFileConfiguration(System.String,System.Boolean,System.String[])">
            <summary>
            取得单独config文件中的 Configuration
            </summary>
            <param name="fileName">文件地址</param>
            <param name="fileDependencies">缓存依赖文件</param>
            <param name="ignoreFileNotExist">是否忽略不存在的文件</param>
            <returns>Configuration对象</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetStandardWebConfiguration(System.String,System.Boolean,System.String[])">
            <summary>
            获取标准Web应用程序的配置信息，合并Web.config和global配置文件
            </summary>
            <param name="machineConfigPath">global配置文件地址</param>
            <param name="ignoreFileNotExist">是否忽略不存在的文件</param>
            <param name="fileDependencies">缓存依赖文件</param>
            <returns>Web.config和global配置文件合并后的Configuration对象</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetStandardWebAndGlobalConfiguration(System.String,System.Boolean,System.Configuration.Configuration@,System.String[])">
            <summary>
            获取标准Web应用程序的配置信息，合并Web.config和global配置文件
            </summary>
            <param name="machineConfigPath">global配置文件地址</param>
            <param name="ignoreFileNotExist">是否忽略不存在的文件</param>
            <param name="globalConfig">返回的全局配置</param>
            <param name="fileDependencies">缓存依赖文件</param>
            <returns>Web.config和global配置文件合并后的Configuration对象</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetGlobalConfiguration(System.String,System.Boolean,System.Func{System.Configuration.Configuration},System.String[])">
            <summary>
            得到全局配置文件的config对象
            </summary>
            <param name="configFile"></param>
            <param name="ignoreFileNotExist"></param>
            <param name="getConfig"></param>
            <param name="fileDependencies"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetStandardExeConfiguration(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            获取标准WinForm应用程序的配置信息，合并App.config和global配置文件
            </summary>
            <param name="machineConfigPath">global配置文件地址</param>
            <param name="localConfigPath">本地应用程序配置文件地址</param>
            <param name="ignoreFileNotExist">是否忽略不存在的文件</param>
            <param name="fileDependencies">缓存依赖文件</param>
            <returns>App.config和global配置文件合并后的Configuration对象</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetStandardExeAndGlobalConfiguration(System.String,System.String,System.Boolean,System.Configuration.Configuration@,System.String[])">
            <summary>
            获取标准WinForm应用程序的配置信息，合并App.config和global配置文件
            </summary>
            <param name="machineConfigPath">global配置文件地址</param>
            <param name="localConfigPath">本地应用程序配置文件地址</param>
            <param name="globalConfig">得到全局的配置</param>
            <param name="ignoreFileNotExist">是否忽略不存在的文件</param>
            <param name="fileDependencies">缓存依赖文件</param>
            <returns>App.config和global配置文件合并后的Configuration对象</returns>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.AddConfigurationToCache(System.String,System.Configuration.Configuration,System.Boolean,System.String[])">
            <summary>
            把Configuration对象放入缓存，建立时间和文件的混合依赖
            </summary>
            <param name="cacheKey">cache key</param>
            <param name="config">待缓存的Configuration对象</param>
            <param name="ignoreFileNotExist">是否忽略不存在的文件</param>
            <param name="files">缓存依赖的文件</param>
        </member>
        <member name="M:MCS.Library.Configuration.ConfigurationBroker.GetSection(System.String,System.Boolean)">
            <summary>
            按节点名称从配置信息中取得节点，并将节点信息缓存，建立文件依赖
            </summary>
            <param name="sectionName">节点名称</param>
            <param name="checkNullSection">如果返回null，是否抛出异常</param>
            <returns>配置节点</returns>
            <remarks>
            按名称获取配置节点信息。返回ConfigurationSection的派生类实体，实体类需由用户自定义。
            <code source="..\Framework\TestProjects\Deluxeworks.Library.WebTest\Configuration\Default.aspx.cs" region="Using Broker" lang="cs" title="使用配置管理" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Configuration.ConfigurationBroker.MetaConfigurationPosition">
            <summary>
            meta配置文件位置枚举
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.ConfigurationBroker.ConfigFilesSetting">
            <summary>
            内部类，用于存放、传递machine、local、meta、global配置文件的地址和
            meta文件位置（枚举） 
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.ConfigurationCache">
            <summary>
            用于存放 Configuration的Cache，这是合并过Configuration
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.ConfigurationCache.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.ConfigurationSectionCache">
            <summary>
            用于存放ConfigurationSection的Cache
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.ConfigurationSectionCache.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.ConfigurationFileCache">
            <summary>
            用于存放 Configuration 的 Cache，但是以文件为Key。适用于缓存单独的配置文件
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.ConfigurationFileCache.Instance">
            <summary>
            获取实例
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.MetaConfigurationSectionGroup">
             <summary>
             DeluxeWorks root meta configuration section group entity.
             
             <example>
              <mcs.library.metaConfig>
              <instance name="risk.qd">
                <configMappings>
                  <add name="db" value="db.xml"/>
                  <add name="authorization" value="authorization.xml"/>
                </configMappings>
              </instance>
              <instance name="risk.sh">
                <configMappings>
                  <add name="db" value="db2.xml"/>
                  <add name="authorization" value="authorization2.xml"/>
                  <add name="olap" value="olap.xml"/>
                </configMappings>
              </instance>
            </mcs.library.metaConfig>
             </example>
             </summary>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSectionGroup.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSectionGroup.SourceConfigurationMapping">
            <summary>
            源配置映射节
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.MetaConfigurationSourceInstanceElement">
            <summary>
            SourceMapping实例的配置元素.
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.MetaConfigurationSourceInstanceElement.NameItem">
            <summary>
            Private const
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceInstanceElement.GetMode">
            <summary>
            获取某个 Instance 的运行模式
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceInstanceElement.Name">
            <summary>
            站点的名称，不可以重复
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceInstanceElement.Path">
            <summary>
            全局配置文件的路径和文件名
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceInstanceElement.Mode">
            <summary>
            配置文件使用的访问类型，web访问方式mode可配置为：web，winForm访问方式mode可配置为：win。
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceInstanceElement.Mappings">
            <summary>
            当前实例的配置文件映射
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection">
            <summary>
            SourceMappings实例的配置元素集合
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection.Name">
            <summary>
            Public const
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection.FilterByInstanceMode(MCS.Library.Core.InstanceMode)">
            <summary>
            根据应用的类型过滤实例的配置
            </summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection.CreateNewElement">
            <summary>
            创建新的配置元素实例
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            由键值获取配置元素
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection.GetMatchedPath(System.String)">
            <summary>
            参数appPath为外面传入访问地址的绝对路径
            mode属性是用来区别web访问和winForm类型的，程序只对匹配mode下的配置型进行匹配
            以减少匹配的工作量，提高匹配的效率
            返回值是匹配成功的全局配置文件的路径和文件名称（即匹配项对应的path属性的值）
            如果未找到匹配的全局配置文件，则返回值为""
            </summary>
            <param name="appPath">(疑问地点？？？？？？不知道该参数是何用途)</param>
            <returns>匹配成功的全局配置文件的路径和文件名称（即匹配项对应的path属性的值）</returns>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection.Item(System.Int32)">
            <summary>
            由索引获取MetaConfigurationSourceInstanceElement
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceInstanceElementCollection.Item(System.String)">
            <summary>
            由名称获取MetaConfigurationSourceInstanceElement
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Configuration.MetaConfigurationSourceInstanceSection">
            <summary>
            SourceMappings配置节
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.MetaConfigurationSourceInstanceSection.Name">
            <summary>
            Public const
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceInstanceSection.Instances">
            <summary>
            所有实例的源映射元素集合
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.MetaConfigurationSourceMappingElement">
            <summary>
            Entity of applications in sourceMappings config 
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.MetaConfigurationSourceMappingElement.AppItem">
            <summary>
            Private const and Field
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceMappingElement.IsMatched(System.String)">
            <summary>
            对于web访问使用UriMatch();对于winForm访问使用FileMatch()
            </summary>
            <param name="appPath">外层传来的访问地址的全路径</param>
            <returns>bool</returns>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceMappingElement.FileMatch(System.String,System.String)">
            <summary>
            如果配置项app是相对路径，则在相对路径前补上当前应用域的路径，使其成为绝对路径
            最终使用绝对路径进行匹配
            </summary>
            <param name="filePath"></param>
            <param name="configPath"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceMappingElement.UriMatch(System.String,System.String)">
            <summary>
            如果配置项app是绝对路径，则要对访问协议、端口号、用户信息、主机名、主机名类型进行逐一匹配
            最终使用相对路径进行匹配。
            </summary>
            <param name="url"></param>
            <param name="configPath"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceMappingElement.Application">
            <summary>
            Logical name of mapping configuration file.
            配置的应用系统的路径，可以是绝对路径，也可以是相对路径。
            绝对路径需要指定正确的主机名、IP地址、段口号、用户信息等各个字段，匹配要求更严格。
            建议使用相对路径，配置要求更宽松
            如果是配置对所有应用都有效，可以配置app="/"，不过匹配规则是找到一个匹配的全局文件就不再进行后面的匹配，所以，这用配置要慎用。
            </summary>
        </member>
        <member name="T:MCS.Library.Configuration.MetaConfigurationSourceMappingElementCollection">
            <summary>
            每一个应用的配置文件映射集合
            </summary>
        </member>
        <member name="F:MCS.Library.Configuration.MetaConfigurationSourceMappingElementCollection.Name">
            <summary>
            Public const
            </summary>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceMappingElementCollection.CreateNewElement">
            <summary>
            创建配置元素实例
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceMappingElementCollection.GetElementKey(System.Configuration.ConfigurationElement)">
            <summary>
            获取配置元素的键值
            </summary>
            <param name="element">配置元素</param>
            <returns>键值</returns>
        </member>
        <member name="M:MCS.Library.Configuration.MetaConfigurationSourceMappingElementCollection.IsMatched(System.String)">
            <summary>
            如果该集合中有一个配置项app匹配成功，则返回true
            </summary>
            <param name="appPath"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceMappingElementCollection.Item(System.Int32)">
            <summary>
            由索引获取MetaConfigurationSourceMappingElement
            </summary>
        </member>
        <member name="P:MCS.Library.Configuration.MetaConfigurationSourceMappingElementCollection.Item(System.String)">
            <summary>
            由名称获取MetaConfigurationSourceMappingElement
            </summary>
        </member>
        <member name="T:MCS.Library.Core.EnumItemDescriptionAttribute">
            <summary>
            定义了枚举型中每个枚举项附加的属性，这个属性包含了对该枚举项的描述信息
            </summary>
            <remarks>
            这些描述信息包括：描述信息，ID号，短名。
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.#ctor">
            <summary>
            缺省的构造方法
            </summary>
            <remarks>
            缺省的构造方法
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\EnumItemDescriptionAttributeTest.cs" lang="cs" title="EnumItemDescriptionAttribute缺省的构造方法" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.#ctor(System.String)">
            <summary>
            带描述信息参数的构造函数
            </summary>
            <param name="desp">对枚举项的描述信息</param>
            <remarks>
            带描述信息参数的构造函数，同时设置枚举项附加属性的描述值等于desp。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\EnumItemDescriptionAttributeTest.cs" lang="cs" title="获得带描述信息参数的构造方法" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="desp"></param>
            <param name="category"></param>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.#ctor(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="desp">枚举项的描述信息</param>
            <param name="sort">枚举项的排序号</param>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.#ctor(System.String,System.Int32,System.String)">
            <summary>
            带描述信息和排序号参数的构造函数
            </summary>
            <param name="desp">枚举项的描述信息</param>
            <param name="sort">枚举项的排序号</param>
            <param name="category">多语言版的类别</param>
            <remarks>
            带描述信息和排序号参数的构造函数，同时设置枚举项附加属性的描述信息和排序号
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\EnumItemDescriptionAttributeTest.cs" lang="cs" title="带描述信息和序号参数的构造方法" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.#ctor(System.String,System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="desp"></param>
            <param name="sName"></param>
            <param name="sort"></param>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.#ctor(System.String,System.String,System.Int32,System.String)">
             <summary>
             带描述信息、短名和排序号参数的构造函数
             </summary>
             <param name="desp">枚举项的描述信息</param>
             <param name="sName">枚举项的短名</param>
             <param name="sort">枚举项的排序号</param>
             <param name="category">多语言版的类别</param>
             <remarks>带描述信息、短名和排序号参数的构造函数，同时设置枚举项附加属性的描述信息、短名和排序号
             <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\EnumItemDescriptionAttributeTest.cs" lang="cs" title="带描述信息、短名和排序号参数的构造方法" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.GetAttribute(System.Enum)">
            <summary>
            获得枚举项附加属性的描述信息属性
            </summary>
            <param name="enumItem">枚举项</param>
            <returns>描述信息属性，若该附加属性没有定义，则返回null</returns>
            <remarks>获得枚举项的附加属性，若该附加属性没有定义，则返回null
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\EnumItemDescriptionAttributeTest.cs" region = "GetAttributeTest" lang="cs" title="得到枚举项的描述信息属性" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.GetDescription(System.Enum)">
            <summary>
            获得枚举项的描述信息值，若没有定义该附加属性，则返回空串
            </summary>
            <param name="enumItem">枚举项</param>
            <returns>枚举项的描述信息值，若没有定义该枚举项附加属性，则返回空串</returns>
            <remarks>获得枚举项的描述信息值，若没有定义该枚举项附加属性，则返回空串
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\EnumItemDescriptionAttributeTest.cs" region = "GetDescriptionTest" lang="cs" title="得到枚举项的描述信息属性" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionAttribute.GetDescriptionList(System.Type)">
            <summary>
            获得已排序的枚举型的描述信息表
            </summary>
            <param name="enumType">枚举型</param>
            <returns>已排序的枚举型的描述信息表</returns>
            <remarks>得到已排序的枚举型的描述信息表，该表是根据SortID属性排序的。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\EnumItemDescriptionAttributeTest.cs" region = "GetEnumItemDescriptionListTest" lang="cs" title="获得已排序的枚举项的描述信息表" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescriptionAttribute.Description">
            <summary>
            枚举项的描述信息
            </summary>
            <remarks>该属性是可读写的
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescriptionAttribute.SortId">
            <summary>
            枚举项的排序号
            </summary>
            <remarks>该属性是可读写的
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescriptionAttribute.ShortName">
            <summary>
            枚举项的短名
            </summary>
            <remarks>该属性是可读写的
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescriptionAttribute.Category">
            <summary>
            翻译的类别
            </summary>
        </member>
        <member name="T:MCS.Library.Core.EnumItemDescription">
            <summary>
            枚举项描述类
            </summary>
            <remarks>用于描述枚举项的类，其中描述信息包括：Name，Description，ShortName，EnumValue，SortID。
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescription.CreateFromFieldInfo(System.Reflection.FieldInfo,System.Type)">
            <summary>
            通过一个字段属性创建一个对枚举项描述的实例
            </summary>
            <param name="fi">字段属性实例</param>
            <param name="enumType">枚举型</param>
            <returns>描述枚举项的实例</returns>
            <remarks>通过一个字段属性值创建一个枚举项描述的实例
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescription.Compare(MCS.Library.Core.EnumItemDescription,MCS.Library.Core.EnumItemDescription)">
            <summary>
            枚举项的比较方法
            </summary>
            <param name="x">需要比较的枚举项描述类的实例</param>
            <param name="y">需要比较的枚举项描述类的实例</param>
            <returns>比较结果</returns>
            <remarks>枚举项的比较方法,返回值是两个实例的排序号相减的结果
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescription.SortId">
            <summary>
            枚举项排序的ID
            </summary>
            <remarks>枚举项排序的ID，当对枚举项进行排序时，使用该属性进行排序，该属性是只读的
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescription.EnumValue">
            <summary>
            枚举项的值
            </summary>
            <remarks>该属性是只读的
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescription.ShortName">
            <summary>
            枚举项的短名
            </summary>
            <remarks>该属性是只读的
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescription.Description">
            <summary>
            枚举项的描述信息
            </summary>
            <remarks>该属性是只读的
            </remarks> 
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescription.Category">
            <summary>
            类别
            </summary>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescription.Name">
            <summary>
            枚举项的名字
            </summary>
            <remarks>
            该属性是只读的
            </remarks>
        </member>
        <member name="T:MCS.Library.Core.EnumItemDescriptionList">
            <summary>
            强类型的枚举项描述信息集合
            </summary>
            <remarks>
            强类型的枚举项描述信息集合,该信息是只读的
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.EnumItemDescriptionList.#ctor(System.Collections.Generic.IList{MCS.Library.Core.EnumItemDescription})">
            <summary>
            带枚举项描述信息类参数的构造函数
            </summary>
            <param name="list">枚举项描述信息类的实例</param>
            <remarks>带枚举项描述信息类参数的构造函数
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.EnumItemDescriptionList.Item(System.Int32)">
            <summary>
            获得指定位置元素的枚举项描述信息
            </summary>
            <param name="i">第i个元素</param>
            <returns>枚举项描述信息类的实例</returns>
            <remarks>该属性是只读的
            </remarks>
        </member>
        <member name="T:MCS.Library.Core.LruDictionary`2">
            <summary>
            运用最近最少用算法(Least Recently Used Algorithm)实现把最近最多使用的元素放在LruDictionary的前部，而最近最少使用的元素放在LruDictionary的后部
            </summary>
            <typeparam name="TKey">LruDictionary的键值Key的类型</typeparam>
            <typeparam name="TValue">LruDictionary的Value的类型</typeparam>
            <remarks>运用最近最少用算法(Least Recently Used Algorithm)实现LruDictionary，LruDictionary中最近最少使用的元素放在其后部，最近经常使用的元素放在其前部。
            LruDictionary中的每个元素由两部分组成—Key和Value，其中Key为LruDictionary的键值。
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.#ctor">
            <summary>
            LruDictionary没有参数的构造函数。
            </summary>
            <remarks>该构造函数中LruDictionary的最大长度是100。此构造方法适用于构造不指定最大长度的LruDictionary。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" region="LruDictionaryTest" lang="cs" title="获取一个无参数构造的LruDictionary"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>    
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.#ctor(System.Boolean)">
            <summary>
            构造方法
            </summary>
            <param name="threadSafe">是否是线程安全的</param>
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.#ctor(System.Int32)">
            <summary>
            定制最大长度为maxLength的LruDictionary。
            </summary>
            <param name="maxLruLength">需要设置的LruDictionary的最大长度。</param>
            <remarks>在默认情况下，LruDictionary的最大长度为100。此构造方法适用于构造指定最大长度的LruDictionary。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" region="LruDictionaryTest" lang="cs" title="获取最大长度为maxLength的LruDictionary"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.#ctor(System.Int32,System.Boolean)">
            <summary>
            构造方法
            </summary>
            <param name="maxLruLength">&gt;需要设置的LruDictionary的最大长度。</param>
            <param name="threadSafe">是否是线程安全的</param>
            <remarks>在默认情况下，LruDictionary的最大长度为100。此构造方法适用于构造指定最大长度的LruDictionary。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" region="LruDictionaryTest" lang="cs" title="获取最大长度为maxLength的LruDictionary"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.Add(`0,`1)">
             <summary>
             向LruDictionary中添加一个元素，用户需要把组成元素的Key和Value值传入。
             </summary>
             <param name="key">向LruDictionary中填入元素的Key值</param>
             <param name="data">向LruDictionary中填入元素的Value值</param>
             <remarks>向LruDictionary中添加一个元素时，该元素是由Key和Value值组成。按照LRU原则，经常使用的元素放在LruDictionary的前面。
             <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" region="AddTest" lang="cs" title="向LruDictionary中添加一个元素"/>
             <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.Remove(`0)">
            <summary>
            删除LruDictionary中键值为Key值的元素
            </summary>
            <param name="key">键值Key</param>
            <remarks>若LruDictionary中不包含键值为Key的元素，则系统自动的抛出异常。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" region="RemoveTest" lang="cs" title="从LruDictionary中删除键值为Key的元素"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.ContainsKey(`0)">
            <summary>
            判断LruDictionary中是否包含键值为Key值的元素
            </summary>
            <param name="key">键值Key</param>
            <returns>若LruDictionary中包含键值为key值的元素,则返回true，否则返回false</returns>
            <remarks>若返回值为true，由于该Key值的元素刚使用过，则把该元素放在LruDictionary的最前面。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" region="ContainsKeyTest" lang="cs" title="判断LruDictionary中是否包含键值为key的元素"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.TryGetValue(`0,`1@)">
            <summary>
            判断LruDictionary中是否包含键值为Key值的元素。若包含，则返回值是true，可以从data中取出该值，否则返回false。
            </summary>
            <param name="key">键值key</param>
            <param name="data">键值key的Value值</param>
            <returns>返回true或false</returns>
            <remarks>若返回值为true，由于该Key值的元素刚使用过，则把该元素放在LruDictionary的最前面。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" region="TryGetValueTest" lang="cs" title="试图从LruDictionary中取出键值为key的元素"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.Clear">
            <summary>
            清除LruDictionary内的所有值
            </summary>
            <remarks>此时LruDictionary中没有任何元素
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" region="ClearTest" lang="cs" title="清空LruDictionary中的所有元素"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.LruDictionary`2.GetEnumerator">
             <summary>
             获得LruDictionary中所有元素的枚举器
             </summary>
             <returns>LruDictionary中所有元素的枚举器</returns>
             <remarks>
             <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" region="GetEnumeratorTest" lang="cs" title="获得LruDictionary中所有元素的枚举器"/>
             <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="P:MCS.Library.Core.LruDictionary`2.IsThreadSafe">
            <summary>
            是否是线程安全的。访问的时候是否添加同步锁
            </summary>
        </member>
        <member name="P:MCS.Library.Core.LruDictionary`2.SyncRoot">
            <summary>
            同步访问LruDictionary的属性
            </summary>
            <remarks>同步访问LruDictionary的属性，该属性是只读的。</remarks>
        </member>
        <member name="P:MCS.Library.Core.LruDictionary`2.MaxLength">
            <summary>
            LruDictionary的最大长度
            </summary>
            <remarks>LruDictionary的最大长度，该属性是可读可写的。</remarks>
        </member>
        <member name="P:MCS.Library.Core.LruDictionary`2.Count">
            <summary>
            LruDictionary的当前长度
            </summary>
            <remarks>当前LruDictionary的长度，该属性是只读的。</remarks>
        </member>
        <member name="P:MCS.Library.Core.LruDictionary`2.Item(`0)">
            <summary>
            获取或设置LruDictionary中元素键值为key值的Value值
            </summary>
            <param name="key">要获得的元素的键值</param>
            <returns>LruDictionary中键值key的Value值</returns>
            <remarks>该属性是可读可写的。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\LruDictionaryTest.cs" lang="cs" title="读取或设置LruDictionary中键值为Key值的Value值"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="T:MCS.Library.Core.SerializationFormatterType">
            <summary>
            枚举类型，其包括Soap和Binary串行化编码方式
            </summary>
            <remarks>SerializationFormatterType枚举型包括Soap和Binary，Soap是SOAP消息格式编码，Binary是二进制消息格式编码。</remarks>
        </member>
        <member name="F:MCS.Library.Core.SerializationFormatterType.Soap">
            <summary>
            SOAP消息格式编码
            </summary>
        </member>
        <member name="F:MCS.Library.Core.SerializationFormatterType.Binary">
            <summary>
            二进制消息格式编码
            </summary>
        </member>
        <member name="T:MCS.Library.Core.SerializationHelper">
            <summary>
            帮助对象实现序列化和反序列化。
            </summary>
            <remarks>对象序列化是把对象序列化转化为string类型；对象反序列化是把对象从string类型反序列化转化为其源类型。
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.SerializationHelper.GetFormatter(MCS.Library.Core.SerializationFormatterType)">
            <summary>
            按照串行化的编码要求，生成对应的编码器。
            </summary>
            <param name="formatterType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.SerializationHelper.SerializeObjectToString(System.Object,MCS.Library.Core.SerializationFormatterType)">
            <summary>
            把对象序列化转换为字符串
            </summary>
            <param name="graph">可串行化对象实例</param>
            <param name="formatterType">消息格式编码类型（Soap或Binary型）</param>
            <returns>串行化转化结果</returns>
            <remarks>调用BinaryFormatter或SoapFormatter的Serialize方法实现主要转换过程。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\SerializationHelperTest.cs" region="TestSerializeAndDeserialize" lang="cs" title="把对象转换为字符串" />
            </remarks>    
        </member>
        <member name="M:MCS.Library.Core.SerializationHelper.DeserializeStringToObject``1(System.String,MCS.Library.Core.SerializationFormatterType)">
            <summary>
            把已序列化为字符串类型的对象反序列化为指定的类型
            </summary>
            <param name="serializedGraph">已序列化为字符串类型的对象</param>
            <param name="formatterType">消息格式编码类型（Soap或Binary型）</param>
            <typeparam name="T">对象转换后的类型</typeparam>
            <returns>串行化转化结果</returns>
            <remarks>调用BinaryFormatter或SoapFormatter的Deserialize方法实现主要转换过程。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\SerializationHelperTest.cs" region="TestSerializeAndDeserialize" lang="cs" title="把字符串对象转换为指定的类型" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.SerializationHelper.DeserializeStringToObject``1(System.String,MCS.Library.Core.SerializationFormatterType,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            把已序列化为字符串类型的对象反序列化为指定的类型
            </summary>
            <typeparam name="T">对象转换后的类型</typeparam>
            <param name="serializedGraph">已序列化为字符串类型的对象</param>
            <param name="formatterType">消息格式编码类型（Soap或Binary型）</param>
            <param name="binder">反序列化时的类型转换器</param>
            <returns>串行化转化结</returns>
            <remarks>调用BinaryFormatter或SoapFormatter的Deserialize方法实现主要转换过程。</remarks>
        </member>
        <member name="M:MCS.Library.Core.SerializationHelper.DeserializeStringToObject(System.String,MCS.Library.Core.SerializationFormatterType)">
            <summary>
            把已序列化为字符串类型的对象反序列化为指定的类型
            </summary>
            <param name="serializedGraph">已序列化为字符串类型的对象</param>
            <param name="formatterType">消息格式编码类型（Soap或Binary型）</param>
            <returns>串行化转化结果</returns>
            <remarks>调用BinaryFormatter或SoapFormatter的Deserialize方法实现主要转换过程。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\SerializationHelperTest.cs" region="TestSerializeAndDeserialize" lang="cs" title="把字符串对象转换为指定的类型" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.SerializationHelper.DeserializeStringToObject(System.String,MCS.Library.Core.SerializationFormatterType,System.Runtime.Serialization.SerializationBinder)">
            <summary>
            把已序列化为字符串类型的对象反序列化为指定的类型
            </summary>
            <param name="serializedGraph">已序列化为字符串类型的对象</param>
            <param name="formatterType">消息格式编码类型（Soap或Binary型）</param>
            <param name="binder"></param>
            <returns>串行化转化结果</returns>
            <remarks>调用BinaryFormatter或SoapFormatter的Deserialize方法实现主要转换过程。</remarks>
        </member>
        <member name="M:MCS.Library.Core.SerializationHelper.CloneObject(System.Object)">
            <summary>
            通过序列化复制对象
            </summary>
            <param name="graph"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.SerializationHelper.ToBytes(System.IO.Stream)">
            <summary>
            将一个Stream转换为Byte数组
            </summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.VersionStrategyBinder">
            <summary>
            与版本无关的Binder类，用于反序列化对象
            </summary>
        </member>
        <member name="F:MCS.Library.Core.VersionStrategyBinder.Instance">
            <summary>
            单一实例
            </summary>
        </member>
        <member name="M:MCS.Library.Core.VersionStrategyBinder.BindToType(System.String,System.String)">
            <summary>
            根据类型描述，经过转换（去处Version信息），返回类型对象
            </summary>
            <param name="assemblyName">AssemblyName</param>
            <param name="typeName">类型的描述</param>
            <returns>类型的实例</returns>
        </member>
        <member name="M:MCS.Library.Core.VersionStrategyBinder.AdjustTypeName(System.String,System.String)">
            <summary>
            调整类型名称，去掉类型中的版本依赖部分
            </summary>
            <param name="assemblyName"></param>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.UnknownTypeStrategyBinder">
            <summary>
            未知类型的反序列化器
            </summary>
        </member>
        <member name="F:MCS.Library.Core.UnknownTypeStrategyBinder.Instance">
            <summary>
            单一实例
            </summary>
        </member>
        <member name="M:MCS.Library.Core.UnknownTypeStrategyBinder.BindToType(System.String,System.String)">
            <summary>
            根据类型描述，经过转换（去处Version信息），返回类型对象
            </summary>
            <param name="assemblyName">AssemblyName</param>
            <param name="typeName">类型的描述</param>
            <returns>类型的实例</returns>
        </member>
        <member name="T:MCS.Library.Core.DataConverter">
            <summary>
            提供字符串与枚举类型的转换，TimeSpan与整形的转换。
            </summary>
            <remarks>提供字符串和枚举、TimeSpan的转换
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.DataConverter.ChangeType``2(``0)">
            <summary>
            类型转换，提供字符串与枚举型、TimeSpan与整型之间的转换
            </summary>
            <typeparam name="TSource">源数据的类型</typeparam>
            <typeparam name="TResult">目标数据的类型</typeparam>
            <param name="srcValue">源数据的值</param>
            <returns>类型转换结果</returns>
            <remarks>
            数据转换，主要调用系统Convert类的ChangeType方法，但是对于字符串与枚举，整型与TimeSpan类型之间的转换，进行了特殊处理。
            <seealso cref="T:MCS.Library.Core.XmlHelper"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.DataConverter.ChangeType``1(``0,System.Type)">
            <summary>
            字符串与枚举型、TimeSpan与整型之间转换的方法。
            </summary>
            <typeparam name="TSource">源数据类型</typeparam>
            <param name="srcValue">源数据的值</param>
            <param name="targetType">目标数据类型</param>
            <returns>类型转换后的结果</returns>
            <remarks>字符串与枚举型、TimeSpan与整型之间转换的方法。
            <seealso cref="T:MCS.Library.Core.XmlHelper"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.DataConverter.ChangeType(System.Type,System.Object,System.Type)">
            <summary>
            字符串与枚举型、TimeSpan与整型之间转换的方法。
            </summary>
            <param name="srcType">源数据类型</param>
            <param name="srcValue">源数据的值</param>
            <param name="targetType">目标数据类型</param>
            <returns>类型转换后的结果</returns>
            <remarks>字符串与枚举型、TimeSpan与整型之间转换的方法。
            <seealso cref="T:MCS.Library.Core.XmlHelper"/>
            </remarks>
        </member>
        <member name="T:MCS.Library.Expression.ExpTreeNode">
            <summary>
            二叉树的节点
            </summary>
            
        </member>
        <member name="M:MCS.Library.Expression.ExpTreeNode.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            重载实现二叉树的反序列化
            </summary>
            <param name="info">The object to be populated with serialization information.</param>
            <param name="context">The destination context of the serialization.</param>
            <remarks>
            二叉树的反序列化
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="Serialization" lang="cs" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ExpTreeNode.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            重载GetObjectData实现二叉树的序列化
            </summary>
            <param name="info">The object to be populated with serialization information. </param>
            <param name="context">The destination context of the serialization. </param>
            <remarks>对二叉树实现序列化
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="Serialization" lang="cs" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Expression.ExpTreeNode.Left">
            <summary>
            二叉树的左子树
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpTreeNode.Right">
            <summary>
            二叉树的右子树
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpTreeNode.Position">
            <summary>
            二叉树所在结点在表达式中的绝对位置
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpTreeNode.OperationID">
            <summary>
            运算符
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpTreeNode.Value">
            <summary>
            二叉树的值
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpTreeNode.Params">
            <summary>
            二叉树结点函数的参数
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ExpTreeNode.FunctionName">
            <summary>
            二叉树结点所代表的函数名
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ParseResult">
            <summary>
            表达式分析的结果
            </summary>
            <remarks>
            表达式分析后产生的结果
            </remarks>
        </member>
        <member name="P:MCS.Library.Expression.ParseResult.Tree">
            <summary>
            取解析出的二叉树
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParseResult.Identifiers">
            <summary>
            标识符
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ParamObject">
            <summary>
            用户自定义函数传入的参数
            </summary>
            <remarks>
            用户传入的参数对象
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="UserDefinedFucntions" lang="cs" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ParamObject.CheckParameterType``1">
            <summary>
            检查参数的类型
            </summary>
            <typeparam name="T">参数是否是指定类型，或者是它的派生类</typeparam>
            <remarks>
            检查参数类型是否为指定类型
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="UserDefinedFucntions" lang="cs" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Expression.ParamObject.Value">
            <summary>
            参数值
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParamObject.Position">
            <summary>
            参数在表达式中的位置
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParamObject.ParamIndex">
            <summary>
            是第几个参数
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ParamObjectCollection">
            <summary>
            参数类型的集合
            </summary>
            <remarks>
            用户自定义函数传入的参数集合
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="UserDefinedFucntions" lang="cs" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ParamObjectCollection.CheckParamsLength(System.Int32)">
            <summary>
            检查参数的个数
            </summary>
            <param name="nLimit">参数的最小个数</param>
        </member>
        <member name="P:MCS.Library.Expression.ParamObjectCollection.Item(System.Int32)">
            <summary>
            取参数集合中的参数
            </summary>
            <param name="i">第几个次序</param>
            <returns>返回参数，类型为ParamObject</returns>
        </member>
        <member name="T:MCS.Library.Expression.ParseIdentifier">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ParseIdentifier.ToString">
            <summary>
            输出内容
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Expression.ParseIdentifier.OperationID">
            <summary>
            标识符的类型
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParseIdentifier.Identifier">
            <summary>
            标识符的文本
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParseIdentifier.Position">
            <summary>
            标识符的类型
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParseIdentifier.PrevIdentifier">
            <summary>
            前一个标识符
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParseIdentifier.NextIdentifier">
            <summary>
            后一个标识符
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParseIdentifier.SubIdentifier">
            <summary>
            子标识符
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParseIdentifier.ParentIdentifier">
            <summary>
            父标识符
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ParsingException">
            <summary>
            为表达式识别错误封装的异常
            </summary>
            <remarks>
            封装的解析错误，在表达式解析过程中会报出异常，提示信息包括错误原因、出错位置
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="parse_error" lang="cs" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Expression.ParsingException.#ctor(MCS.Library.Expression.ParseError,System.Int32,System.String)">
            <summary>
            构造函数，根据错误类型、出错位置构造异常
            </summary>
            <param name="pe">错误类型</param>
            <param name="nPosition">出错位置</param>
            <param name="strMsg">错误信息</param>
        </member>
        <member name="M:MCS.Library.Expression.ParsingException.NewParsingException(MCS.Library.Expression.ParseError,System.Int32,System.String[])">
            <summary>
            产生一个新的表达式识别异常
            </summary>
            <param name="pe">错误原因</param>
            <param name="nPosition">出错位置</param>
            <param name="strParams">在错误信息中的参数</param>
            <returns>表达式识别异常对象</returns>
            <remarks>
            对表达式模块中产生的错误进行封装
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="parse_error" lang="cs" title="异常的封装" />
            </remarks>
        </member>
        <member name="P:MCS.Library.Expression.ParsingException.Reason">
            <summary>
            错误原因
            </summary>
        </member>
        <member name="P:MCS.Library.Expression.ParsingException.Position">
            <summary>
            出错位置
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.CalculateUserFunction">
            <summary>
            用户自定义函数的委托定义
            </summary>
            <param name="funcName">用户自定义函数名</param>
            <param name="arrParams">参数数组</param>
            <param name="callerContext">调用上下文</param>
            <returns>计算结果</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Expression\ExpressionParserTest.cs" region="UserDefinedFucntions" lang="cs" title="用户自定义函数的范例" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Expression.ParseError">
            <summary>
            错误类别
            </summary>
            <remarks>
            表达式解析的一些错误封装
            </remarks>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peNone">
            <summary>
            无异常
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peInvalidChar">
            <summary>
            非法字符
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peInvalidString">
            <summary>
            非法的字符串
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peInvalidOperator">
            <summary>
            非法操作符
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peTypeMismatch">
            <summary>
            类型不匹配
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peInvalidParam">
            <summary>
            非法的参数
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peInvalidUFValue">
            <summary>
            非法的用户自定义函数返回值
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peSyntaxError">
            <summary>
            语法错误
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peFloatOverflow">
            <summary>
            浮点运算溢出
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peCharExpected">
            <summary>
            需要某个字符
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peFuncError">
            <summary>
            函数错误
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peNeedOperand">
            <summary>
            需要操作数
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.peFormatError">
            <summary>
            格式错误
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ParseError.InvalidParameterType">
            <summary>
            参数类型错误
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.Operation_IDs">
            <summary>
            操作类型，作为语法分析二叉树节点中的运算符标识
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_NONE">
            <summary>
            无操作符
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_NOT">
            <summary>
            非
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_ADD">
            <summary>
            加
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_MINUS">
            <summary>
            减
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_MUL">
            <summary>
            乘
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_DIV">
            <summary>
            除
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_NEG">
            <summary>
            负号
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_EQUAL">
            <summary>
            等于
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_NOT_EQUAL">
            <summary>
            不等于
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_GREAT">
            <summary>
            大于
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_GREATEQUAL">
            <summary>
            大于等于
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_LESS">
            <summary>
            小于
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_LESSEQUAL">
            <summary>
            小于等于
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_LOGICAL_AND">
             <summary>
            逻辑与 
             </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_LOGICAL_OR">
            <summary>
            逻辑或
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_LBRACKET">
            <summary>
            左括号
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_RBRACKET">
            <summary>
            右括号
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_COMMA">
            <summary>
            逗号
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_USERDEFINE">
            <summary>
            自定义函数
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_STRING">
            <summary>
            字符串
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_NUMBER">
            <summary>
            数字
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_BOOLEAN">
            <summary>
            布尔型
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.Operation_IDs.OI_DATETIME">
            <summary>
            日期型
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpressionDataType">
            <summary>
            表达式中的数据类型
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ExpressionDataType.String">
            <summary>
            字符串
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ExpressionDataType.Number">
            <summary>
            数字
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ExpressionDataType.Boolean">
            <summary>
            布尔型
            </summary>
        </member>
        <member name="F:MCS.Library.Expression.ExpressionDataType.DateTime">
            <summary>
            日期型
            </summary>
        </member>
        <member name="T:MCS.Library.Expression.ExpTreeExecutor">
            <summary>
            语法分析Tree的计算类
            </summary>
        </member>
        <member name="M:MCS.Library.Expression.ExpTreeExecutor.GetValue(MCS.Library.Expression.ExpTreeNode,MCS.Library.Expression.CalculateUserFunction,System.Object,System.Boolean)">
            <summary>
            获取树结点值
            </summary>
            <param name="tree">二叉树节点</param>
            <param name="calcUDF">用户自定义函数的委托</param>
            <param name="callerContext">调用者上下文</param>
            <param name="optimize">最优化选项</param>
            <returns>树结点值</returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpTreeExecutor.GetValue(MCS.Library.Expression.ExpTreeNode,System.Object,System.Object,System.Boolean)">
            <summary>
            获取树结点值
            </summary>
            <param name="tree">二叉树节点</param>
            <param name="builtInFunctionsWrapper">包含内置函数的实现类</param>
            <param name="callerContext">调用者上下文</param>
            <param name="optimize">最优化选项</param>
            <returns>树结点值</returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpTreeExecutor.CalculateFunctionWithParameters(System.String,MCS.Library.Expression.ParamObjectCollection,MCS.Library.Expression.CalculateContext)">
            <summary>
            计算所有参数都已经准备好了的函数
            </summary>
            <param name="strFuncName"></param>
            <param name="arrParams"></param>
            <param name="calcContext"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpTreeExecutor.CalculateExpressionDictionary(System.String,MCS.Library.Expression.ParamObjectCollection,MCS.Library.Expression.CalculateContext)">
            <summary>
            计算表达式字典
            </summary>
            <param name="strFuncName"></param>
            <param name="arrParams"></param>
            <param name="calcContext"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Expression.ExpTreeExecutor.NToD(System.Object)">
            <summary>
            将数字转换为Decimal
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Logging.ILogFilter">
            <summary>
            接口，定义日志过滤器
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.ILogFilter.IsMatch(MCS.Library.Logging.LogEntity)">
            <summary>
            接口方法，实现日志过滤
            </summary>
            <param name="log">日志对象</param>
            <returns>布尔值，true：通过，false：不通过</returns>
        </member>
        <member name="P:MCS.Library.Logging.ILogFilter.Name">
            <summary>
            名称
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.PriorityLogFilter">
            <summary>
            优先级过滤器
            </summary>
            <remarks>
            LogFilter的派生类，实现根据优先级过滤日志记录
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.LogFilter">
            <summary>
            抽象类，实现ILogFilter接口
            </summary>
            <remarks>
            所有LogFilter的基类
            派生时，为使定制的Filter支持可配置，必须在该派生类中实现参数为LogConfigurationElement对象的构造函数
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogFilter.#ctor">
            <summary>
            缺省构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.LogFilter.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="filterName">Filter名称</param>
            <remarks>
            name参数不能为空，否则抛出异常
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogFilter.IsMatch(MCS.Library.Logging.LogEntity)">
            <summary>
            抽象方法，实现日志过滤
            </summary>
            <param name="log">日志对象</param>
            <returns>布尔值，true：通过，false：不通过</returns>
        </member>
        <member name="P:MCS.Library.Logging.LogFilter.Name">
            <summary>
            Filter名称
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.PriorityLogFilter.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="name">名称</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogFilterPipelineTest.cs"
            lang="cs" region="ILogFilter AddRemove Test" tittle="增删LogFillter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.PriorityLogFilter.#ctor(System.String,MCS.Library.Logging.LogPriority)">
            <summary>
            重载的构造函数
            </summary>
            <param name="name">名称</param>
            <param name="minPriority">优先级阀值</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogFilterPipelineTest.cs"
            lang="cs" region="ILogFilter AddRemove Test" tittle="增删LogFillter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.PriorityLogFilter.#ctor(MCS.Library.Logging.LoggerFilterConfigurationElement)">
            <summary>
            重载的构造函数，从配置文件中读取、构造
            </summary>
            <param name="element">配置对象</param>
            <remarks>
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Filters\LogFilterFactory.cs" 
            lang="cs" region="Get FilterPipeline" title="获取Filter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.PriorityLogFilter.IsMatch(MCS.Library.Logging.LogEntity)">
            <summary>
            覆写的方法，具体实现优先级过滤
            </summary>
            <param name="log">日志记录</param>
            <returns>布尔值，true：通过，false：不通过</returns>
            <remarks>
            只有优先级大于等于minPriority的日志记录才能通过
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.PriorityLogFilter.MinPriority">
            <summary>
            优先级阀值
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.FlatFileTraceListener">
            <summary>
            文本文件侦听器（Listerner）
            </summary>
            <remarks>
            FormattedTextWriterTraceListener派生类，增加标头和脚注
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.FormattedTextWriterTraceListener">
            <summary>
            可格式化的文本编写侦听器（Listerner）
            </summary>
            <remarks>
            FormattedTraceListenerWrapperBase的派生类，包装TextWriterTraceListener类
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.FormattedTraceListenerWrapperBase">
            <summary>
            抽象基类，Logging组件内置Listener的基类
            </summary>
            <remarks>
            FormattedTraceListenerBase的派生类，内部包装了TraceListener对象
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.FormattedTraceListenerBase">
            <summary>
            抽象基类，日志组件中所有Listener的基类
            </summary>
            <remarks>
            TraceListener的派生类，扩展Formatter属性
            派生时，为使定制的Listener支持可配置，必须在该派生类中实现参数为LogConfigurationElement对象的构造函数
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerBase.#ctor">
            <summary>
            缺省构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerBase.#ctor(MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="formatter">ILogFormatter对象</param>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerBase.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)">
            <summary>
            重载方法，写入数据
            </summary>
            <param name="eventCache">包含当前进程 ID、线程 ID 以及堆栈跟踪信息的 TraceEventCache 对象</param>
            <param name="source">标识输出时使用的名称，通常为生成跟踪事件的应用程序的名称</param>
            <param name="eventType">TraceEventType枚举值，指定引发日志记录的事件类型</param>
            <param name="id">事件的数值标识符</param>
            <param name="data">要记录的日志数据</param>
            <remarks>
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" 
            lang="cs" region="Process Log" title="写日志"></code>
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.FormattedTraceListenerBase.Formatter">
            <summary>
            日志文本格式化器（可选）
            </summary>
            <remarks>
            将LogEntity格式化成string。该属性可以不设定，此时不进行格式化
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.#ctor">
            <summary>
            缺省构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.#ctor(System.Diagnostics.TraceListener)">
            <summary>
            构造函数
            </summary>
            <param name="slaveListener">被包装的TraceListener对象</param>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.#ctor(System.Diagnostics.TraceListener,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造方法
            </summary>
            <param name="slaveListener">被包装的TraceListener对象</param>
            <param name="formater">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object[])">
            <summary>
            重载方法，写入数据
            </summary>
            <param name="eventCache">包含当前进程 ID、线程 ID 以及堆栈跟踪信息的 TraceEventCache 对象</param>
            <param name="source">标识输出时使用的名称，通常为生成跟踪事件的应用程序的名称</param>
            <param name="logEventType">TraceEventType枚举值，指定引发日志记录的事件类型</param>
            <param name="eventID">事件的数值标识符</param>
            <param name="data">要记录的日志数据</param>
            <remarks>
            调用包装的TraceListener类的对应TraceData方法
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" 
            lang="cs" region="Process Log" title="写日志"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)">
            <summary>
            重载方法，写入数据
            </summary>
            <param name="eventCache">包含当前进程 ID、线程 ID 以及堆栈跟踪信息的 TraceEventCache 对象</param>
            <param name="source">标识输出时使用的名称，通常为生成跟踪事件的应用程序的名称</param>
            <param name="logEventType">TraceEventType枚举值，指定引发日志记录的事件类型</param>
            <param name="eventID">事件的数值标识符</param>
            <param name="data">要记录的日志数据</param>
            <remarks>
            只有Formatter属性不为空时，才格式化
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" lang="cs" region="Process Log" title="写日志"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String)">
            <summary>
            重载方法，写入数据
            </summary>
            <param name="eventCache">包含当前进程 ID、线程 ID 以及堆栈跟踪信息的 TraceEventCache 对象</param>
            <param name="source">标识输出时使用的名称，通常为生成跟踪事件的应用程序的名称</param>
            <param name="logEventType">TraceEventType枚举值，指定引发日志记录的事件类型</param>
            <param name="id">事件的数值标识符</param>
            <param name="message">要记录的日志数据</param>
            <remarks>
            调用包装的TraceListener类的对应TraceEvent方法
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.TraceEvent(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,System.Object[])">
            <summary>
            重载方法，写入数据
            </summary>
            <param name="eventCache">包含当前进程 ID、线程 ID 以及堆栈跟踪信息的 TraceEventCache 对象</param>
            <param name="source">标识输出时使用的名称，通常为生成跟踪事件的应用程序的名称</param>
            <param name="logEventType">TraceEventType枚举值，指定引发日志记录的事件类型</param>
            <param name="id">事件的数值标识符</param>
            <param name="format">格式串</param>
            <param name="args">要记录的日志数据</param>
            <remarks>
            调用包装的TraceListener类的对应TraceEvent方法
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.Write(System.String)">
            <summary>
            重载方法，写入字符串
            </summary>
            <param name="message">待写入的字符串</param>
            <remarks>
            调用包装的TraceListener类的对应Write方法
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.WriteLine(System.String)">
            <summary>
            重载方法，写入一行字符串
            </summary>
            <param name="message">待写入的字符串</param>
            <remarks>
            调用包装的TraceListener类的对应WriteLine方法
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.Flush">
            <summary>
            刷新Listener的缓冲区
            </summary>
            <remarks>
            调用包装的TraceListener类的对应Flush方法
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" lang="cs" region="Process Log" title="写日志"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.Close">
            <summary>
            关闭Listener
            </summary>
            <remarks>
            调用包装的TraceListener类的对应Close方法
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" lang="cs" region="Process Log" title="写日志"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTraceListenerWrapperBase.Dispose(System.Boolean)">
            <summary>
            释放资源
            </summary>
            <param name="disposing">是否释放包装的资源</param>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.#ctor">
            <summary>
            缺省构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.#ctor(MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="formatter">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="filename">日志文件名</param>
            <remarks>
            将日志记录写入filename指定的文件中
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.#ctor(System.String,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="filename">日志文件名</param>
            <param name="formatter">ILogFormatter实例</param>
            <remarks>
            将日志记录，由formatter格式化后写入filename指定的文件中
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.#ctor(System.IO.Stream)">
            <summary>
            构造函数
            </summary>
            <param name="stream">Stream对象</param>
            <remarks>
            将日志记录，写入stream流中
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.#ctor(System.IO.Stream,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="stream">Stream对象</param>
            <param name="formatter">ILogFormatter实例</param>
            <remarks>
            将日志记录，由formatter格式化后写入stream流中
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.#ctor(System.IO.TextWriter)">
            <summary>
            构造函数
            </summary>
            <param name="writer">TextWriter对象</param>
            <remarks>
            将日志记录，写入writer中
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.#ctor(System.IO.TextWriter,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="writer">TextWriter对象</param>
            <param name="formatter">ILogFormatter实例</param>
            <remarks>
            将日志记录，由formatter格式化后写入writer中
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)">
            <summary>
            重载方法，写入数据
            </summary>
            <param name="eventCache">包含当前进程 ID、线程 ID 以及堆栈跟踪信息的 TraceEventCache 对象</param>
            <param name="source">标识输出时使用的名称，通常为生成跟踪事件的应用程序的名称</param>
            <param name="eventType">TraceEventType枚举值，指定引发日志记录的事件类型</param>
            <param name="id">事件的数值标识符</param>
            <param name="data">要记录的日志数据</param>
            <remarks>
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" 
            lang="cs" region="Process Log" title="写日志"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.GetSupportedAttributes">
             <summary>
            支持的属性
             </summary>
             <returns>属性数组</returns>
        </member>
        <member name="M:MCS.Library.Logging.FormattedTextWriterTraceListener.RootFileNameAndEnsureTargetFolderExists(System.String)">
            <summary>
            文件路径处理
            </summary>
            <param name="fileName">文件名</param>
            <returns>标准的完整文件路径</returns>
        </member>
        <member name="P:MCS.Library.Logging.FormattedTextWriterTraceListener.IsThreadSafe">
            <summary>
            是否线程安全，对TextWriterTraceListener为true
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor">
            <summary>
            缺省构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(MCS.Library.Logging.LoggerListenerConfigurationElement)">
            <summary>
            构造函数
            </summary>
            <param name="element">LogListenerElement对象</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Logging\ListenerTest.cs"
            lang="cs" region="FlatFileTraceListener Test" tittle="创建Listener对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="formatter">ILogFormatter实例</param>
            <remarks>
            用Formatter初始化一个实例对象
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.IO.FileStream,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="stream">FileStream对象</param>
            <param name="formatter">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.IO.FileStream)">
            <summary>
            构造函数
            </summary>
            <param name="stream">FileStream对象</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.IO.StreamWriter,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="writer">StreamWriter对象.</param>
            <param name="formatter">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.IO.StreamWriter)">
            <summary>
            构造函数
            </summary>
            <param name="writer">StreamWriter对象</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.IO.TextWriter,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="writer">TextWriter对象</param>
            <param name="formatter">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.String,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="fileName">日志文件名</param>
            <param name="formatter">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
            <param name="fileName">日志文件名</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.String,System.String,System.String,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="fileName">日志文件名</param>
            <param name="header">日志记录标头</param>
            <param name="footer">日志记录脚注</param>
            <param name="formatter">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.String,System.String,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="fileName">日志文件名</param>
            <param name="header">日志记录标头</param>
            <param name="footer">日志记录脚注</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.IO.FileStream,System.String,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="stream">FileStream对象</param>
            <param name="name">Listener的名称</param>
            <param name="formatter">ILogFormatter实例.</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.IO.FileStream,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="stream">FileStream对象</param>
            <param name="name">Listener的名称</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.IO.StreamWriter,System.String,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="writer">StreamWriter对象</param>
            <param name="name">Listener的名称</param>
            <param name="formatter">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.IO.StreamWriter,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="writer">StreamWriter对象</param>
            <param name="name">Listener的名称</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.String,System.String,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="fileName">日志文件名</param>
            <param name="name">Listener的名称</param>
            <param name="formatter">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.#ctor(System.String,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="fileName">日志文件名</param>
            <param name="name">Listener的名称</param>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)">
            <summary>
            重载方法，写入文件
            </summary>
            <param name="eventCache">包含当前进程 ID、线程 ID 以及堆栈跟踪信息的 TraceEventCache 对象</param>
            <param name="source">标识输出时使用的名称，通常为生成跟踪事件的应用程序的名称</param>
            <param name="eventType">TraceEventType枚举值，指定引发日志记录的事件类型</param>
            <param name="id">事件的数值标识符</param>
            <param name="data">要记录的日志数据</param>
            <remarks>
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" 
            lang="cs" region="Process Log" title="写日志"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FlatFileTraceListener.GetSupportedAttributes">
            <summary>
            FlatFileTraceListener支持的Attibutes
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.FlatFileTraceListener.Formatter">
            <summary>
            文本格式化器
            </summary>
            <remarks>
            该Listener下所配的格式化器
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.FormattedEventLogTraceListener">
            <summary>
            EventLog侦听器（Listerner）
            </summary>
            <remarks>
            FormattedTraceListenerWrapperBase派生类，将日志记入EventLog中
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedEventLogTraceListener.#ctor(MCS.Library.Logging.LoggerListenerConfigurationElement)">
            <summary>
            构造函数
            </summary>
            <param name="element">LogListenerElement对象</param>
            <remarks>
            根据配置信息创建FormattedEventLogTraceListener对象
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\ListenerTest.cs"
            lang="cs" region="EventLogTraceListener Test" tittle="创建Listener对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedEventLogTraceListener.#ctor">
            <summary>
            缺省构造函数
            </summary>
            <remarks>
            用EventLogTraceListener初始化一个实例对象
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedEventLogTraceListener.#ctor(MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="formater">ILogFormatter实例</param>
            <remarks>
            用EventLogTraceListener和Formatter初始化一个实例对象
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedEventLogTraceListener.#ctor(System.Diagnostics.EventLog)">
            <summary>
            构造函数
            </summary>
            <param name="eventLog">EventLog对象</param>
            <remarks>
            用EventLogTraceListener(EventLog)初始化一个实例对象
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedEventLogTraceListener.#ctor(System.Diagnostics.EventLog,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数
            </summary>
            <param name="eventLog">EventLog对象</param>
            <param name="formatter">ILogFormatter实例</param>
            <remarks>
            用EventLogTraceListener(EventLog)和Formatter初始化一个实例对象
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedEventLogTraceListener.#ctor(System.String,System.String,System.String,MCS.Library.Logging.ILogFormatter)">
            <summary>
            构造函数，用EventLogTraceListener(EventLog)和Formatter初始化一个实例对象
            </summary>
            <param name="source">EventLog中的事件来源</param>
            <param name="logName">EventLog中的日志名称</param>
            <param name="machineName">记录事件日志的机器名称</param>
            <param name="formatter">ILogFormatter实例</param>
        </member>
        <member name="M:MCS.Library.Logging.FormattedEventLogTraceListener.TraceData(System.Diagnostics.TraceEventCache,System.String,System.Diagnostics.TraceEventType,System.Int32,System.Object)">
            <summary>
            重载方法，写入文件
            </summary>
            <param name="eventCache">包含当前进程 ID、线程 ID 以及堆栈跟踪信息的 TraceEventCache 对象</param>
            <param name="source">标识输出时使用的名称，通常为生成跟踪事件的应用程序的名称</param>
            <param name="logEventType">TraceEventType枚举值，指定引发日志记录的事件类型</param>
            <param name="eventID">事件的数值标识符</param>
            <param name="data">要记录的日志数据</param>
            <remarks>
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" 
            lang="cs" region="Process Log" title="写日志"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.FormattedEventLogTraceListener.RegisterSourceToLogName(System.String,System.String)">
            <summary>
            注册日志来源和日志名称的映射关系
            </summary>
            <param name="source">来源</param>
            <param name="logName">日志名称</param>
        </member>
        <member name="P:MCS.Library.Logging.FormattedEventLogTraceListener.Formatter">
            <summary>
            文本格式化器
            </summary>
            <remarks>
            该Listener下所配的格式化器
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.FormattedEventLogTraceListener.IsThreadSafe">
            <summary>
            是否线程安全，对EventLogTraceListener为true
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LogEntity">
            <summary>
            日志记录
            </summary>
            <remarks>
            单条的日志记录类
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogEntity.#ctor(System.String)">
            <summary>
            构造函数，根据消息，创建日志记录对象
            </summary>
            <param name="message">日志记录消息</param>
            <remarks>
            message参数不能为空，否则抛异常
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogEntityTest.cs"
            lang="cs" region="Create LogEntity Test" tittle="根据消息创建日志记录对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogEntity.#ctor(System.Exception)">
            <summary>
            构造函数，根据异常创建日志记录对象
            </summary>
            <param name="ex">异常对象</param>
            <remarks>
            ex参数不能为空，否则抛异常
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogEntityTest.cs"
            lang="cs" region="Create LogEntity Test" tittle="根据异常对象创建日志记录对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogEntity.#ctor(System.String,System.String,System.Int32)">
            <summary>
            构造函数，根据参数构造LogEntity对象
            </summary>
            <param name="title">日志标题</param>
            <param name="message">日志消息</param>
            <param name="eventID">日志事件ID</param>
            <remarks>
            根据所传递的参数构造LogEntity对象，其他属性为缺省值
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogEntityTest.cs"
            lang="cs" region="Create LogEntity Test" tittle="根据参数构造LogEntity对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogEntity.#ctor(System.String,System.String,System.Int32,MCS.Library.Logging.LogPriority,System.Diagnostics.TraceEventType,System.String,System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            构造函数，根据参数构造LogEntity对象
            </summary>
            <param name="title">日志标题</param>
            <param name="message">日志消息</param>
            <param name="eventID">日志事件ID</param>
            <param name="priority">日志记录优先级</param>
            <param name="logEventType">日志事件类型</param>
            <param name="source">日志来源</param>
            <param name="stackTrace">调用栈</param>
            <param name="propterties">扩展信息</param>
            <remarks>
            根据所传递的参数构造LogEntity对象
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogEntityTest.cs"
            lang="cs" region="Create LogEntity Test" tittle="根据参数构造LogEntity对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogEntity.Clone">
            <summary>
            实现ICloneable接口
            </summary>
            <returns>
            克隆出的LogEntity对象
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogEntityTest.cs"
            lang="cs" region="LogEntityClone Test" tittle="克隆LogEntity对象"></code>
            </returns>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.EventID">
            <summary>
            日志事件ID
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.Title">
            <summary>
            日志标题
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.Message">
            <summary>
            日志消息
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.StackTrace">
            <summary>
            调用栈
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.Source">
            <summary>
            日志来源
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.TimeStamp">
            <summary>
            时间戳
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.MachineName">
            <summary>
            机器名
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.ActivityID">
            <summary>
            活动（操作）ID
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.Priority">
            <summary>
            日志记录优先级
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.LogEventType">
            <summary>
            日志事件类型
            </summary>
        </member>
        <member name="P:MCS.Library.Logging.LogEntity.ExtendedProperties">
            <summary>
            扩展信息
            </summary>
        </member>
        <member name="T:MCS.Library.Logging.LogFilterPipeline">
            <summary>
            实现ILogFilter的管道（Pipeline）
            </summary>
            <remarks>
            内置LogFilter集合对象
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogFilterPipeline.Add(MCS.Library.Logging.ILogFilter)">
            <summary>
            向Pipeline中添加ILogFilter对象
            </summary>
            <param name="filter">ILogFilter对象</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogFilterPipelineTest.cs"
            lang="cs" region="ILogFilter AddRemove Test" tittle="增删LogFillter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogFilterPipeline.Remove(MCS.Library.Logging.ILogFilter)">
            <summary>
            从Pipeline中移除ILogFilter实例
            </summary>
            <param name="filter">ILogFilter实例</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogFilterPipelineTest.cs"
            lang="cs" region="ILogFilter AddRemove Test" tittle="增删LogFillter对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LogFilterPipeline.IsMatch(MCS.Library.Logging.LogEntity)">
            <summary>
            实现日志过滤，判断是否通过LogFilterPipeline
            </summary>
            <param name="log">日志对象</param>
            <returns>布尔值，true：通过，false：不通过</returns>
            <remarks>
            Pipeline的Filter之间是“与”的关系，只有所有的Filter都通过，才算通过
            <code source="..\Framework\src\DeluxeWorks.Library\Logging\Logger.cs" 
            lang="cs" region="Process Log" tittle="写日志记录"></code>
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.LogFilterPipeline.Item(System.Int32)">
            <summary>
            根据索引返回单个的ILogFilter实例
            </summary>
            <param name="index">索引</param>
            <returns>单个的ILogFilter实例</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogFilterPipelineTest.cs"
            lang="cs" region="ILogFilter AddRemove Test" tittle="增删LogFillter对象"></code>
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.LogFilterPipeline.Length">
            <summary>
            Pipeline中ILogFilter实例的个数
            </summary>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LogFilterPipelineTest.cs"
            lang="cs" region="ILogFilter AddRemove Test" tittle="增删LogFillter对象"></code>
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.Logger">
            <summary>
            日志处理类
            </summary>
            <remarks>
            包含Filters、Listeners的日志处理类
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.Logger.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="M:MCS.Library.Logging.Logger.Write(MCS.Library.Logging.LogEntity)">
            <summary>
            写日志
            </summary>
            <param name="log">待写的日志记录</param>
            <remarks>
            写日志信息的方法
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LoggerTest.cs"
            lang="cs" region="Logger Write Test" tittle="写日志信息"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.Logger.Write(System.String,MCS.Library.Logging.LogPriority,System.Int32,System.Diagnostics.TraceEventType,System.String)">
            <summary>
            写日志
            </summary>
            <param name="message">日志消息</param>
            <param name="priority">日志优先级</param>
            <param name="eventId">日志事件ID</param>
            <param name="logEventType">日志事件类型</param>
            <param name="title">日志标题</param>
            <remarks>
            根据传递的参数，构建LogEntity对象，并写入媒介
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LoggerTest.cs"
            lang="cs" region="Logger Write Test" tittle="写日志信息"></code>
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.Logger.Name">
            <summary>
            Logger的名称
            </summary>
            <remarks>
            Logger的名称，一般从配置文件读取
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.Logger.EnableLog">
            <summary>
            表明Logger是否可用
            </summary>
            <remarks>
            设置该Logger是否可用的布尔值
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.Logger.Listeners">
            <summary>
            Listener集合
            </summary>
            <remarks>
            从配置文件中读取创建对象；如果没有，则返回初始List&lt;FormattedTraceListenerBase&gt;对象
            </remarks>
        </member>
        <member name="P:MCS.Library.Logging.Logger.FilterPipeline">
            <summary>
            Filter集合
            </summary>
            <remarks>
            从配置文件中读取、创建对象；如果没有，则返回初始LogFilterPipeline对象
            </remarks>
        </member>
        <member name="T:MCS.Library.Logging.LoggerFactory">
            <summary>
            Logger工厂类
            </summary>
            <remarks>
            用于创建Logger对象的工厂类
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LoggerFactory.Create(System.String)">
            <summary>
            根据Name, 从配置文件读取，并创建Logger对象
            </summary>
            <param name="name">Logger的名称</param>
            <returns>读取的Logger对象</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LoggerTest.cs"
            lang="cs" region="Create Logger Test" tittle="获取Logger对象"></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Logging.LoggerFactory.Create">
            <summary>
            创建Logger对象
            </summary>
            <returns>只带缺省值的Logger对象</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\\Logging\LoggerTest.cs"
            lang="cs" region="Create Logger Test" tittle="获取Logger对象"></code>
            </remarks>
        </member>
        <member name="T:MCS.Library.Properties.ExpressionParserRes">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.FunctionError">
            <summary>
              Looks up a localized string similar to 函数{0}错误，{1}.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.InvalidDateDiffType">
            <summary>
              Looks up a localized string similar to \&quot;{0}\&quot;不是DateDiff所支持的时间间隔类型.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.InvalidParameterType">
            <summary>
              Looks up a localized string similar to &quot;第{0}的参数类型错误，应该是{1}类型&quot;.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.InvalidParamsCount">
            <summary>
              Looks up a localized string similar to 参数个数应该不少于{0}个.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peCharExpected">
            <summary>
              Looks up a localized string similar to 应该有一个&quot;{0}&quot;.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peFloatOverflow">
            <summary>
              Looks up a localized string similar to 出现浮点运算越界或除零错误.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peFormatError">
            <summary>
              Looks up a localized string similar to 出现格式错误.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peFuncError">
            <summary>
              Looks up a localized string similar to 函数错误.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peInvalidChar">
            <summary>
              Looks up a localized string similar to 存在非法字符&quot;{0}&quot;.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peInvalidOperator">
            <summary>
              Looks up a localized string similar to 存在非法操作符&quot;{0}&quot;.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peInvalidParam">
            <summary>
              Looks up a localized string similar to 函数&quot;{0}&quot;应该有{1}个参数.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peInvalidString">
            <summary>
              Looks up a localized string similar to 存在非法字符串.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peInvalidUFValue">
            <summary>
              Looks up a localized string similar to 用户自定义函数返回值不能为空.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peNeedOperand">
            <summary>
              Looks up a localized string similar to 需要操作数.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peSyntaxError">
            <summary>
              Looks up a localized string similar to 存在语法错误.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.peTypeMismatch">
            <summary>
              Looks up a localized string similar to 类型不匹配.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ExpressionParserRes.position">
            <summary>
              Looks up a localized string similar to 在第{0}个字符附近.
            </summary>
        </member>
        <member name="T:MCS.Library.Properties.Configuration">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Configuration.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Configuration.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Configuration.RootConfigurationNode">
            <summary>
              Looks up a localized string similar to &lt;chinaCustoms.framework.deluxeWorks&gt;.
            </summary>
        </member>
        <member name="T:MCS.Library.Core.AttributeHelper">
            <summary>
            Attribute定义的控制器
            </summary>
            <remarks>
            通过反射，读取类、属性、方法等的Attribute定义
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.AttributeHelper.GetCustomAttribute``1(System.Reflection.MemberInfo)">
            <summary>
            读取类、属性或方法上的Attribute定义
            </summary>
            <typeparam name="T">欲读取的类、属性或方法的类型</typeparam>
            <param name="element">类、属性或方法类型的实例</param>
            <returns>类、属性或方法等的Attribute实例</returns>
            <remarks>
            读取类、属性或方法上的Attribute定义。采用反射机制实现。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\AttributeHelperTest.cs" region="GetCustomAttributeTest" lang="cs" title="获取CollegeStudent的DescriptionAttribute内容"/>
            <seealso cref="T:System.ComponentModel.DescriptionAttribute"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
        </member>
        <member name="T:MCS.Library.Core.ExceptionHelper">
            <summary>
            Exception工具，提供了TrueThrow和FalseThrow等方法
            </summary>
            <remarks>Exception工具，TrueThrow方法判断它的布尔参数值是否为true，若是则抛出异常；FalseThrow方法判断它的布尔参数值是否为false，若是则抛出异常。
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.NullCheck(System.Object,System.String)">
            <summary>
            检查对象是否为空，如果为空，抛出ArgumentNullException
            </summary>
            <param name="data">被检查的对象</param>
            <param name="message">参数的名称</param>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.NullCheck``1(System.Object,System.String,System.Object[])">
            <summary>
            检查对象是否为空，如果为空，抛出异常
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="message"></param>
            <param name="messageParams"></param>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.TrueThrow(System.Boolean,System.String,System.Object[])">
            <summary>
            如果条件表达式boolExpression的结果值为真(true)，则抛出strMessage指定的错误信息
            </summary>
            <param name="parseExpressionResult">条件表达式</param>
            <param name="message">错误信息</param>
            <param name="messageParams">错误信息参数</param>
            <remarks>
            如果条件表达式boolExpression的结果值为真(true)，则抛出strMessage指定的错误信息
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ExceptionsTest.cs" lang="cs" title="通过判断条件表达式boolExpression的结果值而判断是否抛出指定的异常信息"/>
            <seealso cref="M:MCS.Library.Core.ExceptionHelper.FalseThrow(System.Boolean,System.String,System.Object[])"/>
            <seealso cref="T:MCS.Library.Compression.ZipReader"/>
            </remarks>
            <example>
            <code>
            ExceptionTools.TrueThrow(name == string.Empty, "对不起，名字不能为空！");
            </code>
            </example>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.TrueThrow``1(System.Boolean,System.String,System.Object[])">
            <summary>
            如果条件表达式boolExpression的结果值为真(true)，则抛出strMessage指定的错误信息
            </summary>
            <param name="parseExpressionResult">条件表达式</param>
            <param name="message">错误信息</param>
            <param name="messageParams">错误信息的参数</param>
            <typeparam name="T">异常的类型</typeparam>
            <remarks>
            如果条件表达式boolExpression的结果值为真(true)，则抛出message指定的错误信息
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ExceptionsTest.cs" region="TrueThrowTest" lang="cs" title="通过判断条件表达式boolExpression的结果值而判断是否抛出指定的异常信息"/>
            <seealso cref="M:MCS.Library.Core.ExceptionHelper.FalseThrow(System.Boolean,System.String,System.Object[])"/>
            <seealso cref="T:MCS.Library.Logging.LogEntity"/>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.FalseThrow(System.Boolean,System.String,System.Object[])">
            <summary>
            如果条件表达式boolExpression的结果值为假（false），则抛出strMessage指定的错误信息
            </summary>
            <param name="parseExpressionResult">条件表达式</param>
            <param name="message">错误信息</param>
            <param name="messageParams">错误信息参数</param>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ExceptionsTest.cs" region="FalseThrowTest" lang="cs" title="通过判断条件表达式boolExpression的结果值而判断是否抛出指定的异常信息"/>
            <seealso cref="M:MCS.Library.Core.ExceptionHelper.TrueThrow(System.Boolean,System.String,System.Object[])"/>
            <seealso cref="T:MCS.Library.Logging.LoggerFactory"/>
            <remarks>
            如果条件表达式boolExpression的结果值为假（false），则抛出message指定的错误信息
            </remarks>
            <example>
            <code>
            ExceptionTools.FalseThrow(name != string.Empty, "对不起，名字不能为空！");
            </code>
            </example>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.FalseThrow``1(System.Boolean,System.String,System.Object[])">
            <summary>
            如果条件表达式boolExpression的结果值为假（false），则抛出message指定的错误信息
            </summary>
            <typeparam name="T">异常的类型</typeparam>
            <param name="parseExpressionResult">条件表达式</param>
            <param name="message">错误信息</param>
            <param name="messageParams">错误信息参数</param>
            <remarks>
            如果条件表达式boolExpression的结果值为假（false），则抛出strMessage指定的错误信息
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ExceptionsTest.cs" region="FalseThrowTest" lang="cs" title="通过判断条件表达式boolExpression的结果值而判断是否抛出指定的异常信息"/>
            <seealso cref="M:MCS.Library.Core.ExceptionHelper.TrueThrow(System.Boolean,System.String,System.Object[])"/>
            <seealso cref="T:MCS.Library.Core.EnumItemDescriptionAttribute"/>
            </remarks>
            <example>
            <code>
            ExceptionTools.FalseThrow(name != string.Empty, typeof(ApplicationException), "对不起，名字不能为空！");
            </code>
            </example>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.CheckStringIsNullOrEmpty(System.String,System.String)">
            <summary>
            检查字符串参数是否为Null或空串，如果是，则抛出异常
            </summary>
            <param name="data">字符串参数值</param>
            <param name="paramName">字符串名称</param>
            <remarks>
            若字符串参数为Null或空串，抛出ArgumentException异常
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\ExceptionsTest.cs" region="CheckStringIsNullOrEmpty" lang="cs" title="检查字符串参数是否为Null或空串，若是，则抛出异常" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.CheckStringIsNullOrEmpty``1(System.String,System.String)">
            <summary>
            检查字符串参数是否为Null或空串，如果是，则抛出异常
            </summary>
            <typeparam name="T">异常的类型</typeparam>
            <param name="data">检查字符串参数是否为Null或空串，如果是，则抛出异常</param>
            <param name="message"></param>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.GetRealException(System.Exception)">
            <summary>
            从Exception对象中，获取真正发生错误的错误对象。
            </summary>
            <param name="ex">Exception对象</param>
            <returns>真正发生错误的错误对象</returns>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.GetSoapExceptionMessage(System.Exception)">
            <summary>
            得到SoapException中的错误信息
            </summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.DoSilentAction(System.Action)">
            <summary>
            执行一个不抛出异常的操作
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.WriteToEventLog(System.Exception,System.String)">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="ex"></param>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.WriteToEventLog(System.Exception,System.String,System.Diagnostics.EventLogEntryType)">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="entryType"></param>
            <param name="ex"></param>
        </member>
        <member name="M:MCS.Library.Core.ExceptionHelper.WriteToEventLog(System.Exception,System.String,System.Diagnostics.EventLogEntryType,System.Int32)">
            <summary>
            
            </summary>
            <param name="source"></param>
            <param name="entryType"></param>
            <param name="eventID"></param>
            <param name="ex"></param>
        </member>
        <member name="T:MCS.Library.Core.XmlHelper">
            <summary>
            本基类提供和XML相关数据处理的相关函数，这里包含的所有方法都是与XML文档对象操作相关，目的就是为了方便程序员的程序开发，提供有效、快捷的共
            用函数
            </summary>
            <remarks>
            本基类提供和XML相关数据处理的相关函数。这里采用静态方法的形式提供出各种数据对象与XML数据之间的数据转换。
            <list type="bullet">
            <item>数据集到XML文档对象的转换。如DataSet, DataReader等的数据转换成XML文档对象的方法</item>
            <item>XML文档对象的节点上添加节点和属性的不同操作</item>
            <item>XML文档对象中节点替换、存在、遍历的处理</item>
            </list>
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetExceptionXmlDoc(System.Exception)">
            <summary>
            将异常对象生成为一个XML文档对象，相当于将Exception序列化为Xml
            </summary>
            <param name="ex">异常对象</param>
            <returns>表示异常对象的Xml文档</returns>
            <remarks>相当于将Exception对象序列化为Xml文档对象，有利于Exception对象输出到用户
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region ="GetExceptionXmlTest" lang="cs" title="将Exception序列化为Xml" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendExceptionInfo(System.Xml.XmlWriter,System.Exception)">
            <summary>
            在XmlWriter中添加Exception的信息
            </summary>
            <param name="writer">XmlWriter对象</param>
            <param name="ex">异常对象</param>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region ="AppendExceptionInfoTest" lang="cs" title="将Exception序列化为Xml" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.LoadDocument(System.String)">
             <summary>
             从某个磁盘文件加载XML文档对象
             </summary>
             <param name="path">文件路径</param>
             <returns>XML文档对象</returns>
             <remarks>从某个磁盘文件加载XML文档对象，该方法和XmlDocument.Load的不同点在于它支持共享读，即使在别的程序正在写这个文件
             <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region ="LoadDocumentTest" lang="cs" title="从磁盘加载Xml文档对象" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.LoadDocumentAsync(System.String)">
             <summary>
             从某个磁盘文件异步加载XML文档对象
             </summary>
             <param name="path">文件路径</param>
             <returns>XML文档对象</returns>
             <remarks>从某个磁盘文件加载XML文档对象，该方法和XmlDocument.Load的不同点在于它支持共享读，即使在别的程序正在写这个文件
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.LoadElement(System.String)">
            <summary>
            以共享读方式打开文件构造XElement
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.LoadElementAsync(System.String)">
            <summary>
            以共享读方式异步打开文件构造XElement
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.CreateDomDocument(System.String)">
            <summary>
            建立一个XML文档对象，并初始化文档（方便文档对象的创建和初始化）
            </summary>
            <param name="xml">XML文档对象在初始化的时候要求的数据值</param>
            <returns>创建以后并且被初始化的XmlDocument对象</returns>
            <remarks>
            建立一个XML文档对象，并且可以初始化文档（方便文档对象的创建和初始化）。该函数包含了XML文档对象
            创建和初始化的两步工作，这样方便了编程人员的创建XML文档对象和初始化的工作。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="CreateDocumentTest" lang="cs" title="创建一个Xml文档对象" />
            </remarks>
            <example>
            <code>
            XmlDocument xmlDoc = XMLHelper.CreateDomDocument("&lt;DataSet/&gt;");
            </code>
            </example>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNode(System.Xml.XmlNode,System.String)">
            <summary>
            在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点
            </summary>
            <param name="root">文档对象中的指定要添加子节点的根节点</param>
            <param name="nodeName">要被添加的子节点名称</param>
            <returns>被添加的子节点对象</returns>
            <remarks>
            在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点。该子节点的名称由
            nodeName指定，它的内容（InnerXml）为空。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region ="AppendNodeTest" lang="cs" title="在xml文档对象中在指定的节点下面添加指定的子节点" />
            </remarks>
            <example>
            <code>
            XmlDocument xmlDoc = CreateDomDocument("&lt;FIRST&gt;&lt;SECOND&gt;&lt;THIRD/&gt;&lt;/SECOND&gt;&lt;/FIRST&gt;");
            XmlNode root = xmlDoc.DocumentElement.FirstChild;
            XmlNode node = XMLHelper.AppendNode(root, "FOURTH");
            </code>
            结果为：
            <code>
            &lt;FIRST&gt;
            	&lt;SECOND&gt;
            		&lt;THIRD/&gt;
            		&lt;FOURTH/&gt;
            	&lt;/SECOND&gt;
            &lt;/FIRST&gt;
            </code>
            </example>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNodeWithNamespace(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点
            </summary>
            <param name="root"></param>
            <param name="nodeName"></param>
            <param name="namespaceURI"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNodeWithNamespace``1(System.Xml.XmlNode,System.String,System.String,``0)">
            <summary>
            在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点，其中该节点的内容为nodeValue
            </summary>
            <typeparam name="T">节点值的类型</typeparam>
            <param name="root"></param>
            <param name="nodeName"></param>
            <param name="namespaceURI"></param>
            <param name="nodeValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendCDataNodeWithNamespace``1(System.Xml.XmlNode,System.String,System.String,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="root"></param>
            <param name="nodeName"></param>
            <param name="namespaceURI"></param>
            <param name="nodeValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotNullNodeWithNamespace``1(System.Xml.XmlNode,System.String,System.String,``0)">
            <summary>
            如果nodeValue不为空(null或string.Empty)，在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点，其中该节点的内容为nodeValue
            </summary>
            <typeparam name="T"></typeparam>
            <param name="root"></param>
            <param name="nodeName"></param>
            <param name="namespaceURI"></param>
            <param name="nodeValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotDefaultNode``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="root"></param>
            <param name="nodeName"></param>
            <param name="nodeValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotDefaultNodeWithNamespace``1(System.Xml.XmlNode,System.String,System.String,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="root"></param>
            <param name="nodeName"></param>
            <param name="namespaceURI"></param>
            <param name="nodeValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendAttrWithNamespace(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="namespaceURI"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendAttrWithNamespace``1(System.Xml.XmlNode,System.String,System.String,``0)">
            <summary>
            为xml文档对象的node指定节点上创建一个属性，属性名称为attrName，属性的值为attrValue
            </summary>
            <param name="node">要添加属性的节点</param>
            <param name="attrName">要添加的属性名称</param>
            <param name="attrValue">要添加的属性内容</param>
            <param name="namespaceURI"></param>
            <typeparam name="T">属性值的类型</typeparam>
            <returns>添加的属性对象</returns>
            <remarks>
            为xml文档对象的node指定节点上创建一个属性，属性名称为attrName，默认该属性的值为strValue指定。注意，该函数调用了
            AppendAttr(XmlDocument xmlDoc, XmlNode node, string attrName)来创建一个默认值为空的属性，然后再把属性内容修改成
            attrValue指定的内容
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="AppendAttrTest" lang="cs" title="在xml文档对象的node指定节点上创建一个属性" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotNullAttrWithNamespace``1(System.Xml.XmlNode,System.String,System.String,``0)">
            <summary>
            当attrValue值非空时(不是null或string.Empty)，为xml文档对象的node指定节点上创建一个属性，属性名称为attrName，属性的值为attrValue
            </summary>
            <typeparam name="T">属性值的类型</typeparam>
            <param name="node">要添加属性的节点</param>
            <param name="attrName">要添加的属性名称</param>
            <param name="attrValue">要添加的属性内容</param>
            <param name="namespaceURI"></param>
            <returns>添加的属性对象</returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotDefaultAttrWithNamespace``1(System.Xml.XmlNode,System.String,System.String,``0)">
            <summary>
            如果attrValue不等于该类型的缺省值，则添加此属性
            </summary>
            <typeparam name="T"></typeparam>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="attrValue"></param>
            <param name="namespaceURI"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNode``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点，其中该节点的内容为nodeValue
            </summary>
            <typeparam name="T">节点值的类型</typeparam>
            <param name="root">文档对象中的指定要添加子节点的根节点</param>
            <param name="nodeName">要被添加的子节点名称</param>
            <param name="nodeValue">要被添加的子节点的内容</param>
            <returns>被添加的子节点对象</returns>
            <remarks>
            在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点。该子节点的名称由
            nodeName指定，它的内容为nodeValue。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="AppendNodeTest" lang="cs" title="在xml文档对象中在指定的节点下面添加指定的子节点" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotNullNode``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            如果nodeValue不为空(null或string.Empty)，在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点，其中该节点的内容为nodeValue
            </summary>
            <typeparam name="T">节点值的类型</typeparam>
            <param name="root">文档对象中的指定要添加子节点的根节点</param>
            <param name="nodeName">要被添加的子节点名称</param>
            <param name="nodeValue">要被添加的子节点的内容</param>
            <returns>被添加的子节点对象</returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNode``1(System.Xml.XmlWriter,System.String,``0)">
            <summary>
            在XmlWriter对象中添加一个名称为nodeName指定的子节点，其中该节点的内容为nodeValue
            </summary>
            <typeparam name="T">节点值的类型</typeparam>
            <param name="writer">XmlWriter对象</param>
            <param name="nodeName">要被添加的子节点名称</param>
            <param name="nodeValue">要被添加的子节点的内容</param>
            <remarks>在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点。该子节点的名称由
            nodeName指定，它的内容为nodeValue。
            /// <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="XmlWriterAppendNodeTest" lang="cs" title="在Xml Writer对象中在指定的节点下面添加指定的子节点" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotNullNode``1(System.Xml.XmlWriter,System.String,``0)">
            <summary>
            如果nodeValue不为空(null或string.Empty)，在XmlWriter对象中添加一个名称为nodeName指定的子节点，其中该节点的内容为nodeValue
            </summary>
            <typeparam name="T">节点值的类型</typeparam>
            <param name="writer">XmlWriter对象</param>
            <param name="nodeName">要被添加的子节点名称</param>
            <param name="nodeValue">要被添加的子节点的内容</param>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendCDataNode``1(System.Xml.XmlWriter,System.String,``0)">
            <summary>
            在XmlWriter对象中添加一个名称为nodeName指定的子节点，其中该节点包含在CData中，内容为nodeValue
            </summary>
            <typeparam name="T">节点值的类型</typeparam>
            <param name="writer">XmlWriter对象</param>
            <param name="nodeName">要被添加的子节点名称</param>
            <param name="nodeValue">要被添加的子节点的内容</param>
            <remarks>在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点。该子节点的名称由
            nodeName指定，其中该节点包含在CData中，内容为nodeValue。
            /// <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="XmlWriterAppendNodeTest" lang="cs" title="在Xml Writer对象中在指定的节点下面添加指定的子节点" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendCDataNode``1(System.Xml.XmlNode,System.String,``0)">
             <summary>
             在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点，其中该节点的内容为nodeValue指定。
             </summary>
             <param name="root">文档对象中的指定要添加子节点的根节点</param>
             <param name="nodeName">要被添加的子节点名称</param>
             <param name="nodeValue">要被添加的子节点的内容</param>
             <typeparam name="T">节点值的类型</typeparam>
             <returns>被添加的子节点对象</returns>
             <remarks>在xml文档对象中由root指定的节点下面添加一个名称为nodeName指定的子节点，其中该节点的内容为nodeValue指定。但是节点的内容会被CData Section包围起来
             <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="AppendCDataNodeTest" lang="cs" title="在xml文档对象中在指定的节点下面添加指定的子节点" />
             </remarks>
             <example>
             <code>
             <![CDATA[
             XmlDocument xmlDoc = CreateDomDocument("<Document/>");
             
             XmlNode root = xmlDoc.DocumentElement;
             
             XmlNode node = AppendCDataNode(root, "Data", "  Hello world !");
            
             结果为：
             <Document>
            		<Data>
            			<![CDATA[  Hello world !]]/>
            		</Data>
            	</Document>
             ]]>
             </code>
             </example>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotExistsNode``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            在XML文档对象xmlDoc中的root节点下添加一个名称由nodeName指定内容由nodeValue指定的节点。如果在root指定
            的根节点下已经存在有节点名称为nodeName，那我们就仅仅在它的内容为空的时候把值修改为nodeValue
            </summary>
            <typeparam name="T">nodeValue的类型</typeparam>
            <param name="root">文档对象中的指定要添加子节点的根节点</param>
            <param name="nodeName">要被添加的子节点名称（或xPath方式）</param>
            <param name="nodeValue">要被添加的子节点的内容</param>
            <returns>被添加的子节点对象</returns>
            <remarks>
            在XML文档对象xmlDoc中的root节点下添加一个名称由nodeName指定内容由nodeValue指定的节点。如果在root指定
            的根节点下已经存在有节点名称为nodeName，那我们就仅仅在它的内容为空的时候把值修改为nodeValue。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region = "AppendNotExistsNodeTest" lang="cs" title="在xml文档对象中在指定的节点下面添加指定的子节点" />
            </remarks>
            <example>
            下面我们可以看一下该函数的处理（原数据与结果数据的对比，这里我们针对节点FOURTH, nodeValue设定为“1234”，
            根节点设定为SECOND指定节点）：
            <table align="center">
            	<tr>
            		<td align="center">XML文档对象原数据</td>
            		<td align="center">XML文档对象新数据</td>
            	</tr>
            	<tr>
            		<td>
            			<code>
            &lt;FIRST&gt;
            	&lt;SECOND&gt;
            		&lt;THIRD/&gt;
            	&lt;/SECOND&gt;
            &lt;/FIRST&gt;
            			</code>
            		</td>
            		<td>
            			<code>
            &lt;FIRST&gt;
            	&lt;SECOND&gt;
            		&lt;THIRD/&gt;
            		&lt;FOURTH&gt;1234&lt;/FOURTH&gt;
            	&lt;/SECOND&gt;
            &lt;/FIRST&gt;
            			</code>
            		</td>
            	</tr>
            	<tr>
            		<td>
            			<code>
            &lt;FIRST&gt;
            	&lt;SECOND&gt;
            		&lt;THIRD/&gt;
            		&lt;FOURTH/&gt;
            	&lt;/SECOND&gt;
            &lt;/FIRST&gt;
            			</code>
            		</td>
            		<td>
            			<code>
            &lt;FIRST&gt;
            	&lt;SECOND&gt;
            		&lt;THIRD/&gt;
            		&lt;FOURTH&gt;1234&lt;/FOURTH&gt;
            	&lt;/SECOND&gt;
            &lt;/FIRST&gt;
            			</code>
            		</td>
            	</tr>
            	<tr>
            		<td>
            			<code>
            &lt;FIRST&gt;
            	&lt;SECOND&gt;
            		&lt;THIRD/&gt;
            		&lt;FOURTH&gt;6789&lt;/FOURTH&gt;
            	&lt;/SECOND&gt;
            &lt;/FIRST&gt;
            			</code>
            		</td>
            		<td>
            			<code>
            &lt;FIRST&gt;
            	&lt;SECOND&gt;
            		&lt;THIRD/&gt;
            		&lt;FOURTH&gt;6789&lt;/FOURTH&gt;
            	&lt;/SECOND&gt;
            &lt;/FIRST&gt;
            			</code>
            		</td>
            	</tr>
            </table>
            </example>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.ReplaceNode``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            在XML文档对象xmlDoc中的指定根节点root下，如果有名称为nodeName的节点就把该节点的内容修改为nodeValue指定的内容。
            否则就在root下创建一个名称为nodeName内容为nodeValue指定的新节点
            </summary>
            <param name="root">被替换节点的的根节点</param>
            <param name="nodeName">被替换子节点的名称(或xpath)</param>
            <param name="nodeValue">被替换子节点的内容</param>
            <typeparam name="T">节点值的类型</typeparam>
            <returns>被替换节点的节点对象</returns>
            <remarks>ReplaceNodeTest
            在XML文档对象xmlDoc中的指定根节点root下，如果有名称为nodeName的节点就把该节点的内容修改为nodeValue指定的内容。
            否则就在root下创建一个名称为nodeName内容为nodeValue指定的新节点
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region = "ReplaceNodeTest" lang="cs" title="在xml文档对象中添加一个节点，若该节点在xml文档对象中存在，则把该节点的值替换为nodeValue" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.ReplaceNode(System.Xml.XmlNode,System.String)">
            <summary>
            在XML文档对象xmlDoc中的指定根节点root下，如果有名称为nodeName的节点就把该节点的内容修改为nodeValue指定的内容。
            否则就在root下创建一个名称为nodeName内容为nodeValue指定的新节点
            </summary>
            <param name="root">被替换节点的的根节点</param>
            <param name="nodeName">被替换子节点的名称(或xpath)</param>
            <returns>被替换节点的节点对象</returns>
            <remarks> 
            在XML文档对象xmlDoc中的指定根节点root下，如果有名称为nodeName的节点就把该节点的内容修改为nodeValue指定的内容。
            否则就在root下创建一个名称为nodeName内容为nodeValue指定的新节点
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region = "ReplaceNodeTest" lang="cs" title="在xml文档对象中添加一个节点，若该节点在xml文档对象中存在，则把该节点的值替换为nodeValue" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendAttr(System.Xml.XmlNode,System.String)">
            <summary>
            为xml文档对象的node指定节点上创建一个属性，属性名称为attrName，默认该属性的值为空
            </summary>
            <param name="node">要添加属性的节点</param>
            <param name="attrName">要添加的属性名称</param>
            <returns>添加的属性对象（此时属性的内容还是空的）</returns>
            <remarks>
            为xml文档对象的node指定节点上创建一个属性，属性名称为attrName，默认该属性的值为空。如果您需要添加具体的属性内容
            可以采用该函数的重载函数AppendAttr(XmlNode node, string attrName, string strValue)
             <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="AppendAttrTest" lang="cs" title="为xml文档对象的node指定节点上创建一个属性" />
            </remarks>
            <example>
            <code>
            XmlDocument xmlDoc = XMLHelper.CreateDomDocument("&lt;FIRST&gt;&lt;SECOND&gt;&lt;THIRD/&gt;&lt;/SECOND&gt;&lt;/FIRST&gt;");
            XmlAttribute attr = XMLHelperr.AppendAttr(xmlDoc.DocumentElement.FirstChild, "WEIGHT");
            attr.Value = "65kg";
            </code>
            </example>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendAttr``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            为xml文档对象的node指定节点上创建一个属性，属性名称为attrName，属性的值为attrValue
            </summary>
            <param name="node">要添加属性的节点</param>
            <param name="attrName">要添加的属性名称</param>
            <param name="attrValue">要添加的属性内容</param>
            <typeparam name="T">属性值的类型</typeparam>
            <returns>添加的属性对象</returns>
            <remarks>
            为xml文档对象的node指定节点上创建一个属性，属性名称为attrName，默认该属性的值为strValue指定。注意，该函数调用了
            AppendAttr(XmlDocument xmlDoc, XmlNode node, string attrName)来创建一个默认值为空的属性，然后再把属性内容修改成
            attrValue指定的内容
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="AppendAttrTest" lang="cs" title="在xml文档对象的node指定节点上创建一个属性" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotNullAttr``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            当attrValue值非空时(不是null或string.Empty)，为xml文档对象的node指定节点上创建一个属性，属性名称为attrName，属性的值为attrValue
            </summary>
            <typeparam name="T">属性值的类型</typeparam>
            <param name="node">要添加属性的节点</param>
            <param name="attrName">要添加的属性名称</param>
            <param name="attrValue">要添加的属性内容</param>
            <returns>添加的属性对象</returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotDefaultAttr``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            如果attrValue不等于该类型的缺省值，则添加此属性
            </summary>
            <typeparam name="T"></typeparam>
            <param name="node"></param>
            <param name="attrName"></param>
            <param name="attrValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendAttr``1(System.Xml.XmlWriter,System.String,``0)">
            <summary>
            为Xml Writer创建一个属性，属性名称为attrName，属性的值为attrValue
            </summary>
            <typeparam name="T">属性值的类型</typeparam>
            <param name="writer">XmlWriter</param>
            <param name="attrName">要添加的属性名称</param>
            <param name="attrValue">要添加的属性内容</param>
            <remarks>
            为xml文档对象的node指定节点上创建一个属性，属性名称为attrName，属性的值为attrValue。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="XmlWriterAppendAttrTest" lang="cs" title="为Xml Writer在指定节点上创建一个属性" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.AppendNotNullAttr``1(System.Xml.XmlWriter,System.String,``0)">
            <summary>
            当attrValue值非空时(不是null或string.Empty)，为Xml Writer创建一个属性，属性名称为attrName，属性的值为attrValue
            </summary>
            <typeparam name="T">属性值的类型</typeparam>
            <param name="writer">XmlWriter</param>
            <param name="attrName">要添加的属性名称</param>
            <param name="attrValue">要添加的属性内容</param>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.EnumNodeList(System.Xml.XmlNodeList,MCS.Library.Core.XmlHelper.DoNodeList,System.Object)">
             <summary>
             对节点列表nodeList中的每一个节点进行nodeOP指定的操作，其中oParam是操作使用到的参数
             </summary>
             <param name="nodeList">节点列表</param>
             <param name="nodeOP">每次枚举一个节点所做的操作</param>
             <param name="oParam">每次操作所传入的参数</param>
             <remarks>
             对节点列表nodeList中的每一个节点进行nodeOP指定的操作，其中oParam是操作使用到的参数
             <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="EnumNodeListTest" lang="cs" title="对节点列表nodeList中的每一个节点进行nodeOP指定的操作" />
             </remarks>
             <example>
             <code>
             public static void myMethod(XmlNode nodeRoot, object oParam)
             {
             }
            
             public static void Invoke(XmlNodeList nodeList)
             {
             	XMLHelper.EnumNodeList(nodeList, new XMLHelper.DoNodeList(myMethod), new object());
             }
             </code>
             </example>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetSingleNodeText(System.Xml.XmlNode,System.String)">
            <summary>
            查询一个节点，得到该节点的正文，如果该节点不存在，则返回空串
            </summary>
            <param name="nodeRoot">执行查询的根节点</param>
            <param name="path">查询的XPath</param>
            <returns>查询nodeRoot下，按照path查询出的节点的正文，如果nodeRoot为空，或节点不存在，则返回空串</returns>
            <remarks>查询一个节点，得到该节点的正文，如果该节点不存在，则返回空串
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region ="GetSingleNodeExceptionTest" lang="cs" title="查询一个节点，得到该节点的正文" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetSingleNodeText(System.Xml.XmlNode,System.String,System.Xml.XmlNamespaceManager)">
            <summary>
            
            </summary>
            <param name="nodeRoot"></param>
            <param name="path"></param>
            <param name="nsMgr"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetSingleNodeValue``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            查询一个节点，得到该节点的正文，如果该节点不存在，则返回空串
            </summary>
            <param name="nodeRoot">执行查询的根节点</param>
            <param name="path">查询的XPath</param>
            <param name="defaultValue">如果节点不存在，返回的缺省值</param>
            <typeparam name="T">返回值的类型</typeparam>
            <returns>查询nodeRoot下，按照path查询出的节点的正文，如果nodeRoot为空，或节点或不存在，则返回缺省值</returns>
            <remarks>查询一个节点，得到该节点的正文，如果该节点不存在，则返回缺省值
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region ="GetSingleNodeValueTest" lang="cs" title="查询一个节点，得到该节点的正文" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetSingleNodeValue``1(System.Xml.XmlNode,System.String,System.Xml.XmlNamespaceManager,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="nodeRoot"></param>
            <param name="path"></param>
            <param name="nsMgr"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetSingleNodeException(System.Xml.XmlNode,System.String)">
            <summary>
            查询一个节点，如果该节点不存在，则抛出异常
            </summary>
            <param name="nodeRoot">执行查询的根节点</param>
            <param name="path">查询的XPath</param>
            <returns>查询nodeRoot下，按照path查询出的节点，如果nodeRoot为空，或节点或不存在，则抛出异常</returns>
            <remarks>查询一个节点，如果该节点不存在，则抛出异常
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="GetSingleNodeExceptionTestWithException" lang="cs" title="查询一个节点，如果该节点不存在，则抛出异常" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetSingleNodeException(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            查询一个节点，如果该节点不存在，则抛出异常
            </summary>
            <param name="nodeRoot">执行查询的根节点</param>
            <param name="path">查询的XPath</param>
            <param name="message">异常文本</param>
            <returns>查询nodeRoot下，按照path查询出的节点，如果nodeRoot为空，或节点或不存在，则抛出异常</returns>
            <remarks>查询一个节点，如果该节点不存在，则抛出异常
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="GetSingleNodeExceptionTestWithException" lang="cs" title="查询一个节点，如果该节点不存在，则抛出异常" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetSingleNodeException(System.Xml.XmlNode,System.String,System.Xml.XmlNamespaceManager,System.String)">
            <summary>
            
            </summary>
            <param name="nodeRoot"></param>
            <param name="path"></param>
            <param name="nsMgr"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetNodeText(System.Xml.XmlReader,System.String)">
            <summary>
            从XmlReader中，得到节点的字符串值
            </summary>
            <param name="reader">XmlReader</param>
            <param name="nodeName">节点名称</param>
            <returns>节点的字符串值</returns>
            <remarks>从XmlReader中，得到节点的字符串值
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="XmlReaderGetNodeValueTest" lang="cs" title="在XmlReader中得到当前节点的字符串值" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetNodeValue``1(System.Xml.XmlReader,System.String,``0)">
            <summary>
            从XmlReader中，得到节点的值
            </summary>
            <typeparam name="T">节点的值类型</typeparam>
            <param name="reader">XmlReader</param>
            <param name="nodeName">节点的名称</param>
            <param name="defaultValue">缺省值</param>
            <returns>节点的值</returns>
            <remarks>从XmlReader中，得到节点的值
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="XmlReaderGetNodeValueTest" lang="cs" title="在XmlReader中得到当前节点的值" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetAttributeText(System.Xml.XmlReader,System.String)">
            <summary>
            在XmlReader中得到当前节点的属性字符串值
            </summary>
            <param name="reader">XmlReader</param>
            <param name="attrName">属性名称</param>
            <returns>当前节点的属性字符串值</returns>
            <remarks>在XmlReader中得到当前节点的属性字符串值，如果属性不存在，则返回空串。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="XmlReaderGetAttrValueTest" lang="cs" title="在XmlReader中得到当前节点的属性字符串值" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetAttributeValue``1(System.Xml.XmlReader,System.String,``0)">
            <summary>
            在XmlReader中得到当前节点的属性值
            </summary>
            <typeparam name="T">属性值的类型</typeparam>
            <param name="reader">XmlReader</param>
            <param name="attrName">属性名称</param>
            <param name="defaultValue">如果属性不存在，缺省值</param>
            <returns>当前节点的属性值</returns>
            <remarks>在XmlReader中得到当前节点的属性值，如果属性不存在，则返回缺省值
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="XmlReaderGetAttrValueTest" lang="cs" title="在XmlReader中得到当前节点的属性值" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetAttributeText(System.Xml.XmlNode,System.String)">
            <summary>
            获得一个节点的属性的值，如果该属性不存在，则返回空串
            </summary>
            <param name="nodeRoot">执行查询的节点</param>
            <param name="attrName">属性名称</param>
            <returns>nodeRoot中某个属性的值，如果该属性不存在或nodeRoot为空，则返回空串</returns>
            <remarks>获得一个属性的值，如果该属性不存在，则返回空串
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region="GetAttributeValueTest" lang="cs" title="获得一个节点的属性的值" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetAttributeText(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            
            </summary>
            <param name="nodeRoot"></param>
            <param name="attrName"></param>
            <param name="namespaceURI"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetAttributeValue``1(System.Xml.XmlNode,System.String,``0)">
            <summary>
            获得一个节点的属性的值，如果该属性不存在，则返回缺省值
            </summary>
            <typeparam name="T">返回值的类型</typeparam>
            <param name="nodeRoot">执行查询的节点</param>
            <param name="attrName">属性名称</param>
            <param name="defaultValue">缺省值</param>
            <returns>nodeRoot中某个属性的值，如果该属性不存在或nodeRoot为空，则返回空串</returns>
            <remarks>获得一个节点的属性的值，如果该属性不存在，则返回缺省值
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" region = "GetAttributeValueTest" lang="cs" title="获得一个节点的属性的值" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.GetAttributeValue``1(System.Xml.XmlNode,System.String,System.String,``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="nodeRoot"></param>
            <param name="attrName"></param>
            <param name="namespaceURI"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.SerializeObjectToXml``1(``0,System.String[])">
            <summary>
            
            </summary>
            <param name="graph"></param>
            <param name="ignorProperties"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.DeserializeToObject``1(System.Xml.XmlDocument,``0,System.String[])">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="xmlDoc"></param>
            <param name="graph"></param>
            <param name="ignorProperties"></param>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.DecorateDate(System.Object)">
            <summary>
            对数据进行最后的修饰，例如对日期类型的属性加工
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Core.XmlHelper.SerializeObjectToNode``1(System.Xml.XmlNode,MCS.Library.Core.XmlObjectMappingItem,``0,System.String[])">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="parentNode"></param>
            <param name="item"></param>
            <param name="graph"></param>
            <param name="ignorProperties"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Core.XmlHelper.DoNodeList">
            <summary>
            在枚举Xml NodeList的时候回调的函数接口
            </summary>
            <param name="nodeRoot">Xml文档的节点</param>
            <param name="oParam">对Xml文档的节点所做的操作</param>
            <remarks>通过回调函数，实现根据xml节点的需要而进行不同的操作功能。
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Core\XmlHelperTest.cs" lang="cs" title="枚举Xml NodeList时候的回调函数接口" />
            </remarks>
        </member>
        <member name="T:MCS.Library.Properties.Resource">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.CanNotFindNamedConfigElement">
            <summary>
              Looks up a localized string similar to 不能找到名称为{0}的配置集合元素.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.CanNotFindXmlNode">
            <summary>
              Looks up a localized string similar to 不能在Xml节点{0}下找到{1}.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.CanNotFoundConfigSection">
            <summary>
              Looks up a localized string similar to 不能在配置文件中找到配置节&quot;{0}&quot;.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.CanNotFoundConfigSectionElement">
            <summary>
              Looks up a localized string similar to 不能在配置文件中找到配置节&quot;{0}&quot;的详细定义部分.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.CollectionIsReadOnly">
            <summary>
              Looks up a localized string similar to 集合类是只读的，不能执行该操作.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.ConvertXmlNodeToPropertyError">
            <summary>
              Looks up a localized string similar to Xml节点{0}转换到属性{1}出错，{2}.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.DefaultTextFormat">
             <summary>
               Looks up a localized string similar to Timestamp: {timestamp}
            Title: {title}
            EventID: {eventid}
            Message: {message}
            Priority: {priority}
            EventType: {eventtype}
            StackTrace: {newline}{stacktrace}
            Machine: {machine}
            Extended Properties: {newline}{dictionary({key} - {value}{newline})}.
             </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.DependencyChanged">
            <summary>
              Looks up a localized string similar to Cache项{0}失效了，失效的依赖条件类型是{1}.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.DuplicateDescriptorKey">
            <summary>
              Looks up a localized string similar to 在集合中添加对象类型{0}时，Key属性值&quot;{1}&quot;重复.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.DuplicateKey">
            <summary>
              Looks up a localized string similar to 已添加了具有相同键的项: {0}.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.ExceptionConflictPathDefinition">
            <summary>
              Looks up a localized string similar to 应用&apos;{0}&apos; 定义了相互冲突的路径&apos;{1}&apos; 和  &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.ExceptionNullOrEmptyString">
            <summary>
              Looks up a localized string similar to The value can not be null or an empty string..
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.ExceptionSerializationFormatterType">
            <summary>
              Looks up a localized string similar to The formatter type &apos;{0}&apos; of &apos;{1}&apos;  is invalid..
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.FileNotFound">
            <summary>
              Looks up a localized string similar to 文件&quot;{0}&quot;不存在.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.GlobalFileNotFound">
            <summary>
              Looks up a localized string similar to Meta中配置的全局配置文件&quot;{0}&quot;不存在.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.InitialPropertyError">
            <summary>
              Looks up a localized string similar to 初始化类属性失败。错误信息：{0}.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.InvalidMemberInfoType">
            <summary>
              Looks up a localized string similar to 成员{0}，对象映射时不支持的成员类型{1}.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.MetaFileNotFound">
            <summary>
              Looks up a localized string similar to Meta文件&quot;{0}&quot;不存在.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.ReflectedPropertyTokenNotFound">
            <summary>
              Looks up a localized string similar to &lt;Error: property {0} not found&gt;.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.StringParamCanNotBeNullOrEmpty">
            <summary>
              Looks up a localized string similar to 字符串参数{0}不能为Null或空串.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.TypeLoadException">
            <summary>
              Looks up a localized string similar to 不能加载类型{0}.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.Resource.TypeMustBeEnum">
            <summary>
              Looks up a localized string similar to 类型{0}必须是枚举类型.
            </summary>
        </member>
        <member name="T:MCS.Library.Properties.RegExpResource">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.EMail">
            <summary>
              Looks up a localized string similar to ^([0-9a-zA-Z]+[-._+&amp;])*[0-9a-zA-Z]+@([-0-9a-zA-Z]+[.])+[a-zA-Z]{2,6}$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.Interger">
            <summary>
              Looks up a localized string similar to ^\+?[1-9][0-9]*$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.IpAddress">
            <summary>
              Looks up a localized string similar to ^(?&lt;First&gt;2[0-4]\d|25[0-5]|[01]?\d\d?)\.(?&lt;Second&gt;2[0-4]\d|25[0-5]|[01]?\d\d?)\.(?&lt;Third&gt;2[0-4]\d|25[0-5]|[01]?\d\d?)\.(?&lt;Fourth&gt;2[0-4]\d|25[0-5]|[01]?\d\d?)$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.Money">
            <summary>
              Looks up a localized string similar to ^[0-9]+(.[0-9]{2})?$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.OnlyAlpha">
            <summary>
              Looks up a localized string similar to ^[A-Za-z]+$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.OnlyAlphaAndNumber">
            <summary>
              Looks up a localized string similar to ^[A-Za-z0-9]+$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.OnlyAlphaLower">
            <summary>
              Looks up a localized string similar to ^[a-z]+$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.OnlyAlphaUpper">
            <summary>
              Looks up a localized string similar to ^[A-Z]+$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.OnlyChinese">
            <summary>
              Looks up a localized string similar to ^[\u4e00-\u9fa5]{0,}$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.OnlyNumber">
            <summary>
              Looks up a localized string similar to ^([1-9]\d*)$|^0$.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.RegExpResource.Url">
            <summary>
              Looks up a localized string similar to ^(?&lt;Protocol&gt;\w+):\/\/(?&lt;Domain&gt;[\w.]+\/?)\S*$.
            </summary>
        </member>
        <member name="T:MCS.Library.Properties.ScriptResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.DatetimeEmptyValidator">
             <summary>
               Looks up a localized string similar to if (typeof ($$methodname) != &quot;undefined&quot;) {
                alert(&quot;方法冲突，$$methodname已定义!&quot;);
            }
            else {
                var $$methodname = function (cvalue) {
                    var isValidate = false;
                    isValidate = (isNaN(cvalue) == false);
            
                    if (isValidate)
                        isValidate = Date.isMinDate(cvalue) == false;
                    return isValidate;
                }
            }.
             </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.DateTimeRangeValidator">
             <summary>
               Looks up a localized string similar to if (typeof ($$methodname) != &quot;undefined&quot;) {
                alert(&quot;方法冲突，$$methodname已定义!&quot;);
            }
            else {
                var $$methodname = function (cvalue, additionalDatas) {
                    var isValidate = false;
                    sourcevalue = cvalue;
                    lowerBound = additionalDatas[0];
                    upperBound = additionalDatas[1];
            
                    if (sourcevalue * 1 &lt; lowerBound * 1 || sourcevalue * 1 &gt; upperBound * 1) {
                        isValidate = false;
                    }
                    else {
                        isValidate = true;
                    }
            
                    return isV [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.EnumDefaultValueValidator">
             <summary>
               Looks up a localized string similar to if (typeof ($$methodname) != &quot;undefined&quot;) {
                alert(&quot;方法冲突，$$methodname已定义!&quot;);
            }
            else {
                var $$methodname = function (cvalue,additionalDatas) {
                    var isValidate = false;
                    if (cvalue) {
                        isValidate = cvalue != additionalDatas[0];
                    }
                    return isValidate;
                }
            }.
             </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.IntegerRangeValidator">
             <summary>
               Looks up a localized string similar to if (typeof ($$methodname) != &quot;undefined&quot;) {
                alert(&quot;方法冲突，$$methodname已定义!&quot;);
            }
            else {
                var $$methodname = function (cvalue, additionalDatas) {
                    var isValidate = false;
                    sourcevalue = cvalue;
                    lowerBound = additionalDatas[0];
                    upperBound = additionalDatas[1];
            
                    if (sourcevalue * 1 &lt; lowerBound * 1 || sourcevalue * 1 &gt; upperBound * 1) {
                        isValidate = false;
                    }
                    else {
                        isValidate = true;
                    }
            
                    return isV [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.NotNullValidator">
             <summary>
               Looks up a localized string similar to if (typeof ($$methodname) != &quot;undefined&quot;) {
                alert(&quot;方法冲突，$$methodname已定义!&quot;);
            }
            else {
                var $$methodname = function (cvalue) {
                    var isValidate = false;
                    if (cvalue) {
                        isValidate = true;
                    }
                    return isValidate;
                }
            }.
             </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.ObjectNullValidator">
             <summary>
               Looks up a localized string similar to if (typeof ($$methodname) != &quot;undefined&quot;) {
                alert(&quot;方法冲突，$$methodname已定义!&quot;);
            }
            else {
                var $$methodname = function (cvalue) {
                    var isValidate = false;
                    if (cvalue) {
                        isValidate = true;
                    }
                    return isValidate;
                }
            }.
             </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.RegexValidator">
             <summary>
               Looks up a localized string similar to  if (typeof ($$methodname) != &quot;undefined&quot;) {
                alert(&quot;方法冲突，$$methodname已定义!&quot;);
            }
            else {
                var $$methodname = function (cvalue, additionalDatas) {
                    if (additionalDatas[0] === true) {
                        cvalue = cvalue.toString().replace(/,/g, &apos;&apos;);
                    }
            
                    var isValidate = false;
                    var reg = new RegExp(additionalDatas[1].toString());
                    isValidate = reg.test(cvalue);
            
                    return isValidate;
                }
            }
            .
             </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.StringEmptyValidator">
            <summary>
              Looks up a localized string similar to .
            </summary>
        </member>
        <member name="P:MCS.Library.Properties.ScriptResources.StringLengthValidator">
            <summary>
              Looks up a localized string similar to .
            </summary>
        </member>
        <member name="T:MCS.Library.Security.DESEncryptorBase">
            <summary>
            基于DES的对称算法的基类
            </summary>
        </member>
        <member name="T:MCS.Library.Security.ISymmetricEncryption">
            <summary>
            对称加密算法的实现
            </summary>
        </member>
        <member name="M:MCS.Library.Security.ISymmetricEncryption.EncryptString(System.String)">
            <summary>
            加密字符串
            </summary>
            <param name="strData">字符串数据</param>
            <returns>加密后的二进制流</returns>
        </member>
        <member name="M:MCS.Library.Security.ISymmetricEncryption.DecryptString(System.Byte[])">
            <summary>
            解密字符串
            </summary>
            <param name="encryptedData">加密过的数据</param>
            <returns>解密后的字符串</returns>
        </member>
        <member name="M:MCS.Library.Security.DESEncryptorBase.EncryptString(System.String)">
            <summary>
            将二进制流加密为字符串
            </summary>
            <param name="strData"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Security.DESEncryptorBase.DecryptString(System.Byte[])">
            <summary>
            将二进制流解密为字符串
            </summary>
            <param name="encryptedData"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Security.DESEncryptorBase.GetDesObject">
            <summary>
            得到DES对象（提供密钥）
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Security.MachineKeyEncryptor">
            <summary>
            使用Machine Key加密和解密字符串
            </summary>
        </member>
        <member name="M:MCS.Library.Security.MachineKeyEncryptor.Encrypt(System.String)">
            <summary>
            加密字符串
            </summary>
            <param name="strData"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Security.MachineKeyEncryptor.Decrypt(System.String)">
            <summary>
            解密字符串
            </summary>
            <param name="encryptedData"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Security.SecurityExtension">
            <summary>
            和安全有关的扩展方法
            </summary>
        </member>
        <member name="M:MCS.Library.Security.SecurityExtension.ToDES(System.String)">
            <summary>
            如果字符串是DES的key，那么就生成此DES的密钥
            </summary>
            <param name="desKey"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Services.AppDomainBuilders">
            <summary>
            AppDomain的创建器
            </summary>
        </member>
        <member name="M:MCS.Library.Services.AppDomainBuilders.CreateDefaultAppDomain(System.String)">
            <summary>
            默认的AppDomain的创建器
            </summary>
            <param name="appName"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Services.CacheSoapExtensionBase`1">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.GetInitializer(System.Type)">
            <summary>
            参数中的serviceType在Server端一般是WebService类的派生类，客户端的一般是代理类。
            通过这个类型来判断到底是Server端还是Client端使用这个Extension
            </summary>
            <param name="serviceType">使用这个Extension的类</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.GetInitializer(System.Web.Services.Protocols.LogicalMethodInfo,System.Web.Services.Protocols.SoapExtensionAttribute)">
            <summary>
             System.Web.Services.Protocols.LogicalMethodInfo，它表示应用 SOAP 扩展的 XML Web services 方法的特定函数原型。
            </summary>
            <param name="methodInfo">应用于 XML Web services 方法的 System.Web.Services.Protocols.SoapExtensionAttribute。</param>
            <param name="attribute"></param>
            <returns>System.Object，SOAP 扩展将对其进行初始化以用于缓存。</returns>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.Initialize(System.Object)">
            <summary>
            
            </summary>
            <param name="initializer"></param>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.ProcessMessage(System.Web.Services.Protocols.SoapMessage)">
            <summary>
            处理消息。
            BeforeDeserialize和AfterDeserialize是发生在服务内代码执行之前。
            BeforeSerialize和AfterSerialize是发生在服务内代码执行之后。
            整个执行时序是：ChainStream，BeforeDeserialize，AfterDeserialize，BeforeSerialize，AfterSerialize
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.ChainStream(System.IO.Stream)">
            <summary>
            当在派生类中被重写时，允许 SOAP 扩展访问包含 SOAP 请求或响应的内存缓冲区。
            </summary>
            <param name="stream">包含 SOAP 请求或响应的内存缓冲区。</param>
            <returns>System.IO.Stream，它表示此 SOAP 扩展可以修改的新内存缓冲区。</returns>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.FetchDataFromCache(System.Web.Services.Protocols.SoapMessage)">
            <summary>
            从Cache中获取数据
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.CreateMessage(System.IO.Stream,System.String)">
            <summary>
            创建消息
            </summary>
            <param name="stream"></param>
            <param name="serviceName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.BeforeExecuteServerMethod(System.Web.Services.Protocols.SoapMessage)">
            <summary>
            执行Server端方法之前
            </summary>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.GetMethodCacheManager">
            <summary>
            得到服务方法缓存的管理器的实例，该实例的类型通常用于刷新缓存
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.CreateServiceMethodCache(System.String,System.Int32)">
            <summary>
            创建方法的缓存队列
            </summary>
            <param name="instanceName"></param>
            <param name="maxLength"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.InitAllParamsAndCounters(System.Web.Services.Protocols.SoapMessage)">
            <summary>
            全部初始化参数
            </summary>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.Dispose">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Services.CacheSoapExtensionBase`1.Dispose(System.Boolean)">
            <summary>
            
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:MCS.Library.Services.CacheSoapExtensionBase`1.RequestMessage">
            <summary>
            请求的消息
            </summary>
        </member>
        <member name="T:MCS.Library.Services.Configuration.ServiceConfigurationElement">
            <summary>
            Service的配置元素
            </summary>
        </member>
        <member name="P:MCS.Library.Services.Configuration.ServiceConfigurationElement.Methods">
            <summary>
            方法的定义集合
            </summary>
        </member>
        <member name="T:MCS.Library.Services.Configuration.ServiceConfigurationElementCollection">
            <summary>
            Service配置元素的集合
            </summary>
        </member>
        <member name="T:MCS.Library.Services.Configuration.ServiceMethodConfigurationElement">
            <summary>
            Web服务中每一个方法的缓存相关定义
            </summary>
        </member>
        <member name="F:MCS.Library.Services.Configuration.ServiceMethodConfigurationElement.DefaultCacheSlidingTime">
            <summary>
            默认超时时间
            </summary>
        </member>
        <member name="M:MCS.Library.Services.Configuration.ServiceMethodConfigurationElement.GetValue``1(System.String,``0)">
            <summary>
            得到没有预定义好的配置属性值
            </summary>
            <typeparam name="T"></typeparam>
            <param name="attrName"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.Configuration.ServiceMethodConfigurationElement.OnDeserializeUnrecognizedAttribute(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Services.Configuration.ServiceMethodConfigurationElement.CacheEnabled">
            <summary>
            是否使用Cache
            </summary>
        </member>
        <member name="P:MCS.Library.Services.Configuration.ServiceMethodConfigurationElement.QueueLength">
            <summary>
            Cache队列长度
            </summary>
        </member>
        <member name="P:MCS.Library.Services.Configuration.ServiceMethodConfigurationElement.CacheSlidingTime">
            <summary>
            缓存的滑动过期时间。指的是最后一次访问Cache项后，多长时间过期
            </summary>
        </member>
        <member name="T:MCS.Library.Services.Configuration.ServiceMethodConfigurationElementCollection">
            <summary>
            
            </summary>
        </member>
        <member name="T:MCS.Library.Services.Configuration.ServiceSettings">
            <summary>
            服务方法的配置信息
            </summary>
        </member>
        <member name="M:MCS.Library.Services.Configuration.ServiceSettings.GetConfig">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Services.Configuration.ServiceSettings.MethodDefaultSettings">
            <summary>
            所有方法的默认设置
            </summary>
        </member>
        <member name="P:MCS.Library.Services.Configuration.ServiceSettings.Services">
            <summary>
            服务的配置集合
            </summary>
        </member>
        <member name="T:MCS.Library.Services.HttpWebRequestExecutorBase">
            <summary>
            发送Http请求，然后获得返回结果进行处理的虚基类。
            派生类重载请求和处理响应的文本，将处理过的结果，放在派生类的属性中。
            </summary>
        </member>
        <member name="M:MCS.Library.Services.HttpWebRequestExecutorBase.Execute">
            <summary>
            执行请求，返回结果
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.HttpWebRequestExecutorBase.PrepareWebRequest">
            <summary>
            准备请求对象
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.HttpWebRequestExecutorBase.ProcessResponseText(System.String)">
            <summary>
            处理响应结果
            </summary>
            <param name="responseText"></param>
        </member>
        <member name="M:MCS.Library.Services.HttpWebRequestExecutorBase.GetResponseText(System.Net.HttpWebRequest)">
            <summary>
            得到响应的文本
            </summary>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Services.HttpWebRequestExecutorBase.ResponseEncoding">
            <summary>
            响应的文本的编码方式
            </summary>
        </member>
        <member name="P:MCS.Library.Services.HttpWebRequestExecutorBase.Request">
            <summary>
            Http请求对象
            </summary>
        </member>
        <member name="T:MCS.Library.Services.ServiceHostProxy">
            <summary>
            启动在另一个AppDomain中的Service代理
            </summary>
        </member>
        <member name="M:MCS.Library.Services.ServiceHostProxy.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="typeDesp"></param>
        </member>
        <member name="M:MCS.Library.Services.ServiceHostProxy.Start">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Services.ServiceHostProxy.Dispose">
            <summary>
            释放资源
            </summary>
        </member>
        <member name="T:MCS.Library.Services.ShadowDomainManager">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Services.ShadowDomainManager.LoadAppDomain(System.String,System.Func{System.String,System.AppDomain})">
            <summary>
            加载某个应用的AppDomain，如果已经加载，则返回已经加载的AppDomain
            </summary>
            <param name="appName">应用名称</param>
            <param name="appDomainBuilder">AppDomain的创建器</param>
            <returns>应用程序域(AppDomain)</returns>
        </member>
        <member name="M:MCS.Library.Services.ShadowDomainManager.CreateInstanceInApp(System.AppDomain,System.String,System.Object[])">
            <summary>
            通过某个应用对应的AppDomain来创建该域中的对象
            </summary>
            <param name="appDomain">应用名称</param>
            <param name="typeDesp">类型描述</param>
            <param name="args">对象的构造参数</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.ShadowDomainManager.GetAppDomain(System.String)">
            <summary>
            根据应用名称查找AppDomain，如果没有找到，则抛出异常
            </summary>
            <param name="appName"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.ShadowDomainManager.UnloadAppDomain(System.String)">
            <summary>
            卸载一个AppDomain
            </summary>
            <param name="appName"></param>
        </member>
        <member name="M:MCS.Library.Services.ShadowDomainManager.FindAppDomain(System.String)">
            <summary>
            根据应用的名称查找AppDomain
            </summary>
            <param name="appName">应用的名称</param>
            <returns>应用程序域</returns>
        </member>
        <member name="T:MCS.Library.Services.SimpleRequestSoapMessage">
            <summary>
            简单的Soap请求信息
            </summary>
        </member>
        <member name="M:MCS.Library.Services.SimpleRequestSoapMessage.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Services.SimpleRequestSoapMessage.CreateMessage(System.IO.Stream)">
            <summary>
            创建一个消息
            </summary>
            <param name="inputStream"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.SimpleRequestSoapMessage.InitFromStream(System.IO.Stream)">
            <summary>
            
            </summary>
            <param name="inputStream"></param>
        </member>
        <member name="M:MCS.Library.Services.SimpleRequestSoapMessage.InitProperties">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Services.SimpleRequestSoapMessage.ReadHeaderNode(System.Xml.XmlNamespaceManager,System.Xml.XmlNode)">
            <summary>
            
            </summary>
            <param name="namespaceManager"></param>
            <param name="headerNode"></param>
        </member>
        <member name="P:MCS.Library.Services.SimpleRequestSoapMessage.Current">
            <summary>
            当前实例
            </summary>
        </member>
        <member name="P:MCS.Library.Services.SimpleRequestSoapMessage.Document">
            <summary>
            文档对象
            </summary>
        </member>
        <member name="P:MCS.Library.Services.SimpleRequestSoapMessage.ServiceName">
            <summary>
            服务名称
            </summary>
        </member>
        <member name="P:MCS.Library.Services.SimpleRequestSoapMessage.Action">
            <summary>
            方法（动作）名称
            </summary>
        </member>
        <member name="P:MCS.Library.Services.SimpleRequestSoapMessage.UseServerCache">
            <summary>
            是否使用服务器端的缓存
            </summary>
        </member>
        <member name="P:MCS.Library.Services.SimpleRequestSoapMessage.TimePoint">
            <summary>
            调用查询方法时的TimePoint参数
            </summary>
        </member>
        <member name="P:MCS.Library.Services.SimpleRequestSoapMessage.MethodCacheKey">
            <summary>
            方法缓存的Key
            </summary>
        </member>
        <member name="P:MCS.Library.Services.SimpleRequestSoapMessage.ConnectionMappings">
            <summary>
            连接映射
            </summary>
        </member>
        <member name="P:MCS.Library.Services.SimpleRequestSoapMessage.Context">
            <summary>
            上下文参数
            </summary>
        </member>
        <member name="T:MCS.Library.Services.SoapExtensionCallerType">
            <summary>
            Soap扩展的调用者类型
            </summary>
        </member>
        <member name="F:MCS.Library.Services.SoapExtensionCallerType.ServiceMethod">
            <summary>
            服务端方法
            </summary>
        </member>
        <member name="F:MCS.Library.Services.SoapExtensionCallerType.ClientMethod">
            <summary>
            客户端方法
            </summary>
        </member>
        <member name="T:MCS.Library.Services.SoapExtensionCallerInfo">
            <summary>
            SOAP扩展信息的调用者信息
            </summary>
        </member>
        <member name="M:MCS.Library.Services.SoapExtensionCallerInfo.#ctor(System.String,MCS.Library.Services.SoapExtensionCallerType)">
            <summary>
            
            </summary>
            <param name="serviceName">服务名称</param>
            <param name="callerType">调用Extension的类型（客户端还是服务器端）</param>
        </member>
        <member name="P:MCS.Library.Services.SoapExtensionCallerInfo.ServiceName">
            <summary>
            服务名称
            </summary>
        </member>
        <member name="P:MCS.Library.Services.SoapExtensionCallerInfo.CallerType">
            <summary>
            调用者的类型
            </summary>
        </member>
        <member name="T:MCS.Library.Services.SoapMessageExtensions">
            <summary>
            SoapMessage的扩展方法
            </summary>
        </member>
        <member name="M:MCS.Library.Services.SoapMessageExtensions.GetMethodName(System.Web.Services.Protocols.SoapMessage)">
            <summary>
            从SoapMessage得到方法名称，去掉前面的名字空间
            </summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Services.WebMethodServerCounters">
            <summary>
            Web Service方法调用的Performance Counter
            </summary>
        </member>
        <member name="M:MCS.Library.Services.WebMethodServerCounters.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="instanceName">实例名称</param>
        </member>
        <member name="P:MCS.Library.Services.WebMethodServerCounters.RequestCount">
            <summary>
            总请求数
            </summary>
        </member>
        <member name="P:MCS.Library.Services.WebMethodServerCounters.RequestFailCount">
            <summary>
            请求失败的次数
            </summary>
        </member>
        <member name="P:MCS.Library.Services.WebMethodServerCounters.RequestSuccessCount">
            <summary>
            请求成功的次数
            </summary>
        </member>
        <member name="P:MCS.Library.Services.WebMethodServerCounters.RequestsPerSecond">
            <summary>
            每秒调用次数
            </summary>
        </member>
        <member name="P:MCS.Library.Services.WebMethodServerCounters.RequestAverageDurationBase">
            <summary>
            平均执行时间的基数
            </summary>
        </member>
        <member name="P:MCS.Library.Services.WebMethodServerCounters.RequestAverageDuration">
            <summary>
            平均执行时间的系数
            </summary>
        </member>
        <member name="T:MCS.Library.Services.WebMethodServerCountersInstaller">
            <summary>
            Web Service方法调用的Performance Counter的安装类
            </summary>
        </member>
        <member name="F:MCS.Library.Services.WebMethodServerCountersInstaller.Instance">
            <summary>
            性能监控指针的安装类实例，用于初始化PerformanceCounters类
            </summary>
        </member>
        <member name="M:MCS.Library.Services.WebMethodServerCountersInstaller.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Services.WebMethodServerCountersInstaller.Dispose(System.Boolean)">
            <summary> 
            清空已经存在安装信息
            </summary>
            <param name="disposing">是否清空</param>
        </member>
        <member name="M:MCS.Library.Services.WebMethodServerCountersInstaller.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:MCS.Library.Services.WebMethodServerCountersExtension">
            <summary>
            Web Service服务器端性能指针的扩展
            </summary>
        </member>
        <member name="M:MCS.Library.Services.WebMethodServerCountersExtension.GetInitializer(System.Type)">
            <summary>
            
            </summary>
            <param name="serviceType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.WebMethodServerCountersExtension.GetInitializer(System.Web.Services.Protocols.LogicalMethodInfo,System.Web.Services.Protocols.SoapExtensionAttribute)">
            <summary>
            
            </summary>
            <param name="methodInfo"></param>
            <param name="attribute"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Services.WebMethodServerCountersExtension.Initialize(System.Object)">
            <summary>
            
            </summary>
            <param name="initializer"></param>
        </member>
        <member name="M:MCS.Library.Services.WebMethodServerCountersExtension.ProcessMessage(System.Web.Services.Protocols.SoapMessage)">
            <summary>
            处理消息。
            BeforeDeserialize和AfterDeserialize是发生在服务内代码执行之前。
            BeforeSerialize和AfterSerialize是发生在服务内代码执行之后。
            整个执行时序是：ChainStream，BeforeDeserialize，AfterDeserialize，BeforeSerialize，AfterSerialize
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:MCS.Library.Validation.BaseValidatorAttribute">
            <summary>
            自定义校验器属性的抽象基类
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.BaseValidatorAttribute.Ruleset">
            <summary>
            校验规则集合
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.BaseValidatorAttribute.Tag">
            <summary>
            校验器附加的标签
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.BaseValidatorAttribute.MessageTemplate">
            <summary>
            校验器上附加的校验失败信息
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.CompositeValidatorBuilder">
            <summary>
            组合型校验器的创建
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.CompositionType">
            <summary>
            组合类型类型定义：与 或 
            </summary>
        </member>
        <member name="F:MCS.Library.Validation.CompositionType.And">
            <summary>
            与，表示附加在目标元素上的多个校验器全部校验正确，校验才可通过
            </summary>
        </member>
        <member name="F:MCS.Library.Validation.CompositionType.Or">
            <summary>
            或，表示附加在目标元素上的多个校验器只要有一个校验正确，校验即可通过
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.IClientValidatable">
            <summary>
            实现客户端校验的校验器须实现此接口
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.IClientValidatable.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns>script</returns>
        </member>
        <member name="M:MCS.Library.Validation.IClientValidatable.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.IClientValidatable.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.ValidationFactory">
            <summary>
            校验器的工厂类，用户通过这个类来创建校验器
            </summary>
            <remarks>
            校验器的工厂类，用户通过这个类来创建并获取目标类型上预定义的校验器
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ValidationFactory.CreateValidator(System.Type)">
            <summary>
            获取指定类型上定义的校验器
            </summary>
            <param name="targetType">目标类型</param>
            <returns>校验器</returns>
            <remarks>
            <code>
            
            </code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ValidationFactory.CreateValidator(System.Type,System.Collections.Generic.List{System.String})">
            <summary>
            获取指定类型上定义的校验器
            </summary>
            <param name="targetType">目标类型</param>
            <param name="unValidates">忽略的属性集合</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.ValidationFactory.CreateValidator(System.Type,System.String)">
            <summary>
            获取指定类型上定义的并属于指定规则集合的校验器
            </summary>
            <param name="targetType">目标类型</param>
            <param name="ruleset">校验器所属的规则集合</param>
            <returns>校验器</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\ValidationFactoryTest.cs" region="CreateValidatorForSpecificTypeAndRuleset" lang="cs" title="如何创建校验器" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ValidationFactory.CreateValidator(System.Type,System.String,System.Collections.Generic.List{System.String})">
            <summary>
            获取指定类型上定义的校验器
            </summary>
            <param name="targetType">目标类型</param>
            <param name="ruleset">校验器所属的规则集合</param>
            <param name="unValidates">忽略的属性集合</param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Validation.ValidationResult">
            <summary>
            校验器校验结果
            </summary>
            <remarks>
            定义校验器校验结果的数据结构
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ValidationResult.#ctor(System.String,System.Object,System.String,System.String,MCS.Library.Validation.Validator)">
            <summary>
            构造函数
            </summary>
            <param name="message">校验显示信息</param>
            <param name="target">校验对象</param>
            <param name="key">校验结果标识</param>
            <param name="tag">校验结果标记</param>
            <param name="validator">校验器</param>
        </member>
        <member name="M:MCS.Library.Validation.ValidationResult.#ctor(System.String,System.Object,System.String,System.String,MCS.Library.Validation.Validator,System.Collections.Generic.IEnumerable{MCS.Library.Validation.ValidationResult})">
            <summary>
            构造函数
            </summary>
            <param name="message">校验信息</param>
            <param name="target">校验对象</param>
            <param name="key">校验结果标识</param>
            <param name="tag">校验结果标记</param>
            <param name="validator">本次校验的校验器</param>
            <param name="nestedValidationResults">嵌套的校验结果（应用场景：或型的校验器，通常在这个结构内记录多个校验失败的信息）</param>
        </member>
        <member name="P:MCS.Library.Validation.ValidationResult.Key">
            <summary>
            标识
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.ValidationResult.Message">
            <summary>
            校验信息
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.ValidationResult.Tag">
            <summary>
            标记
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.ValidationResult.Target">
            <summary>
            被校验对象
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.ValidationResult.Validator">
            <summary>
            校验器
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.ValidationResult.NestedValidationResults">
            <summary>
            嵌套的校验结果
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.ValidationResults">
            <summary>
            校验结果枚举集合
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.ValidationResults.#ctor">
            <summary>
            构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.ValidationResults.AddResult(MCS.Library.Validation.ValidationResult)">
            <summary>
            向校验结果的枚举集合内添加校验结果对象
            </summary>
            <param name="result">校验结果对象</param>
        </member>
        <member name="M:MCS.Library.Validation.ValidationResults.IsValid">
            <summary>
            判断校验是否通过
            </summary>
            <returns>校验结果</returns>
        </member>
        <member name="M:MCS.Library.Validation.ValidationResults.ToString">
            <summary>
            将校验结果转换为字符串
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.ValidationResults.ToString(System.String)">
            <summary>
            将校验结果转换为字符串，中间以splitChars分割
            </summary>
            <param name="splitChars"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.ValidationResults.ResultCount">
            <summary>
            该校验结果集合中存放的校验结果数目
            </summary>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Validation.Validator">
            <summary>
            校验器抽象基类。
            用户如果要自定义一个校验器，需要实现这个基类。
            </summary>
            <remarks>
            这个基类定义了一个校验器所需要实现的最基本功能：校验器校验方法和校验结果如何记录。
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.Validator.#ctor">
            <summary>
            Validator构造方法
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.Validator.#ctor(System.String)">
            <summary>
            Validator构造方法
            </summary>
            <param name="messageTemplate">校验未成功所提示的信息</param>
        </member>
        <member name="M:MCS.Library.Validation.Validator.#ctor(System.String,System.String)">
            <summary>
            Validator构造方法
            </summary>
            <param name="messageTemplate">校验未成功所提示的信息</param>
            <param name="tag">校验器标签</param>
        </member>
        <member name="M:MCS.Library.Validation.Validator.Validate(System.Object)">
            <summary>
            使用校验器进行校验工作
            </summary>
            <param name="validateObject">校验对象</param>
            <returns>校验结果</returns>
            <remarks>
            <code source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\ValidationFactoryTest.cs" region="UseValidatorToValidate" lang="cs" title="如何使用校验器进行校验" />
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.Validator.Validate(System.Object,MCS.Library.Validation.ValidationResults)">
            <summary>
            使用校验器进行校验工作，将结果填充到validationResults中
            </summary>
            <param name="validateObject"></param>
            <param name="validationResults"></param>
        </member>
        <member name="M:MCS.Library.Validation.Validator.DoValidate(System.Object,System.Object,System.String,MCS.Library.Validation.ValidationResults)">
            <summary>
            校验器的校验逻辑与规则
            </summary>
            <param name="objectToValidate">被校验对象</param>
            <param name="currentObject">当前对象</param>
            <param name="key">当前校验的标识值</param>
            <param name="validateResults">校验结果</param>
        </member>
        <member name="M:MCS.Library.Validation.Validator.RecordValidationResult(MCS.Library.Validation.ValidationResults,System.String,System.Object,System.String)">
            <summary>
            将校验结果在给定的结果集合中进行记录
            </summary>
            <param name="validationResults">校验结果集</param>
            <param name="message">校验结果信息</param>
            <param name="target">被校验对象</param>
            <param name="key">校验结果标识值</param>
        </member>
        <member name="M:MCS.Library.Validation.Validator.RecordValidationResult(MCS.Library.Validation.ValidationResults,System.String,System.Object,System.String,System.Collections.Generic.IEnumerable{MCS.Library.Validation.ValidationResult})">
            <summary>
            将校验结果在给定的结果集合中进行记录
            </summary>
            <param name="validationResults">校验结果集</param>
            <param name="message">校验结果信息</param>
            <param name="target">被校验对象</param>
            <param name="key">校验结果标识值</param>
            <param name="nestedValidationResults">嵌套的结果列表</param>
        </member>
        <member name="P:MCS.Library.Validation.Validator.MessageTemplate">
            <summary>
            校验未成功所提示的信息
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.Validator.Tag">
            <summary>
            校验器标签
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.Validator.Source">
            <summary>
            Validator的来源，通常针对于Property或Field上的Validator，指定了属性名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.ValidatorAttribute">
            <summary>
            自定义校验器属性的抽象基类　
            </summary>
            <remarks>
            这个类间接从系统的自定义属性基类(Attribute)下派生
            用于将用户定义的校验器自定义信息与目标元素相关联　
            主要用来生成相应的校验器
            目标元素为：类(Class) 、属性(Property)、字段(Field)
            除本模块提供的一些基本校验器之外，用户自定义的校验器属性都需要实现这个抽象基类
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ValidatorAttribute.CreateValidator(System.Type,System.Type)">
            <summary>
            使用该方法创建校验器
            </summary>
            <param name="targetType">目标类型</param>
            <param name="ownerType">源对象类型，目前在程序当中未做处理，留待以后扩展使用</param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.ValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            根据自定义的校验器属性创建一个校验器实例的抽象方法
            在开发者编写自定义校验器的时候需要实现这个抽象方法
            </summary>
            <param name="targetType">目标类型</param>
            <returns>创建好的检验器</returns>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\AddressValidatorAttribute.cs" region="HowToImplementedCreateValidator" lang="cs" title="如何实现校验器的创建"  ></code>
            </remarks>
        </member>
        <member name="P:MCS.Library.Validation.ValidatorAttribute.Validator">
            <summary>
            获得校验器
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.DateTimeEmptyValidator">
            <summary>
            日期类型的为空判断的校验器
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeEmptyValidator.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="messageTemplate"></param>
            <param name="tag"></param>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeEmptyValidator.DoValidate(System.Object,System.Object,System.String,MCS.Library.Validation.ValidationResults)">
            <summary>
            
            </summary>
            <param name="objectToValidate"></param>
            <param name="currentObject"></param>
            <param name="key"></param>
            <param name="validationResults"></param>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeEmptyValidator.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeEmptyValidator.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.DateTimeEmptyValidator.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.DateTimeEmptyValidatorAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeEmptyValidatorAttribute.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeEmptyValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            创建校验器
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Validation.DateTimeRangeValidator">
            <summary>
            时间校验器
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeRangeValidator.#ctor(System.DateTime,System.DateTime,System.String,System.String)">
            <summary>
            初始化
            </summary>
            <param name="lowerBound">下限</param>
            <param name="upperBound">上限</param>
            <param name="messageTemplate">校验未成功所提示的信息</param>
            <param name="tag">校验器标签</param>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeRangeValidator.DoValidate(System.Object,System.Object,System.String,MCS.Library.Validation.ValidationResults)">
            <summary>
            校验数据
            </summary>
            <param name="objectToValidate"></param>
            <param name="currentTarget"></param>
            <param name="key"></param>
            <param name="validationResults"></param>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeRangeValidator.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeRangeValidator.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.DateTimeRangeValidator.LowerBound">
            <summary>
            下限
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.DateTimeRangeValidator.UpperBound">
            <summary>
            上限
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.DateTimeRangeValidator.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.DateTimeRangeValidatorAttribute">
            <summary>
            时间校验属性
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeRangeValidatorAttribute.#ctor(System.String,System.String)">
            <summary>
            初始化
            </summary>
            <param name="lowerBound">下限</param>
            <param name="upperBound">上限</param>
        </member>
        <member name="M:MCS.Library.Validation.DateTimeRangeValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.DateTimeRangeValidatorAttribute.LowerBound">
            <summary>
            下限
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.DateTimeRangeValidatorAttribute.UpperBound">
            <summary>
            上限
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.EnumDefaultValueValidator">
            <summary>
            枚举类型是否是缺省值的校验器（如果是，则相当于为空，报出错误）
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.EnumDefaultValueValidator.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="messageTemplate"></param>
            <param name="tag"></param>
        </member>
        <member name="M:MCS.Library.Validation.EnumDefaultValueValidator.DoValidate(System.Object,System.Object,System.String,MCS.Library.Validation.ValidationResults)">
            <summary>
            
            </summary>
            <param name="objectToValidate"></param>
            <param name="currentObject"></param>
            <param name="key"></param>
            <param name="validateResults"></param>
        </member>
        <member name="M:MCS.Library.Validation.EnumDefaultValueValidator.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.EnumDefaultValueValidator.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.EnumDefaultValueValidator.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.EnumDefaultValueValidatorAttribute">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.EnumDefaultValueValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.IntegerRangeValidator.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.IntegerRangeValidator.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.IntegerRangeValidator.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.IntegerRangeValidatorAttribute">
            <summary>
            整形值范围判断校验器属性类
            </summary>
            <remarks>
            整形值范围判断校验器属性
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.IntegerRangeValidatorAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
            IntegerRangeValidatorAttribute构造函数
            </summary>
            <param name="lowerBound">整形值下限</param>
            <param name="upperBound">整形值上限</param>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\HelperClass\Student.cs" region="IntegerRangeValidatorAttributeUsage" lang="cs" title="如何添加整形范围校验器属性"  ></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.IntegerRangeValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            重载基类的方法，调用IntegerRangeValidator的构造方式创建一个IntegerRangeValidator实例
            </summary>
            <param name="targetType">目标类型，在本默认实现中未使用到该参数</param>
            <returns>IntegerRangeValidator实例</returns>
        </member>
        <member name="P:MCS.Library.Validation.IntegerRangeValidatorAttribute.LowerBound">
            <summary>
            整形值下限
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.IntegerRangeValidatorAttribute.UpperBound">
            <summary>
            整形值上限
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.NotNullValidator.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.NotNullValidator.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.NotNullValidator.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.NotNullValidatorAttribute">
            <summary>
            对象不为空的校验器属性类
            </summary>
            <remarks>
            对象不为空的校验器属性类
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.NotNullValidatorAttribute.#ctor">
            <summary>
            构造函数
            </summary>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\HelperClass\Student.cs" region="NotNullValidatorAttributeUsage" lang="cs" title="如何添加对象非空校验器属性"  ></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.NotNullValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            重载基类的方法，调用NotNullValidator的构造方式创建一个NotNullValidator实例
            </summary>
            <param name="targetType">目标类型，在本默认实现中未使用到该参数</param>
            <returns>NotNullValidator实例</returns>
        </member>
        <member name="T:MCS.Library.Validation.ObjectCollectionValidator">
            <summary>
            对象集合的校验器，会依次调用对象集合中的对象进行校验
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.ObjectCollectionValidator.#ctor(System.Type,System.String)">
            <summary>
            ObjectCollectionValidator的构造函数
            </summary>
            <param name="targetType">目标类型</param>
            <param name="targetRuleset">所校验类型所属的校验规则集</param>
        </member>
        <member name="T:MCS.Library.Validation.ObjectCollectionValidatorAttribute">
            <summary>
            对象集合校验器属性类
            </summary>
            <remarks>
            对象集合校验器属性类
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ObjectCollectionValidatorAttribute.#ctor(System.Type)">
            <summary>
            构造方法
            </summary>
            <param name="targetType">目标类型</param>
        </member>
        <member name="M:MCS.Library.Validation.ObjectCollectionValidatorAttribute.#ctor(System.Type,System.String)">
            <summary>
            构造方法
            </summary>
            <param name="targetType">目标类型</param>
            <param name="targetRuleset">校验器规则集合</param>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\HelperClass\Customer.cs" region="ObjectCollectionValidatorAttributeUsage" lang="cs" title="如何添加对象集合校验器属性"  ></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ObjectCollectionValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            重载基类的方法，调用ObjectCollectionValidator的构造方式创建一个ObjectCollectionValidator实例
            </summary>
            <param name="targetType">目标类型，，在本默认实现中未使用到该参数</param>
            <returns>ObjectCollectionValidator实例</returns>
        </member>
        <member name="T:MCS.Library.Validation.ObjectNullValidator">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.ObjectNullValidator.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="messageTemplate"></param>
            <param name="tag"></param>
        </member>
        <member name="M:MCS.Library.Validation.ObjectNullValidator.DoValidate(System.Object,System.Object,System.String,MCS.Library.Validation.ValidationResults)">
            <summary>
            
            </summary>
            <param name="objectToValidate"></param>
            <param name="currentObject"></param>
            <param name="key"></param>
            <param name="validateResults"></param>
        </member>
        <member name="M:MCS.Library.Validation.ObjectNullValidator.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.ObjectNullValidator.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.ObjectNullValidator.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.ObjectNullValidatorAttribute">
             <summary>
            
             </summary>
        </member>
        <member name="M:MCS.Library.Validation.ObjectNullValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Validation.ObjectValidatorAttribute">
            <summary>
            对象校验器属性
            </summary>
            <remarks>
            对象校验器属性类，附加在对象类型的Property和Field上面。
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ObjectValidatorAttribute.#ctor">
            <summary>
            构造函数
            </summary>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\HelperClass\Customer.cs" region="ObjectValidatorAttributeUsage" lang="cs" title="如何添加对象校验器属性"  ></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ObjectValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            重载基类的方法，调用ValidationFactory直接构造目标类型的校验器
            </summary>
            <param name="targetType">目标类型</param>
            <returns>目标类型的Validator实例</returns>
        </member>
        <member name="T:MCS.Library.Validation.RangeChecker`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:MCS.Library.Validation.RangeChecker`1.#ctor(`0,`0)">
            <summary>
            
            </summary>
            <param name="lowerBound"></param>
            <param name="upperBound"></param>
        </member>
        <member name="M:MCS.Library.Validation.RangeChecker`1.IsInRange(`0)">
            <summary>
            
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.RegexValidator.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.RegexValidator.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.RegexValidator.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.RegexValidatorAttribute">
            <summary>
            正则表达式校验器属性类，校验被校验对象是否匹配正则表达式
            </summary>
            <remarks>
            正则表达式校验器属性类，校验被校验对象是否匹配正则表达式
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.RegexValidatorAttribute.#ctor(System.String)">
            <summary>
            构造方法
            </summary>
            <param name="pattern">正则表达式</param>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\HelperClass\Address.cs" region="RegexValidatorAttributeUsage" lang="cs" title="如何添加正则表达式校验器属性"  ></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.RegexValidatorAttribute.#ctor(System.String,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            构造方法
            </summary>
            <param name="pattern">正则表达式</param>
            <param name="options">正则表达式选项枚举值</param>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\HelperClass\Student.cs" region="RegexValidatorAttributeUsage2" lang="cs" title="如何添加正则表达式校验器属性"  ></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.RegexValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            重载基类的方法，调用RegexValidator的构造方法直接构造RegexValidator校验器
            </summary>
            <param name="targetType">目标类型，在本默认实现中未使用到该参数</param>
            <returns>RegexValidator实例</returns>
        </member>
        <member name="P:MCS.Library.Validation.RegexValidatorAttribute.Pattern">
            <summary>
            表达式参数
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.RegexValidatorAttribute.Options">
            <summary>
            认证选项
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.StringEmptyValidator">
            <summary>
            字符串为空的校验逻辑
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.StringEmptyValidator.#ctor(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="messageTemplate"></param>
            <param name="tag"></param>
        </member>
        <member name="M:MCS.Library.Validation.StringEmptyValidator.DoValidate(System.Object,System.Object,System.String,MCS.Library.Validation.ValidationResults)">
            <summary>
            
            </summary>
            <param name="objectToValidate"></param>
            <param name="currentObject"></param>
            <param name="key"></param>
            <param name="validationResults"></param>
        </member>
        <member name="M:MCS.Library.Validation.StringEmptyValidator.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.StringEmptyValidator.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.StringEmptyValidator.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.StringEmptyValidatorAttribute">
            <summary>
            字符串为空校验构造器属性类，校验字符串是否为空
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.StringEmptyValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            创建校验器
            </summary>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.StringLengthValidator.GetClientValidateScript">
            <summary>
            获取客户端校验方法脚本
            </summary>
            <returns></returns>
        </member>
        <member name="M:MCS.Library.Validation.StringLengthValidator.GetClientValidateAdditionalData(System.Object)">
            <summary>
            获取客户端校验附加数据，比如正则表达式，范围值，等等
            </summary>
            <returns></returns>
        </member>
        <member name="P:MCS.Library.Validation.StringLengthValidator.ClientValidateMethodName">
            <summary>
            客户端校验函数名称
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.StringLengthValidatorAttribute">
            <summary>
            字符串长度构造器属性类，校验字符串长度是否在指定的范围内
            </summary>
            <remarks>
            字符串长度构造器属性类，校验字符串长度是否在指定的范围内
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.StringLengthValidatorAttribute.#ctor(System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="upperBound">字符串长度上限</param>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\HelperClass\Student.cs" region="StringLengthValidatorAttributeDemo" lang="cs" title="如何添加字符串长度校验器属性"  ></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.StringLengthValidatorAttribute.#ctor(System.Int32,System.Int32)">
            <summary>
            构造函数
            </summary>
            <param name="lowerBound">字符串长度下限</param>
            <param name="upperBound">字符串长度上限</param>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\HelperClass\Student.cs" region="StringLengthValidatorAttributeDemo2" lang="cs" title="如何添加字符串长度校验器属性"  ></code>
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.StringLengthValidatorAttribute.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            初始化
            </summary>
            <param name="methodName">客户端校验方法名称</param>
            <param name="lowerBound">下限</param>
            <param name="upperBound">上限</param>
        </member>
        <member name="M:MCS.Library.Validation.StringLengthValidatorAttribute.DoCreateValidator(System.Type)">
            <summary>
            重载基类的方法，调用StringLengthValidator构造方法创建StringLengthValidator
            </summary>
            <param name="targetType">目标类型，在本默认实现中未使用到该参数</param>
            <returns>字符串长度校验器实例</returns>
        </member>
        <member name="P:MCS.Library.Validation.StringLengthValidatorAttribute.LowerBound">
            <summary>
            区间的最小值
            </summary>
        </member>
        <member name="P:MCS.Library.Validation.StringLengthValidatorAttribute.UpperBound">
            <summary>
            区间最大值
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.ValidatorCompositionAttribute">
            <summary>
            附加在同一目标对象上的校验器之间的组合关系，分为And 和 Or
            </summary>
            <remarks>
            附加在同一目标对象上的校验器之间的组合关系，分为And 和 Or
            And 的情况： 几个校验规则全部符合，校验通过
            Or 的情况：只要有一个校验规则符合情况，校验通过
            </remarks>
        </member>
        <member name="M:MCS.Library.Validation.ValidatorCompositionAttribute.#ctor(MCS.Library.Validation.CompositionType)">
            <summary>
            ValidatorCompositionAttribute 的构造函数
            </summary>
            <param name="compositionType">Validator的组合方式</param>
            <remarks>
            <code  source="..\Framework\TestProjects\DeluxeWorks.Library.Test\Validation\HelperClass\Customer.cs" region="CompositionValidatorUsage" lang="cs" title="如何添加组合型校验器属性"  ></code>
            </remarks>
        </member>
        <member name="P:MCS.Library.Validation.ValidatorCompositionAttribute.CompositionType">
            <summary>
            组合方式
            </summary>
        </member>
        <member name="T:MCS.Library.Validation.ValueAccess">
            <summary>
            值访问的基类
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.ValueAccess.GetValue(System.Object)">
            <summary>
            得到值
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:MCS.Library.Validation.ValueAccessValidator">
            <summary>
            
            </summary>
        </member>
        <member name="M:MCS.Library.Validation.ValueAccessValidator.#ctor(MCS.Library.Validation.ValueAccess,MCS.Library.Validation.Validator)">
            <summary>
            
            </summary>
            <param name="valueAccess"></param>
            <param name="innerValidator"></param>
        </member>
        <member name="M:MCS.Library.Validation.ValueAccessValidator.#ctor(MCS.Library.Validation.ValueAccess,MCS.Library.Validation.Validator,System.String)">
            <summary>
            
            </summary>
            <param name="valueAccess"></param>
            <param name="innerValidator"></param>
            <param name="key"></param>
        </member>
        <member name="M:MCS.Library.Validation.ValueAccessValidator.DoValidate(System.Object,System.Object,System.String,MCS.Library.Validation.ValidationResults)">
            <summary>
            
            </summary>
            <param name="objectToValidate"></param>
            <param name="currentTarget"></param>
            <param name="key"></param>
            <param name="validationResults"></param>
        </member>
    </members>
</doc>
